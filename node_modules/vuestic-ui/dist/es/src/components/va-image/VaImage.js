import { defineComponent, ref, computed, onBeforeMount, onBeforeUnmount, watch, nextTick, useCssVars, resolveComponent, openBlock, createBlock, mergeProps, withCtx, withDirectives, createElementVNode, renderSlot, createCommentVNode, createElementBlock, vShow, createVNode } from "vue";
import { p as pick_1 } from "../../../vendor.js";
import { V as VaAspectRatio } from "../va-aspect-ratio/index.js";
import { V as VaFallback } from "../va-fallback/index.js";
import { u as useNativeImgAttributesProps, a as useNativeImgAttributes } from "./hooks/useNativeImgAttributes.js";
import { u as useGlobalConfig } from "../../services/global-config/global-config.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useDeprecated } from "../../composables/useDeprecated.js";
import { u as useIntersectionObserver } from "../../composables/useIntersectionObserver.js";
import { u as useIsMounted } from "../../composables/useIsMounted.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaImage_vue_vue_type_style_index_0_lang = "";
const VaFallbackProps = extractComponentProps(VaFallback);
const __default__ = defineComponent({
  name: "VaImage",
  components: { VaAspectRatio, VaFallback },
  emits: ["loaded", "error", "fallback"],
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v) => v >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" },
    contain: { type: Boolean, default: false }
  },
  setup(props, { emit, slots }) {
    useDeprecated(["contain"]);
    const root = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a = image.value) == null ? void 0 : _a.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root, props.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a;
        if (!((_a = image.value) == null ? void 0 : _a.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props.src, init);
    const isPlaceholderPassed = computed(() => {
      var _a;
      return ((_a = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a;
      return isLoading.value && !((_a = slots == null ? void 0 : slots.loader) == null ? void 0 : _a.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a;
      return isError.value && (!((_a = slots == null ? void 0 : slots.error) == null ? void 0 : _a.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick_1(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a = useGlobalConfig()) == null ? void 0 : _a.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => {
      if (props.contain) {
        return "contain";
      }
      return props.fit;
    });
    return {
      fitComputed,
      root,
      image,
      isLoading,
      handleLoad,
      isError,
      handleError,
      isReadyForRender,
      isPlaceholderShown,
      isSuccessfullyLoaded,
      imgAttributesComputed,
      aspectRationAttributesComputed,
      isAnyFallbackPassed,
      fallbackProps
    };
  }
});
const __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "64b11d12": _ctx.fitComputed
  }));
};
const __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
const _sfc_main = __default__;
const _hoisted_1 = ["aria-busy"];
const _hoisted_2 = {
  key: 0,
  class: "va-image__overlay"
};
const _hoisted_3 = {
  key: 1,
  class: "va-image__error"
};
const _hoisted_4 = {
  key: 2,
  class: "va-image__loader"
};
const _hoisted_5 = {
  key: 3,
  class: "va-image__placeholder"
};
const _hoisted_6 = ["src"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_fallback = resolveComponent("va-fallback");
  const _component_va_aspect_ratio = resolveComponent("va-aspect-ratio");
  return openBlock(), createBlock(_component_va_aspect_ratio, mergeProps({
    ref: "root",
    class: "va-image"
  }, _ctx.aspectRationAttributesComputed), {
    default: withCtx(() => [
      withDirectives(createElementVNode("picture", {
        class: "va-image__content",
        "aria-busy": _ctx.isLoading
      }, [
        _ctx.$slots.sources ? renderSlot(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode("", true),
        _ctx.isReadyForRender ? (openBlock(), createElementBlock("img", mergeProps({
          key: 1,
          ref: "image"
        }, _ctx.imgAttributesComputed, {
          onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
          onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
        }), null, 16)) : createCommentVNode("", true)
      ], 8, _hoisted_1), [
        [vShow, _ctx.isSuccessfullyLoaded]
      ]),
      _ctx.$slots.default && _ctx.isSuccessfullyLoaded ? (openBlock(), createElementBlock("div", _hoisted_2, [
        renderSlot(_ctx.$slots, "default")
      ])) : createCommentVNode("", true),
      _ctx.isError && (_ctx.$slots.error || _ctx.isAnyFallbackPassed) ? (openBlock(), createElementBlock("div", _hoisted_3, [
        renderSlot(_ctx.$slots, "error", {}, () => [
          createVNode(_component_va_fallback, mergeProps(_ctx.fallbackProps, {
            onFallback: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("fallback"))
          }), null, 16)
        ])
      ])) : createCommentVNode("", true),
      _ctx.isLoading && _ctx.$slots.loader ? (openBlock(), createElementBlock("div", _hoisted_4, [
        renderSlot(_ctx.$slots, "loader")
      ])) : createCommentVNode("", true),
      _ctx.isPlaceholderShown ? (openBlock(), createElementBlock("div", _hoisted_5, [
        renderSlot(_ctx.$slots, "placeholder", {}, () => [
          _ctx.$props.placeholderSrc ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.$props.placeholderSrc,
            alt: ""
          }, null, 8, _hoisted_6)) : createCommentVNode("", true)
        ])
      ])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16);
}
var _VaImage = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaImage as _ };

import './VaImage.css';
//# sourceMappingURL=VaImage.js.map
