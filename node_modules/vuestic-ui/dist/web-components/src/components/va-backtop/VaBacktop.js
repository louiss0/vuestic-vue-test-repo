import { defineComponent, ref, computed, onMounted, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeStyle, withKeys, withModifiers, renderSlot, createVNode, createCommentVNode } from "vue";
import { i as isServer } from "../../utils/ssr.js";
import { w as warn } from "../../utils/console.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
import { V as VaButton } from "../va-button/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var _style_0 = ":root,\n:host {\n  --va-backtop-position: fixed;\n  --va-backtop-top: auto;\n  --va-backtop-left: auto;\n  --va-backtop-right: auto;\n  --va-backtop-bottom: auto;\n  --va-backtop-cursor: pointer;\n  --va-backtop-z-index: 3;\n}\n.va-backtop {\n  position: var(--va-backtop-position);\n  top: var(--va-backtop-top);\n  left: var(--va-backtop-left);\n  right: var(--va-backtop-right);\n  bottom: var(--va-backtop-bottom);\n  cursor: var(--va-backtop-cursor);\n  z-index: var(--va-backtop-z-index);\n  font-family: var(--va-font-family);\n}";
const _sfc_main = defineComponent({
  name: "VaBacktop",
  components: { VaButton },
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    }
  },
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > props.visibilityHeight;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    return {
      computedStyle,
      visible,
      scrollToTop,
      ...useTranslation()
    };
  }
});
const _hoisted_1 = ["aria-label"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": _ctx.t("backToTop"),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "va-arrow-up",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 44, _hoisted_1)) : createCommentVNode("", true);
}
var _VaBacktop = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["styles", [...(   VaButton .styles || []), _style_0]]]);
export { _VaBacktop as _ };
//# sourceMappingURL=VaBacktop.js.map
