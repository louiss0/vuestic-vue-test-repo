import { defineComponent, ref, computed, toRefs, watch, resolveComponent, openBlock, createElementBlock, Fragment, renderSlot, normalizeProps, mergeProps, renderList, toDisplayString, createTextVNode, createCommentVNode, withDirectives, createElementVNode, withKeys, withModifiers, vModelText, guardReactiveProps, createBlock } from "vue";
import { V as VaBadge } from "../../../va-badge/index.js";
import { V as VaIcon } from "../../../va-icon/index.js";
import { _ as _export_sfc } from "../../../../../plugin-vue_export-helper.js";
var VaSelectContent_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSelectContent",
  components: { VaBadge, VaIcon },
  props: {
    value: { type: Array, required: true },
    valueString: { type: String },
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hiddenSelectedOptionsAmount: { type: Number, default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(props, { emit }) {
    const autocompleteInput = ref();
    const isPlaceholder = computed(() => props.placeholder && !props.valueString);
    const toggleHiddenOptionsState = () => emit("toggle-hidden");
    const { value, focused } = toRefs(props);
    const autocompleteInputValueComputed = computed({
      get: () => props.autocompleteInputValue,
      set: (v) => emit("autocomplete-input", v)
    });
    watch(focused, (newValue) => {
      var _a, _b;
      if (!props.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a = autocompleteInput.value) == null ? void 0 : _a.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e) => {
      if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit("delete-last-selected");
      }
    };
    return {
      isPlaceholder,
      toggleHiddenOptionsState,
      autocompleteInputValueComputed,
      autocompleteInput,
      handleBackspace
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "va-select-content__autocomplete"
};
const _hoisted_2 = ["placeholder", "disabled"];
const _hoisted_3 = {
  key: 1,
  class: "va-select-content__placeholder"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_badge = resolveComponent("va-badge");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.$props.autocomplete ? (openBlock(), createElementBlock("div", _hoisted_1, [
      _ctx.$props.multiple || _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 0 }, {
        value: _ctx.$props.value,
        valueString: _ctx.$props.valueString,
        tabindex: _ctx.$props.tabindex
      })), () => [
        _ctx.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.value, (option, index) => {
          return openBlock(), createElementBlock("span", {
            key: _ctx.$props.getText(option)
          }, toDisplayString(`${_ctx.$props.getText(option)}${index + 1 === _ctx.value.length ? "" : ", "}`), 1);
        }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.$props.valueString), 1)
        ], 64))
      ]) : createCommentVNode("", true),
      withDirectives(createElementVNode("input", {
        ref: "autocompleteInput",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.autocompleteInputValueComputed = $event),
        placeholder: _ctx.$props.placeholder,
        disabled: _ctx.$props.disabled,
        autocomplete: "off",
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
          _cache[4] || (_cache[4] = (...args) => _ctx.handleBackspace && _ctx.handleBackspace(...args))
        ]
      }, null, 40, _hoisted_2), [
        [vModelText, _ctx.autocompleteInputValueComputed]
      ])
    ])) : _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 2 }, {
      valueString: _ctx.$props.valueString,
      value: _ctx.$props.value,
      tabindex: _ctx.$props.tabindex
    })), () => [
      createTextVNode(toDisplayString(_ctx.$props.valueString), 1)
    ]),
    renderSlot(_ctx.$slots, "hiddenOptionsBadge", normalizeProps(guardReactiveProps({
      amount: _ctx.$props.hiddenSelectedOptionsAmount,
      isShown: _ctx.$props.isAllOptionsShown,
      toggle: _ctx.toggleHiddenOptionsState
    })), () => [
      _ctx.$props.hiddenSelectedOptionsAmount && !_ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(_component_va_badge, {
        key: 0,
        class: "va-select-content__state-icon",
        color: "info",
        text: `+${_ctx.$props.hiddenSelectedOptionsAmount}`,
        tabindex: _ctx.$props.tabindex,
        onClick: withModifiers(_ctx.toggleHiddenOptionsState, ["stop"])
      }, null, 8, ["text", "tabindex", "onClick"])) : createCommentVNode("", true)
    ]),
    renderSlot(_ctx.$slots, "hideOptionsButton", normalizeProps(guardReactiveProps({
      isShown: _ctx.$props.isAllOptionsShown,
      toggle: _ctx.toggleHiddenOptionsState
    })), () => [
      _ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(_component_va_icon, {
        key: 0,
        role: "button",
        class: "va-select-content__state-icon",
        size: "small",
        name: "reply",
        tabindex: _ctx.$props.tabindex,
        onClick: withModifiers(_ctx.toggleHiddenOptionsState, ["stop"])
      }, null, 8, ["tabindex", "onClick"])) : createCommentVNode("", true)
    ])
  ], 64);
}
var _VaSelectContent = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSelectContent as _ };

import './VaSelectContent.css';
//# sourceMappingURL=VaSelectContent.js.map
