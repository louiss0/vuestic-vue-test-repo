import { defineComponent, shallowRef, ref, onMounted, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, renderSlot, normalizeProps, guardReactiveProps, withModifiers, createVNode } from "vue";
import { c as clamp_1, b as isNumber_1, e as isString_1 } from "../../../vendor.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { w as warn } from "../../utils/console.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useResizeObserver } from "../../composables/useResizeObserver.mjs";
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useSplitDraggerProps, a as useSplitDragger } from "./useSplitDragger.mjs";
import { V as VaDivider } from "../va-divider/index.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
var VaSplit_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSplit",
  components: { VaDivider },
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v) => v <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 }
  },
  emits: useStatefulEmits,
  setup: (props, { emit }) => {
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a;
      const { width, height } = ((_a = splitPanelsContainer.value) == null ? void 0 : _a.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber_1(v)) {
        return v;
      }
      v.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v) => {
      if (v === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString_1(v) || isNumber_1(v)) {
        minPercents = convertToPercents(v, "min");
      }
      if (Array.isArray(v)) {
        minPercents = convertToPercents(v[0], "min");
        maxPercents = convertToPercents(v[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents != null ? minPercents : 0, max: maxPercents != null ? maxPercents : 100 };
    };
    const startPanelMinMax = computed(() => {
      var _a;
      return (_a = getPanelMinMax(props.limits[0])) != null ? _a : { min: 0, max: 100 };
    });
    const endPanelMinMax = computed(() => {
      var _a;
      return (_a = getPanelMinMax(props.limits[1])) != null ? _a : { min: 0, max: 100 };
    });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > props.snappingRange;
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp_1(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v) => {
      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v;
    }, { immediate: true });
    watch(currentSplitterPosition, (v) => {
      splitterPosition.value = v;
    });
    watch(isDragging, (v) => {
      if (!v) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    return {
      ...useTranslation(),
      splitPanelsContainer,
      containerSize,
      startDragging,
      getPanelStyle,
      maximizePanel,
      classComputed,
      draggerStyleComputed
    };
  }
});
const _hoisted_1 = ["aria-label"];
const _hoisted_2 = { class: "va-split__dragger" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_divider = resolveComponent("va-divider");
  return openBlock(), createElementBlock("section", {
    ref: "splitPanelsContainer",
    class: normalizeClass(["va-split", _ctx.classComputed]),
    "aria-label": _ctx.t("splitPanels")
  }, [
    createElementVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("start"))
    }, [
      renderSlot(_ctx.$slots, "start", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4),
    createElementVNode("div", _hoisted_2, [
      createElementVNode("div", {
        class: "va-split__dragger__overlay",
        style: normalizeStyle(_ctx.draggerStyleComputed),
        onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onTouchstart: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onDblclick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.maximizePanel && _ctx.maximizePanel(...args), ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "grabber", {}, () => [
          createVNode(_component_va_divider, {
            class: "va-split__dragger__default",
            vertical: !_ctx.$props.vertical
          }, null, 8, ["vertical"])
        ])
      ], 36)
    ]),
    createElementVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("end"))
    }, [
      renderSlot(_ctx.$slots, "end", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4)
  ], 10, _hoisted_1);
}
var _VaSplit = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSplit as _ };
//# sourceMappingURL=VaSplit.mjs.map
