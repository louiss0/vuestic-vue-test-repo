import { getCurrentInstance, computed } from "vue";
import { u as useElementRef } from "../../../composables/useElementRef.mjs";
import { u as useIntersectionObserver } from "../../../composables/useIntersectionObserver.mjs";
const useTableScrollProps = {
  scrollTopMargin: { type: Number, default: 0 },
  scrollBottomMargin: { type: Number, default: 0 }
};
const useTableScrollEmits = ["scroll:top", "scroll:bottom"];
const useTableScroll = (props, emit) => {
  var _a;
  const vNodeProps = (_a = getCurrentInstance()) == null ? void 0 : _a.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const isObservable = computed(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
      }
    });
  };
  const targets = computed(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed(() => {
    var _a2, _b;
    return {
      root: scrollContainer.value,
      rootMargin: `${(_a2 = props.scrollTopMargin) != null ? _a2 : 0}px 0px ${(_b = props.scrollBottomMargin) != null ? _b : 0}px 0px`
    };
  });
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
};
export { useTableScrollEmits as a, useTableScroll as b, useTableScrollProps as u };
//# sourceMappingURL=useTableScroll.mjs.map
