import { defineComponent, shallowRef, ref, computed, watch, nextTick, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createVNode, createSlots, withModifiers, withKeys, createCommentVNode, renderList, renderSlot, normalizeProps, guardReactiveProps, normalizeStyle } from "vue";
import { p as pick_1 } from "../../../vendor.js";
import { w as warn } from "../../utils/console.js";
import { u as useBem } from "../../composables/useBem.js";
import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as unwrapEl } from "../../utils/unwrapEl.js";
import { f as focusElement, b as blurElement } from "../../utils/focus.js";
import { u as useFocusDeep } from "../../composables/useFocusDeep.js";
import { u as useFormProps } from "../../composables/useForm.js";
import { u as useLoadingProps } from "../../composables/useLoading.js";
import { u as useMaxSelectionsProps, a as useMaxSelections } from "../../composables/useMaxSelections.js";
import { a as useValidationEmits, u as useValidationProps, b as useValidation } from "../../composables/useValidation.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
import { u as useThrottleProps } from "../../composables/useThrottle.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaInput } from "../va-input/index.js";
import { V as VaSelectOptionList } from "./components/VaSelectOptionList/index.js";
import { V as VaSelectContent } from "./components/VaSelectContent/index.js";
import { u as useMaxVisibleOptionsProps, a as useMaxVisibleOptions } from "./hooks/useMaxVisibleOptions.js";
import { u as useToggleIconProps, a as useToggleIcon } from "./hooks/useToggleIcon.js";
import { u as useStringValueProps, a as useStringValue } from "./hooks/useStringValue.js";
import { u as useAutocompleteProps, a as useAutocomplete } from "./hooks/useAutocomplete.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.js";
var _style_0 = ":root,\n:host {\n  --va-select-cursor: pointer;\n  --va-select-dropdown-border-radius: 4px;\n  --va-select-dropdown-background: var(--va-background-secondary);\n  --va-select-box-shadow: 0 4px 8px rgba(59, 63, 73, 0.15);\n  --va-select-min-width: var(--va-form-element-min-width);\n  --va-select-state-icon-margin-left: 0.25rem;\n}\n.va-select {\n  min-width: var(--va-select-min-width);\n}\n.va-select .va-input-wrapper__text {\n  line-height: normal;\n  flex-wrap: wrap;\n}\n.va-select-anchor__input {\n  cursor: var(--va-select-cursor);\n  flex: 1;\n}\n.va-select-anchor--nowrap .va-input-wrapper__text {\n  flex-wrap: nowrap;\n}\n.va-select-dropdown__content {\n  overflow: hidden;\n  border-bottom-right-radius: var(--va-select-dropdown-border-radius);\n  border-bottom-left-radius: var(--va-select-dropdown-border-radius);\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n  box-shadow: var(--va-select-box-shadow);\n  padding: 0;\n}\n.va-select-dropdown__content-search-input {\n  min-width: auto;\n  width: 100%;\n}\n.va-select-dropdown__options-wrapper {\n  background: var(--va-select-dropdown-background);\n  overflow-y: auto;\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n}";
const VaDropdownProps = extractComponentProps(
  VaDropdown,
  ["keyboardNavigation", "offset", "stateful", "keepAnchorWidth", "closeOnContentClick", "innerAnchorSelector", "modelValue"]
);
const _sfc_main = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectContent,
    VaSelectOptionList,
    VaIcon,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: {
    ...VaDropdownProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    requiredMark: { type: Boolean, default: false }
  },
  setup(props, { emit, slots }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getOptionByValue, getValue, getText, getTrackBy } = useSelectableList(props);
    const onScrollBottom = () => emit("scroll-bottom");
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props);
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string or a number for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue));
        } else {
          emit("update:modelValue", getValue(value));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue(option1);
      const two = getValue(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(getValue(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue(option), getValue(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : { ...option };
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => [searchInput.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchInput.value || autocompleteValue.value);
        searchInput.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value && hoveredOption.value !== 0) {
        return;
      }
      if (!showDropdownContent.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchInput.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const { tp, t } = useTranslation();
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps).value,
      closeOnContentClick: closeOnContentClick.value,
      stateful: false,
      offset: [1, 0],
      keepAnchorWidth: true,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      "aria-label": props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption")
    }));
    const optionsListPropsComputed = computed(() => ({
      ...pick_1(props, ["textBy", "trackBy", "groupBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "minSearchChars", "delay"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchInput.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText)
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, showDropdownContent);
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const inputWrapperPropsComputed = computed(() => ({
      ...pick_1(props, ["messages", "requiredMark", "bordered", "outline", "label", "color", "success"]),
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      tabindex: tabIndexComputed.value
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick_1(props, ["placeholder", "autocomplete", "multiple", "disabled"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText
    }));
    const autocompleteValue = useAutocomplete(props, visibleSelectedOptions, showDropdownContent, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
      resetValidation();
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete) {
        e == null ? void 0 : e.stopImmediatePropagation();
        isInputFocused.value = true;
        showDropdownContent.value = true;
      }
    };
    const toggleDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    return {
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      toggleDropdown,
      deleteLastSelected,
      focusAutocompleteInput,
      tp,
      t,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueString,
      showClearIcon,
      toggleIcon,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      focusPreviousOption,
      focusNextOption,
      showDropdownContentComputed,
      handleDropdownOpen,
      handleDropdownClose,
      hideAndFocus,
      toggleIconColor,
      onHintedSearch,
      onScrollBottom,
      clearIconProps,
      dropdownPropsComputed,
      visibleSelectedOptions,
      optionsListPropsComputed,
      toggleHiddenOptionsState,
      setAutocompleteValue,
      inputWrapperPropsComputed,
      inputWrapperClassComputed,
      selectContentPropsComputed
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_select_content = resolveComponent("va-select-content");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    ref: "dropdown",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    class: "va-select va-select__dropdown va-select-dropdown"
  }, _ctx.dropdownPropsComputed), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({
        ref: "input",
        class: ["va-select__anchor va-select-anchor__input", _ctx.inputWrapperClassComputed],
        "model-value": _ctx.valueString
      }, _ctx.inputWrapperPropsComputed, {
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur,
        onClick: _ctx.focusAutocompleteInput
      }), createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": _ctx.t("reset"),
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
          _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
            key: 1,
            color: _ctx.$props.color,
            size: "small",
            name: "va-loading",
            spin: "counter-clockwise"
          }, null, 8, ["color"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon,
            onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
          }, null, 8, ["color", "name", "onClick"])
        ]),
        default: withCtx(() => [
          createVNode(_component_va_select_content, mergeProps(_ctx.selectContentPropsComputed, {
            onToggleHidden: _ctx.toggleHiddenOptionsState,
            onAutocompleteInput: _ctx.setAutocompleteValue,
            onFocusPrev: _ctx.focusPreviousOption,
            onFocusNext: _ctx.focusNextOption,
            onSelectOption: _ctx.selectOrAddOption,
            onDeleteLastSelected: _ctx.deleteLastSelected
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["onToggleHidden", "onAutocompleteInput", "onFocusPrev", "onFocusNext", "onSelectOption", "onDeleteLastSelected"])
        ]),
        _: 2
      }, [
        renderList(_ctx.$slots, (_, name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "model-value", "onFocus", "onBlur", "onClick"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width })
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            "aria-label": _ctx.t("optionsFilter"),
            tabindex: _ctx.tabIndexComputed,
            placeholder: _ctx.tp(_ctx.$props.searchPlaceholderText),
            bordered: "",
            onKeydown: [
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode("", true),
          createVNode(_component_va_select_option_list, mergeProps({
            ref: "optionList",
            class: "va-select-dropdown__options-wrapper",
            hoveredOption: _ctx.hoveredOption,
            "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
            style: { maxHeight: _ctx.$props.maxHeight }
          }, _ctx.optionsListPropsComputed, {
            onSelectOption: _ctx.selectOption,
            onNoPreviousOptionToHover: _ctx.focusSearchBar,
            onKeydown: [
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
              _ctx.onHintedSearch
            ],
            onScrollBottom: _ctx.onScrollBottom
          }), {
            default: withCtx((slotData) => [
              renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData || {})))
            ]),
            _: 3
          }, 16, ["hoveredOption", "style", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
        ]),
        _: 3
      }, 8, ["style"])
    ]),
    _: 3
  }, 16, ["modelValue"]);
}
var _VaSelect = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["styles", [...(      VaSelectContent.styles || []), ...(    VaSelectOptionList.styles || []), ...(    VaIcon.styles || []), ...(    VaDropdown.styles || []), ...(    VaDropdownContent.styles || []), ...(    VaInput.styles || []), ...(    VaInputWrapper  .styles || []), _style_0]]]);
export { _VaSelect as _ };
//# sourceMappingURL=VaSelect.js.map
