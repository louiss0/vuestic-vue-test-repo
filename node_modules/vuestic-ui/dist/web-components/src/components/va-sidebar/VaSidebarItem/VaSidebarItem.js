import { defineComponent, computed, openBlock, createBlock, resolveDynamicComponent, mergeProps, toHandlers, withCtx, renderSlot } from "vue";
import { u as useColors } from "../../../composables/useColors.js";
import { u as useComponentPresetProp } from "../../../composables/useComponentPreset.js";
import { u as useElementRef } from "../../../composables/useElementRef.js";
import { u as useHover } from "../../../composables/useHover.js";
import { e as applyColors } from "../../../services/color/utils.js";
import { u as useKeyboardOnlyFocus } from "../../../composables/useKeyboardOnlyFocus.js";
import { u as useRouterLinkProps, a as useRouterLink } from "../../../composables/useRouterLink.js";
import { u as useTextColor } from "../../../composables/useTextColor.js";
import { a as useSidebarItem } from "../hooks/useSidebar.js";
import { _ as _export_sfc } from "../../../../plugin-vue_export-helper.js";
var _style_0 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: hidden;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar__item {\n  border-left: var(--va-sidebar-item-active-border-size) solid transparent;\n  padding-right: var(--va-sidebar-item-active-border-size);\n  display: inline-block;\n  width: 100%;\n  font-family: var(--va-font-family);\n  transition: var(--va-sidebar-item-transition);\n  box-sizing: border-box;\n  color: currentColor;\n}";
const _sfc_main = defineComponent({
  name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: Number, default: 0.2 },
    borderColor: { type: String, default: void 0 }
  },
  setup(props) {
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement);
    const { getColor, getHoverColor, getFocusColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = { ...sidebar, ...props };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor(
          getColor(props.hoverColor || props.activeColor),
          props.hoverOpacity
        );
      }
      return style;
    });
    const { tagComputed, hrefComputed } = useRouterLink(props);
    return {
      rootElement,
      computedStyle,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isHovered,
      backgroundColorComputed,
      bg: getColor(sidebar == null ? void 0 : sidebar.color),
      textBackground
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "rootElement",
    class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to
  }, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "style", "href", "to"]);
}
var _VaSidebarItem = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["styles", [_style_0]]]);
export { _VaSidebarItem as _ };
//# sourceMappingURL=VaSidebarItem.js.map
