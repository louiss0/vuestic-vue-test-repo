import {
  cleave_esm_default,
  nt
} from "./chunk-26RWD3ZW.js";
import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  defineCustomElement,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toHandlers,
  toRef,
  toRefs,
  unref,
  useCssVars,
  vModelDynamic,
  vModelText,
  vShow,
  watch,
  watchEffect,
  watchPostEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-3NMN3MUW.js";

// node_modules/vuestic-ui/dist/web-components/_commonjsHelpers.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

// node_modules/vuestic-ui/dist/web-components/vendor.js
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$9(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$9;
function isObject$c(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$c;
var baseGetTag$8 = _baseGetTag;
var isObject$b = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$b(value)) {
    return false;
  }
  var tag = baseGetTag$8(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$a = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$6 = _root;
var Map$3 = getNative$6(root$6, "Map");
var _Map = Map$3;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache;
var Map$1 = _Map;
var MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$7 = _baseGetTag;
var isObjectLike$a = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$a(value) && baseGetTag$7(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$9 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$6 = _baseGetTag;
var isLength$2 = isLength_1;
var isObjectLike$8 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$3 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$3 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$8(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$6(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$3 = _baseUnary;
var nodeUtil$3 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes;
var isArguments$3 = isArguments_1;
var isArray$9 = isArray_1;
var isBuffer$2 = isBuffer$3.exports;
var isIndex$3 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$9(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$5 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike$3 = isArrayLike_1;
function keys$3(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$5 = _copyObject;
var keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$5(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$9 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$9(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject;
var keysIn$4 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$4(source, keysIn$4(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$3 = _copyObject;
var getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$3(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush;
var getPrototype$2 = _getPrototype;
var getSymbols$1 = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$2 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$2(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush;
var isArray$8 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$8(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$3 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$3 = _getNative;
var root$5 = _root;
var DataView$1 = getNative$3(root$5, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$4 = _root;
var Promise$2 = getNative$2(root$4, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$3 = _root;
var Set$1 = getNative$1(root$3, "Set");
var _Set = Set$1;
var getNative = _getNative;
var root$2 = _root;
var WeakMap$1 = getNative(root$2, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map2 = _Map;
var Promise$1 = _Promise;
var Set2 = _Set;
var WeakMap = _WeakMap;
var baseGetTag$5 = _baseGetTag;
var toSource = _toSource;
var mapTag$3 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map2);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set2);
var weakMapCtorString = toSource(WeakMap);
var getTag$3 = baseGetTag$5;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map2 && getTag$3(new Map2()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set2 && getTag$3(new Set2()) != setTag$3 || WeakMap && getTag$3(new WeakMap()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag$5(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root$1 = _root;
var Uint8Array$1 = root$1.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray$1 = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray$1(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$8(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate;
var getPrototype$1 = _getPrototype;
var isPrototype = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$2 = _getTag;
var isObjectLike$7 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$7(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$2 = _baseUnary;
var nodeUtil$2 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike$6 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$6(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$1 = _baseUnary;
var nodeUtil$1 = _nodeUtil.exports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer$1 = _cloneBuffer.exports;
var copyArray$1 = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject$1 = _initCloneObject;
var isArray$7 = isArray_1;
var isBuffer$1 = isBuffer$3.exports;
var isMap = isMap_1;
var isObject$7 = isObject_1;
var isSet = isSet_1;
var keys = keys_1;
var keysIn$2 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$7(value)) {
    return value;
  }
  var isArr = isArray$7(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn$2 : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$2(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var baseGetTag$4 = _baseGetTag;
var isObjectLike$5 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$4(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var Symbol$2 = _Symbol;
var arrayMap$1 = _arrayMap;
var isArray$6 = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$6(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$6(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$6;
var deburrLetter = _deburrLetter;
var toString$5 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
  string = toString$5(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['’]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo$1 = "[" + rsComboRange$2 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$2 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$2 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$4 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString$4(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['’]";
var reApos = RegExp(rsApos, "g");
function createCompounder$3(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$3;
var createCompounder$2 = _createCompounder;
var kebabCase = createCompounder$2(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
function baseSlice$2(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice$1(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray = _stringToArray;
var toString$3 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$3(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$2 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$2;
var toString$2 = toString_1;
var upperFirst$1 = upperFirst_1;
function capitalize$1(string) {
  return upperFirst$1(toString$2(string).toLowerCase());
}
var capitalize_1 = capitalize$1;
var capitalize = capitalize_1;
var createCompounder$1 = _createCompounder;
var camelCase = createCompounder$1(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim;
var isObject$6 = isObject_1;
var isSymbol$2 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN;
  }
  if (isObject$6(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$6(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$5 = isObject_1;
var now = now_1;
var toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max;
var nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var isArray$5 = isArray_1;
var isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$5(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray$4 = isArray_1;
var isKey = _isKey;
var stringToPath = _stringToPath;
var toString$1 = toString_1;
function castPath$6(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$6;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$5 = _castPath;
var toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$5(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$3(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var assignValue = _assignValue;
var castPath$4 = _castPath;
var isIndex$2 = _isIndex;
var isObject$4 = isObject_1;
var toKey$2 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$4(object)) {
    return object;
  }
  path = castPath$4(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey$2(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$4(objValue) ? objValue : isIndex$2(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath$3 = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet$1(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$3(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath;
var isArguments$2 = isArguments_1;
var isArray$3 = isArray_1;
var isIndex$1 = _isIndex;
var isLength = isLength_1;
var toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$1(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$3(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var Symbol$1 = _Symbol;
var isArguments$1 = isArguments_1;
var isArray$2 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var flatten = flatten_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function flatRest$2(func) {
  return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick;
var flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var toString = toString_1;
var idCounter = 0;
function uniqueId(prefix2) {
  var id = ++idCounter;
  return toString(prefix2) + id;
}
var uniqueId_1 = uniqueId;
var baseGetTag$3 = _baseGetTag;
var isArray$1 = isArray_1;
var isObjectLike$4 = isObjectLike_1;
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$4(value) && baseGetTag$3(value) == stringTag;
}
var isString_1 = isString;
var baseAssignValue = _baseAssignValue;
var eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var isArrayLike$1 = isArrayLike_1;
var isObjectLike$3 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$3(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseGetTag$2 = _baseGetTag;
var getPrototype = _getPrototype;
var isObjectLike$2 = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$2(value) || baseGetTag$2(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var copyObject$1 = _copyObject;
var keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$1(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer = _cloneBuffer.exports;
var cloneTypedArray = _cloneTypedArray;
var copyArray = _copyArray;
var initCloneObject = _initCloneObject;
var isArguments = isArguments_1;
var isArray = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer = isBuffer$3.exports;
var isFunction = isFunction_1;
var isObject$3 = isObject_1;
var isPlainObject$1 = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$2 = isObject_1;
var keysIn = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
var identity = identity_1;
var overRest = _overRest;
var setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike = isArrayLike_1;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap = _arrayMap;
var baseClone = _baseClone;
var baseUnset = _baseUnset;
var castPath = _castPath;
var copyObject = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp;
var toNumber = toNumber_1;
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}
var clamp_1 = clamp;
function noop() {
}
var noop_1 = noop;
var debounce = debounce_1;
var isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
var createCompounder = _createCompounder;
var upperFirst = upperFirst_1;
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
var baseGetTag$1 = _baseGetTag;
var isObjectLike$1 = isObjectLike_1;
var dateTag = "[object Date]";
function baseIsDate$1(value) {
  return isObjectLike$1(value) && baseGetTag$1(value) == dateTag;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;
var baseGetTag = _baseGetTag;
var isObjectLike = isObjectLike_1;
var numberTag = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
var isNumber_1 = isNumber;

// node_modules/vuestic-ui/dist/web-components/src/services/component-config/config/default.js
var getComponentsDefaultConfig = () => ({
  VaIcon: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  },
  VaRating: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  },
  all: {},
  presets: {
    VaButton: {
      default: {
        backgroundOpacity: 1,
        hoverBehavior: "mask",
        hoverOpacity: 0.15,
        pressedBehavior: "mask",
        pressedOpacity: 0.13
      },
      primary: {
        backgroundOpacity: 0.1,
        hoverBehavior: "opacity",
        hoverOpacity: 0.07,
        pressedBehavior: "opacity",
        pressedOpacity: 0.13
      },
      secondary: {
        backgroundOpacity: 0,
        hoverBehavior: "opacity",
        hoverOpacity: 0.07,
        pressedBehavior: "opacity",
        pressedOpacity: 0.13
      },
      plain: {
        plain: true,
        hoverBehavior: "mask",
        hoverOpacity: 0.15,
        pressedBehavior: "mask",
        pressedOpacity: 0.13
      },
      plainOpacity: {
        plain: true,
        textOpacity: 0.6,
        hoverBehavior: "opacity",
        hoverOpacity: 1,
        pressedBehavior: "opacity",
        pressedOpacity: 0.9
      }
    }
  }
});

// node_modules/vuestic-ui/dist/web-components/src/services/icon/presets/fonts.js
var VuesticIconFonts = [
  {
    name: "mi-{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  },
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];

// node_modules/vuestic-ui/dist/web-components/src/services/icon/presets/vuestic-aliases.js
var VuesticIconAliases = [
  {
    name: "va-arrow-first",
    to: "mi-first_page"
  },
  {
    name: "va-arrow-last",
    to: "mi-last_page"
  },
  {
    name: "va-arrow-right",
    to: "mi-chevron_right"
  },
  {
    name: "va-arrow-left",
    to: "mi-chevron_left"
  },
  {
    name: "va-arrow-down",
    to: "mi-expand_more"
  },
  {
    name: "va-arrow-up",
    to: "mi-expand_less"
  },
  {
    name: "va-calendar",
    to: "mi-calendar_today"
  },
  {
    name: "va-delete",
    to: "mi-delete_outline"
  },
  {
    name: "va-check",
    to: "mi-check"
  },
  {
    name: "va-check-circle",
    to: "mi-check_circle"
  },
  {
    name: "va-warning",
    to: "mi-warning"
  },
  {
    name: "va-clear",
    to: "mi-highlight_off"
  },
  {
    name: "va-close",
    to: "mi-close"
  },
  {
    name: "va-loading",
    to: "mi-loop"
  }
];

// node_modules/vuestic-ui/dist/web-components/src/services/icon/create-icons-config.js
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/config/default.js
var getIconDefaultConfig = () => createIconsConfig({});

// node_modules/vuestic-ui/dist/web-components/src/services/color/presets.js
var presets = {
  light: {
    primary: "#154EC1",
    secondary: "#767C88",
    success: "#3D9209",
    info: "#158DE3",
    danger: "#E42222",
    warning: "#FFD43A",
    backgroundPrimary: "#f6f6f6",
    backgroundSecondary: "#FFFFFF",
    backgroundElement: "#ECF0F1",
    backgroundBorder: "#DEE5F2",
    textPrimary: "#262824",
    textInverted: "#FFFFFF",
    shadow: "rgba(0, 0, 0, 0.12)",
    focus: "#49A8FF"
  },
  dark: {
    primary: "#3472F0",
    secondary: "#767C88",
    success: "#66BE33",
    info: "#3EAAF8",
    danger: "#F34030",
    warning: "#FFD952",
    backgroundPrimary: "#050A10",
    backgroundSecondary: "#1F262F",
    backgroundElement: "#131A22",
    backgroundBorder: "#3D4C58",
    textPrimary: "#F1F1F1",
    textInverted: "#0B121A",
    shadow: "rgba(255, 255, 255, 0.12)",
    focus: "#49A8FF"
  }
};

// node_modules/vuestic-ui/dist/web-components/src/services/color/config/default.js
var getColorDefaultConfig = () => ({
  get variables() {
    return this.presets[this.currentPresetName];
  },
  set variables(value) {
    this.presets[this.currentPresetName] = value;
  },
  threshold: 150,
  presets: {
    light: presets.light,
    dark: presets.dark
  },
  currentPresetName: "light"
});

// node_modules/vuestic-ui/dist/web-components/src/services/i18n/config/default.js
var getI18nConfigDefaults = () => ({
  search: "Search",
  noOptions: "Items not found",
  ok: "Ok",
  cancel: "Cancel",
  uploadFile: "Upload file",
  undo: "Undo",
  dropzone: "Drop files here to upload",
  fileDeleted: "File deleted",
  closeAlert: "close alert",
  backToTop: "back to top",
  toggleDropdown: "toggle dropdown",
  carousel: "carousel",
  goPreviousSlide: "go previous slide",
  goNextSlide: "go next slide",
  goSlide: "go slide {index}",
  slideOf: "slide {index} of {length}",
  close: "close",
  openColorPicker: "open color picker",
  colorSelection: "color selection",
  colorName: "color {color}",
  decreaseCounter: "decrease counter",
  increaseCounter: "increase counter",
  selectAllRows: "select all rows",
  sortColumnBy: "sort column by {name}",
  selectRowByIndex: "select row {index}",
  resetDate: "reset date",
  nextPeriod: "next period",
  switchView: "switch view",
  previousPeriod: "previous period",
  removeFile: "remove file",
  reset: "reset",
  pagination: "pagination",
  goToTheFirstPage: "go to the first page",
  goToPreviousPage: "go to the previous page",
  goToSpecificPage: "go to the {page} page",
  goToSpecificPageInput: "enter the page number to go",
  goNextPage: "go next page",
  goLastPage: "go last page",
  currentRating: "current rating {value} of {max}",
  voteRating: "`vote rating {value} of {max}`",
  optionsFilter: "options filter",
  splitPanels: "split panels",
  movePaginationLeft: "move pagination left",
  movePaginationRight: "move pagination right",
  resetTime: "reset time",
  closeToast: "close toast",
  selectedOption: "Selected option",
  noSelectedOption: "Option is not selected",
  breadcrumbs: "breadcrumbs",
  counterValue: "counter value",
  selectedDate: "selected date",
  selectedTime: "selected time",
  progressState: "progress state",
  color: "color",
  next: "Next",
  back: "Previous",
  finish: "Finish"
});

// node_modules/vuestic-ui/dist/web-components/src/services/breakpoint/index.js
var vaBreakpointSymbol = Symbol("vaBreakpoint");
var defaultThresholds = {
  xs: 0,
  sm: 640,
  md: 1024,
  lg: 1440,
  xl: 1920
};
var getBreakpointDefaultConfig = () => ({
  enabled: true,
  bodyClass: true,
  thresholds: defaultThresholds
});

// node_modules/vuestic-ui/dist/web-components/src/services/current-app.js
var app;
var setCurrentApp = (instance) => {
  app = instance;
};
var getCurrentApp = () => app;
var inject2 = (key, value) => {
  var _a;
  const app2 = (_a = getCurrentApp()) == null ? void 0 : _a._context.provides[key];
  return app2 || inject(key, value);
};

// node_modules/vuestic-ui/dist/web-components/src/utils/merge-deep.js
var isObject2 = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var mergeDeep = (target, source) => {
  if (!isObject2(target) || !isObject2(source)) {
    return source;
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (isObject2(targetValue) && isObject2(sourceValue)) {
      target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};

// node_modules/vuestic-ui/dist/web-components/src/utils/ssr.js
var isServer = () => typeof window === "undefined";
var isClient = () => !isServer();
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/utils/global-properties.js
var extractGlobalProperties = (app2) => app2.config.globalProperties;
var defineGlobalProperty = (app2, key, v) => {
  const globalProperties = extractGlobalProperties(app2);
  globalProperties[key] = v;
};
var getGlobalProperty = (app2, key) => {
  return extractGlobalProperties(app2)[key];
};

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/utils/define-vuestic-plugin.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/web-components/src/utils/dom.js
var addOrUpdateStyleElement = (id, getStyles) => {
  if (isServer()) {
    return;
  }
  let stylesElement = document.getElementById(id);
  if (stylesElement) {
    stylesElement.innerHTML = getStyles();
  } else {
    stylesElement = document.createElement("style");
    stylesElement.setAttribute("type", "text/css");
    stylesElement.setAttribute("id", id);
    stylesElement.innerHTML = getStyles();
    document.head.append(stylesElement);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/services/colors-classes/config/default.js
var ColorsClassesPresets = [
  {
    prefix: "bg",
    property: "background-color"
  },
  {
    prefix: "text",
    property: ["color", "fill"]
  }
];

// node_modules/vuestic-ui/dist/web-components/src/services/colors-classes/plugin/index.js
var getColorsClassesDefaultConfig = () => ColorsClassesPresets;
var getColorsClassesHelpers = (helpers, colors) => {
  const colorsEntries = Object.entries(colors);
  return helpers.reduce((acc, helper) => acc.concat(
    colorsEntries.map(([colorName, colorValue]) => {
      var _a, _b;
      return {
        ...helper,
        postfix: (_a = helper.postfix) != null ? _a : colorName,
        value: (_b = helper.value) != null ? _b : colorValue
      };
    })
  ), []);
};
var getColorsClassesStyles = (helpers) => {
  return helpers.reduce((styles, helper) => {
    const style = [helper.property].flat().map((prop) => `${prop}: ${helper.value};`).join("");
    styles += `.va-${helper.prefix}--${helper.postfix} { ${style} }`;
    return styles;
  }, "");
};
var handleConfigUpdate = (helpers, colors) => {
  const coloredHelpers = getColorsClassesHelpers(helpers, colors);
  addOrUpdateStyleElement(
    "va-color-helpers",
    () => getColorsClassesStyles(coloredHelpers)
  );
};
var createColorHelpersPlugin = () => {
  if (isServer()) {
    return;
  }
  const { globalConfig } = useGlobalConfig();
  watch(() => globalConfig.value.colorsClasses, (newHelpers) => {
    if (newHelpers.length) {
      handleConfigUpdate(newHelpers, globalConfig.value.colors.variables);
    }
  }, { immediate: true, deep: true });
  watch(() => globalConfig.value.colors.variables, (newColors) => {
    if (!newColors) {
      return;
    }
    handleConfigUpdate(globalConfig.value.colorsClasses, newColors);
  }, { immediate: true, deep: true });
  return {
    renderColorHelpers: () => {
      const coloredHelpers = getColorsClassesHelpers(globalConfig.value.colorsClasses, globalConfig.value.colors.variables);
      return getColorsClassesStyles(coloredHelpers);
    }
  };
};
var ColorsClassesPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaColorsClasses", createColorHelpersPlugin());
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/global-config/global-config.js
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var createGlobalConfig = () => {
  const globalConfig = ref({
    colors: getColorDefaultConfig(),
    icons: getIconDefaultConfig(),
    components: getComponentsDefaultConfig(),
    breakpoint: getBreakpointDefaultConfig(),
    i18n: getI18nConfigDefaults(),
    colorsClasses: getColorsClassesDefaultConfig()
  });
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep_1(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = mergeDeep(cloneDeep_1(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
var provideForCurrentApp = (provide2) => {
  var _a, _b;
  const provides = ((_a = getCurrentInstance()) == null ? void 0 : _a.appContext.provides) || ((_b = getCurrentApp()) == null ? void 0 : _b._context.provides);
  if (!provides) {
    throw new Error("Vue app not found for provide");
  }
  provides[GLOBAL_CONFIG] = provide2;
  return provide2;
};
function useGlobalConfig() {
  let injected = inject2(GLOBAL_CONFIG);
  if (!injected) {
    injected = createGlobalConfig();
    provideForCurrentApp(injected);
  }
  return injected;
}

// node_modules/vuestic-ui/dist/web-components/src/services/global-config/types.js
var defineVuesticConfig = (config) => config;

// node_modules/vuestic-ui/dist/web-components/src/composables/useBreakpoint.js
var useBreakpoint = () => {
  return inject(vaBreakpointSymbol, {});
};

// node_modules/vuestic-ui/dist/web-components/src/utils/env.js
var __DEV__ = typeof process !== "undefined" && false;

// node_modules/vuestic-ui/dist/web-components/src/utils/console.js
var warn = (...attrs) => {
  if (__DEV__) {
    console.warn(...attrs);
  }
  return false;
};

// node_modules/vuestic-ui/dist/web-components/src/services/cache/plugin/index.js
var VaAppCachePluginKey = Symbol("VaAppCachePlugin");
var CachePlugin = defineVuesticPlugin(() => ({
  install(app2) {
    const cache = {
      colorContrast: {}
    };
    app2.provide(VaAppCachePluginKey, cache);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useCache.js
var useCache = () => inject2(VaAppCachePluginKey, {
  colorContrast: {}
});

// node_modules/vuestic-ui/dist/web-components/src/composables/useReactiveComputed.js
var useReactiveComputed = (obj) => {
  const objectRef = typeof obj === "function" ? computed(obj) : computed(obj);
  const proxy = new Proxy(objectRef, {
    get(target, p, receiver) {
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(target, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value)) {
        objectRef.value[p].value = value;
      } else {
        objectRef.value[p] = value;
      }
      return true;
    },
    deleteProperty(target, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(target, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
};

// node_modules/vuestic-ui/dist/web-components/src/services/color/utils.js
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
var cssVariableName = (colorName) => `--va-${kebabCase_1(colorName)}`;
var normalizeColorName = (colorName) => camelCase_1(colorName);
var colorToRgba = (color, opacity) => {
  return new nt(color).setA(opacity).RGBA;
};
var getColorLightness = (color) => {
  const { R, G, B } = new nt(color);
  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);
};
var getBoxShadowColor = (color, opacity = 0.4) => {
  return new nt(color).setA(opacity).RGBA;
};
var getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return new nt(background).setA(opacity).RGBA;
};
var getHoverColor = (color, opacity = 0.2) => {
  return new nt(color).setA(opacity).RGBA;
};
var getFocusColor = (color, opacity = 0.3) => {
  return new nt(color).setA(opacity).RGBA;
};
var shiftHSLAColor = (color, offset) => {
  const result = new nt(color);
  if (offset.h) {
    result.setH(result.H + offset.h);
  }
  if (offset.s) {
    result.setS(result.S + offset.s);
  }
  if (offset.l) {
    result.setL(result.L + offset.l);
  }
  if (offset.a) {
    result.setA(result.A + offset.a);
  }
  return result.HSLA;
};
var setHSLAColor = (color, newColor) => {
  const result = new nt(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
var shiftGradientColor = (color) => {
  const newColor = nt.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = nt.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
var getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
var isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
var applyColors = (color1, color2) => {
  const c1 = new nt(color1);
  const c2 = new nt(color2);
  const weight = c2.A;
  if (weight === 1) {
    return c2.RGBA;
  }
  if (weight === 0) {
    return c1.RGBA;
  }
  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
  return c1.RGBA;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useColors.js
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const gc = useGlobalConfig();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { setGlobalConfig, globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.variables,
    set: (v) => {
      setColors(v);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.variables = {
      ...globalConfig.value.colors.variables,
      ...colors2
    };
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = getColors().primary;
    }
    const colors2 = getColors();
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const colorValue = colors2[prop] || colors2[normalizeColorName(prop)];
    if (colorValue) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue;
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    if (__DEV__) {
      console.warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
    }
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed(() => getColor(color));
  };
  const colorsToCSSVariable = (colors2, prefix2 = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${colorName}`] = getColor(colors2[colorName], void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > globalConfig.value.colors.threshold ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > globalConfig.value.colors.threshold ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed(() => globalConfig.value.colors.currentPresetName);
  const presets2 = computed(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
    globalConfig.value.colors.variables = { ...globalConfig.value.colors.presets[presetName] };
  };
  return {
    colors,
    currentPresetName,
    presets: presets2,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useI18n.js
var useI18nConfig = () => {
  const { globalConfig, mergeGlobalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  const mergeIntoConfig = (newConfig) => {
    mergeGlobalConfig({
      i18n: {
        ...config.value,
        ...newConfig
      }
    });
  };
  return {
    config,
    mergeIntoConfig
  };
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/utils/regex.js
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g) => g.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/utils/dynamic-segment.js
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g) => g.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/types.js
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/utils/get-icon-configuration.js
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = merge_1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return merge_1(
    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),
    resolvedIconConfiguration
  );
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key) => {
    delete configuration[key];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useIcon.js
var useIcon = () => {
  const { globalConfig } = useGlobalConfig();
  return {
    getIcon: (name) => getIconConfiguration(name, globalConfig.value.icons)
  };
};

// node_modules/vuestic-ui/dist/web-components/src/services/global-config/plugin/index.js
var GlobalConfigPlugin = defineVuesticPlugin((config) => ({
  install(app2) {
    const globalConfig = createGlobalConfig();
    if (config) {
      globalConfig.mergeGlobalConfig(config);
    }
    if (config == null ? void 0 : config.componentsAll) {
      console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
    }
    app2.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app2, "$vaConfig", globalConfig);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/color/plugin/create-color-config-plugin.js
var setCSSVariable = (name, value, root2) => {
  root2.style.setProperty(cssVariableName(name), value);
};
var createColorConfigPlugin = (app2, config) => {
  var _a;
  const { colors: configColors, getTextColor, getColor, currentPresetName, applyPreset } = useColors();
  const renderCSSVariables = (colors = configColors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    return colorNames.map((key) => `${cssVariableName(key)}: ${colors[key]}`).join(";");
  };
  const updateColors = (newValue) => {
    if (!newValue) {
      return;
    }
    if (isServer()) {
      return;
    }
    const root2 = document.documentElement;
    const colorNames = Object.keys(newValue);
    colorNames.forEach((key) => {
      setCSSVariable(key, newValue[key], root2);
    });
    colorNames.forEach((key) => {
      setCSSVariable(`on-${key}`, getColor(getTextColor(newValue[key])), root2);
    });
  };
  watch(configColors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  if ((_a = config == null ? void 0 : config.colors) == null ? void 0 : _a.currentPresetName) {
    applyPreset(config.colors.currentPresetName);
  }
  return {
    renderCSSVariables,
    updateColors
  };
};

// node_modules/vuestic-ui/dist/web-components/src/services/color/plugin/index.js
var ColorConfigPlugin = defineVuesticPlugin((config) => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaColorConfig", createColorConfigPlugin(app2, config));
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useClientOnly.js
var useClientOnly = (cb) => {
  const isMounted = computed(isClient);
  const result = ref(null);
  watch(isMounted, () => {
    if (isMounted.value) {
      result.value = cb();
    }
  }, { immediate: true });
  return result;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useDocument.js
var useDocument = () => useClientOnly(() => document);

// node_modules/vuestic-ui/dist/web-components/src/composables/useWindow.js
var useWindow = () => useClientOnly(() => window);

// node_modules/vuestic-ui/dist/web-components/src/composables/useEvent.js
var useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useWindow();
  const capture = typeof target === "boolean" ? target : false;
  watch(source, (newValue, oldValue) => {
    var _a, _b;
    if (!Array.isArray(event)) {
      (_a = unref(newValue)) == null ? void 0 : _a.addEventListener(event, listener, capture);
      (_b = unref(oldValue)) == null ? void 0 : _b.removeEventListener(event, listener, capture);
    } else {
      event.forEach((e) => {
        var _a2, _b2;
        (_a2 = unref(newValue)) == null ? void 0 : _a2.addEventListener(e, listener, capture);
        (_b2 = unref(oldValue)) == null ? void 0 : _b2.removeEventListener(e, listener, capture);
      });
    }
  }, { immediate: true });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useWindowSize.js
function useWindowSize() {
  const windowSizes = reactive({
    width: void 0,
    height: void 0
  });
  const setCurrentWindowSizes = () => {
    windowSizes.width = window == null ? void 0 : window.innerWidth;
    windowSizes.height = window == null ? void 0 : window.innerHeight;
  };
  const isMounted = computed(isClient);
  watch(isMounted, (newValue) => {
    if (!newValue) {
      return;
    }
    setCurrentWindowSizes();
  }, { immediate: true });
  useEvent("resize", setCurrentWindowSizes, true);
  return { windowSizes };
}

// node_modules/vuestic-ui/dist/web-components/src/utils/uuid.js
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}`;
};

// node_modules/vuestic-ui/dist/web-components/src/services/breakpoint/plugin/create-service.js
var createBreakpointConfigPlugin = (app2) => {
  var _a;
  const globalConfig = (_a = getGlobalProperty(app2, "$vaConfig")) == null ? void 0 : _a.globalConfig;
  if (!globalConfig) {
    warn("createBreakpointConfigPlugin: globalConfig is not defined!");
    return {};
  }
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("createBreakpointConfigPlugin: breakpointConfig is not defined!");
    }
    return breakpoint != null ? breakpoint : {};
  });
  if (!breakpointConfig.value.enabled) {
    return {};
  }
  if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
    warn("createBreakpointConfigPlugin: there are no defined thresholds!");
    return {};
  }
  const { windowSizes } = useWindowSize();
  const isMounted = computed(isClient);
  const currentBreakpoint = computed(() => {
    if (!isMounted.value || !windowSizes.width) {
      return;
    }
    return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value]) => {
      if (windowSizes.width >= value) {
        acc = key;
      }
      return acc;
    }, "xs");
  });
  const screenClasses = computed(() => Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold) => {
    acc[threshold] = `va-screen-${threshold}`;
    return acc;
  }, {}));
  const generateHelpersMediaCss = () => {
    let result = "";
    Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index) => {
      result += `@media screen and (min-width: ${thresholdValue}px) {`;
      result += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
      result += "}\n";
    });
    return result;
  };
  const uniqueId2 = computed(generateUniqueId);
  addOrUpdateStyleElement(`va-helpers-media-${uniqueId2.value}`, generateHelpersMediaCss);
  const getDocument = useDocument();
  watch(currentBreakpoint, (newValue) => {
    if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) {
      return;
    }
    getDocument.value.body.classList.forEach((className) => {
      if (Object.values(screenClasses.value).includes(className)) {
        getDocument.value.body.classList.remove(className);
      }
    });
    getDocument.value.body.classList.add(screenClasses.value[newValue]);
  }, { immediate: true });
  const breakpointHelpers = computed(() => {
    const isXs = currentBreakpoint.value === "xs";
    const isSm = currentBreakpoint.value === "sm";
    const isMd = currentBreakpoint.value === "md";
    const isLg = currentBreakpoint.value === "lg";
    const isXl = currentBreakpoint.value === "xl";
    return {
      xs: isXs,
      sm: isSm,
      md: isMd,
      lg: isLg,
      xl: isXl,
      smUp: isSm || isMd || isLg || isXl,
      mdUp: isMd || isLg || isXl,
      lgUp: isLg || isXl,
      smDown: isXs || isSm,
      mdDown: isXs || isSm || isMd,
      lgDown: isXs || isSm || isMd || isLg
    };
  });
  return useReactiveComputed(() => ({
    width: windowSizes.width,
    height: windowSizes.height,
    current: currentBreakpoint.value,
    thresholds: breakpointConfig.value.thresholds,
    ...breakpointHelpers.value
  }));
};

// node_modules/vuestic-ui/dist/web-components/src/services/breakpoint/plugin/index.js
var BreakpointConfigPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    const breakpointConfig = createBreakpointConfigPlugin(app2);
    app2.provide(vaBreakpointSymbol, breakpointConfig);
    defineGlobalProperty(app2, "$vaBreakpoint", breakpointConfig);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/components/va-config/hooks/useLocalConfig.js
var LocalConfigKey = "VaLocalConfig";
var CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject(LocalConfigKey, CONFIGS_DEFAULT);
}
function provideLocalConfig(config) {
  provide(LocalConfigKey, config);
}

// node_modules/vuestic-ui/dist/web-components/src/services/component-config/utils/use-component-config-props.js
var useComponentConfigProps = (component, originalProps) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  const instancePreset = computed(() => originalProps.preset);
  const getPresetProps = (presetName) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = globalConfig.value.components) == null ? void 0 : _a.presets) == null ? void 0 : _b[component.name]) == null ? void 0 : _c[presetName];
  };
  return computed(() => {
    var _a, _b;
    const globalConfigProps = {
      ...(_a = globalConfig.value.components) == null ? void 0 : _a.all,
      ...(_b = globalConfig.value.components) == null ? void 0 : _b[component.name]
    };
    const localConfigProps = localConfig.value.reduce(
      (finalConfig, config) => config[component.name] ? { ...finalConfig, ...config[component.name] } : finalConfig,
      {}
    );
    const presetName = instancePreset.value || localConfigProps.preset || globalConfigProps.preset;
    const presetProps = presetName && getPresetProps(presetName);
    return { ...globalConfigProps, ...localConfigProps, ...presetProps };
  });
};

// node_modules/vuestic-ui/dist/web-components/src/services/config-transport/createProxyComponent.js
var toCamelCase = (str) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
var findCamelCased = (obj, key) => {
  const found = Object.keys(obj).find((k) => toCamelCase(k) === key);
  return found && obj[found];
};
var createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a;
      if (typeof key !== "string") {
        return target[key];
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const propFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
var patchInstanceProps = (instance, props) => {
  instance.props = props;
};
var createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const props = createPropsWithCustomConfig(instance, propsFromConfig);
    patchInstanceProps(instance, props);
    return (_a = component.setup) == null ? void 0 : _a.call(component, shallowReadonly(props), ctx);
  };
  return new Proxy(component, {
    get(target, key) {
      if (key === "setup") {
        return customSetup;
      }
      return target[key];
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/services/config-transport/withConfigTransport.js
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({});
    return createProxyComponent(component);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useComponentPreset.js
var useComponentPresetProp = {
  preset: {
    type: String,
    default: void 0
  }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTextColor.js
var useTextColor = (componentColor, isTransparent2 = false) => {
  const { props } = getCurrentInstance();
  const { getColor, getTextColor } = useColors();
  const textColorComputed = computed(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const componentColorHex = getColor(unref(componentColor) || props.color);
    return unref(isTransparent2) ? componentColorHex : getColor(getTextColor(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTimer.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTranslation.js
var applyI18nTemplate = (key, values) => {
  if (!values) {
    return key;
  }
  Object.keys(values).forEach((valueKey) => {
    key = key.replace(`{${valueKey}}`, String(values[valueKey]));
  });
  return key;
};
var useTranslation = () => {
  const { globalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  return {
    tp: (key) => {
      if (!key) {
        return void 0;
      }
      if (key.startsWith("$t:")) {
        return config.value[key.slice(3)] || key;
      }
      return key;
    },
    t(key, values) {
      const translated = config.value[key];
      if (!translated) {
        warn(`${key} not found in VuesticUI i18n config`);
        return key;
      }
      return applyI18nTemplate(translated, values) || key;
    }
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSize.js
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size) => {
      return typeof size === "string" || typeof size === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var useSize = (props, componentName2 = ((_a) => (_a = getCurrentInstance()) == null ? void 0 : _a.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName2 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName2]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSizeGlobal || defaultSize}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/web-components/plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-icon/VaIcon.js
var _style_0 = ':root,\n:host {\n  --va-icon-vertical-align: middle;\n  --va-icon-user-select: none;\n}\n.va-icon {\n  vertical-align: var(--va-icon-vertical-align);\n  -webkit-user-select: var(--va-icon-user-select);\n     -moz-user-select: var(--va-icon-user-select);\n          user-select: var(--va-icon-user-select);\n}\n.va-icon[role^=button][tabindex]:not([tabindex^="-"]) {\n  cursor: pointer;\n}\n.va-icon[role^=button][tabindex]:not([tabindex^="-"]):focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-icon.va-icon {\n  font-style: normal;\n}\n.va-icon--spin {\n  animation: va-icon--spin-animation 1500ms linear infinite;\n}\n.va-icon--spin-reverse {\n  animation: va-icon--spin-animation 1500ms linear infinite;\n  animation-direction: reverse;\n}\n@keyframes va-icon--spin-animation {\nfrom {\n    transform: rotate(0deg);\n}\nto {\n    transform: rotate(360deg);\n}\n}\n.va-icon svg {\n  fill: currentColor;\n  height: 100%;\n}';
var _sfc_main = defineComponent({
  name: "VaIcon",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  },
  setup(props, { attrs }) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcon();
    const iconConfig = computed(() => getIcon(props.name));
    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit_1(attrs, ["class"]) }));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => {
      var _a;
      return [
        iconConfig.value.class,
        getSpinClass((_a = props.spin) != null ? _a : iconConfig.value.spin)
      ];
    });
    const transformStyle = computed(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    const tabindexComputed = computed(() => {
      var _a;
      return (_a = attrs.tabindex) != null ? _a : -1;
    });
    const ariaHiddenComputed = computed(() => attrs.role !== "button" || tabindexComputed.value < 0);
    return {
      iconConfig,
      computedTag,
      computedAttrs,
      computedClass,
      computedStyle,
      ariaHiddenComputed
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.computedTag), mergeProps({
    class: ["va-icon", _ctx.computedClass],
    style: _ctx.computedStyle,
    "aria-hidden": _ctx.ariaHiddenComputed,
    notranslate: ""
  }, _ctx.computedAttrs), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        _ctx.iconConfig.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.iconConfig.content), 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ]),
    _: 3
  }, 16, ["class", "style", "aria-hidden"]);
}
var VaIcon = _export_sfc(_sfc_main, [["render", _sfc_render], ["styles", [_style_0]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/VaToast.js
var _style_02 = ":root,\n:host {\n  --va-toast-display: flex;\n  --va-toast-width: 330px;\n  --va-toast-padding: 14px 26px 14px 13px;\n  --va-toast-border-radius: 8px;\n  --va-toast-border: 1px solid var(--va-background-secondary);\n  --va-toast-background-color: var(--va-background-secondary);\n  --va-toast-border-color: var(--va-background-secondary);\n  --va-toast-box-shadow: 0 2px 12px 0 var(--va-shadow);\n  --va-toast-transition: opacity 0.3s, transform 0.3s, left 0.3s, right 0.3s, top 0.4s, bottom 0.3s;\n  --va-toast-z-index: calc(var(--va-z-index-teleport-overlay) + 100);\n  /* Group */\n  --va-toast-group-margin-left: 13px;\n  --va-toast-group-margin-right: 8px;\n  /* Title */\n  --va-toast-title-font-weight: bold;\n  --va-toast-title-font-size: 1rem;\n  --va-toast-title-color: #303133;\n  --va-toast-title-margin: 0 0 6px;\n  /* Content */\n  --va-toast-content-font-size: 1rem;\n  --va-toast-content-line-height: 1.3125;\n  --va-toast-content-padding-right: 20px;\n  /* Icon */\n  --va-toast-icon-height: 24px;\n  --va-toast-icon-width: 24px;\n  --va-toast-icon-font-size: 24px;\n  /* Icon Close */\n  --va-toast-close-icon-top: 18px;\n  --va-toast-close-icon-right: 15px;\n  --va-toast-close-icon-font-size: 1rem;\n  /* Hover */\n  --va-toast-hover-color: #909399;\n}\n.va-toast {\n  position: fixed;\n  box-sizing: border-box;\n  width: var(--va-toast-width);\n  padding: var(--va-toast-padding);\n  display: flex;\n  align-items: center;\n  border-radius: var(--va-toast-border-radius);\n  border: 1px solid var(--va-toast-border-color);\n  background-color: var(--va-toast-background-color);\n  box-shadow: var(--va-toast-box-shadow);\n  transition: var(--va-toast-transition);\n  overflow: hidden;\n  z-index: var(--va-toast-z-index);\n  font-family: var(--va-font-family);\n}\n.va-toast--multiline {\n  min-height: 70px;\n}\n.va-toast--right {\n  right: 16px;\n}\n.va-toast--left {\n  left: 16px;\n}\n.va-toast__group {\n  margin-left: var(--va-toast-group-margin-left);\n  margin-right: var(--va-toast-group-margin-right);\n}\n.va-toast__title {\n  font-weight: var(--va-toast-title-font-weight);\n  font-size: var(--va-toast-title-font-size);\n  color: var(--va-toast-title-color);\n  margin: var(--va-toast-title-margin);\n}\n.va-toast__content {\n  font-size: var(--va-toast-content-font-size);\n  line-height: var(--va-toast-content-line-height);\n  padding-right: var(--va-toast-content-padding-right);\n}\n.va-toast__content p,\n.va-toast__content div {\n  margin: 0;\n}\n.va-toast__icon {\n  height: var(--va-toast-icon-height);\n  width: var(--va-toast-icon-width);\n  font-size: var(--va-toast-icon-font-size);\n}\n.va-toast__close-icon {\n  position: absolute;\n  top: 50%;\n  right: var(--va-toast-close-icon-right);\n  cursor: pointer;\n  transform: translateY(-50%);\n  font-size: var(--va-toast-close-icon-font-siz);\n  opacity: 0.7;\n}\n.va-toast__close-icon:hover {\n  opacity: 1;\n}\n.va-toast-fade-enter.right {\n  right: 0;\n  transform: translateX(100%);\n}\n.va-toast-fade-enter.left {\n  left: 0;\n  transform: translateX(-100%);\n}\n.va-toast-fade-leave-active {\n  opacity: 0;\n}";
var VaToastRenderer = defineComponent({
  name: "VaToastRenderer",
  props: {
    render: { type: Function, required: true }
  },
  setup: (props) => () => props.render()
});
var _sfc_main2 = defineComponent({
  name: "VaToast",
  components: { VaIcon, VaToastRenderer },
  emits: ["on-click", "on-close"],
  props: {
    ...useComponentPresetProp,
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const visible = ref(false);
    const positionX = computed(() => {
      return props.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props.offsetY}px`,
      [positionX.value]: `${props.offsetX}px`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a, _b;
      (_a = rootElement.value) == null ? void 0 : _a.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a;
      visible.value = false;
      (_a = rootElement.value) == null ? void 0 : _a.addEventListener("transitionend", destroyElement);
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return {
      ...useTranslation(),
      visible,
      toastClasses,
      toastStyles,
      computedMessage,
      onToastClick,
      onToastClose,
      startTimer,
      clearTimer
    };
  }
});
var _hoisted_1 = ["role"];
var _hoisted_2 = { class: "va-toast__group" };
var _hoisted_3 = ["textContent"];
var _hoisted_4 = { class: "va-toast__content" };
var _hoisted_5 = ["innerHTML"];
var _hoisted_6 = ["textContent"];
var _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.closeable ? "alertdialog" : "alert",
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onToastClick && _ctx.onToastClick(...args))
      }, [
        createBaseVNode("div", _hoisted_2, [
          _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
            key: 0,
            class: "va-toast__title",
            textContent: toDisplayString(_ctx.$props.title)
          }, null, 8, _hoisted_3)) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", _hoisted_4, [
            _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: _ctx.computedMessage
            }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock("p", {
              key: 1,
              textContent: toDisplayString(_ctx.computedMessage)
            }, null, 8, _hoisted_6))
          ], 512), [
            [vShow, _ctx.$props.message]
          ]),
          _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7, [
            createVNode(_component_VaToastRenderer, {
              render: _ctx.$props.render
            }, null, 8, ["render"])
          ])) : createCommentVNode("", true),
          _ctx.$props.closeable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: "va-toast__close-icon",
            role: "button",
            "aria-label": _ctx.t("closeToast"),
            tabindex: "0",
            size: "small",
            name: _ctx.$props.icon,
            onClick: withModifiers(_ctx.onToastClose, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
          }, null, 8, ["aria-label", "name", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ])
      ], 46, _hoisted_1), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  });
}
var _VaToast = _export_sfc(_sfc_main2, [["render", _sfc_render2], ["styles", [...VaIcon.styles || [], ...VaToastRenderer.styles || [], _style_02]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/index.js
var VaToast = withConfigTransport(_VaToast);

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/toast.js
var GAP = 5;
var seed = 1;
getGlobal().vaToastInstances = [];
var getTranslateValue = (item, position) => {
  if (item.el) {
    const direction = position.includes("bottom") ? -1 : 1;
    return (item.el.offsetHeight + GAP) * direction;
  }
  return 0;
};
var getNewTranslateValue = (transformY, redundantHeight, position) => {
  const direction = position.includes("bottom") ? -1 : 1;
  return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
var getNodeProps = (vNode) => {
  var _a;
  return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  var _a;
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  const nodeProps = getNodeProps(targetInstance);
  const {
    offsetX: targetOffsetX,
    offsetY: targetOffsetY,
    position: targetPosition
  } = nodeProps;
  const redundantHeight = (_a = targetInstance.el) == null ? void 0 : _a.offsetHeight;
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    if (instance.component) {
      const { offsetX, offsetY, position } = getNodeProps(instance);
      const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
      if (isNextInstance && instance.el && redundantHeight) {
        const [_, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
        const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
        instance.el.style.transform = `translate(0, ${transformYNew}px)`;
      }
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, {
  props,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props == null ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode(component, { ...props, onClose }, children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a;
    return ((_a = instance.el) == null ? void 0 : _a.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    const { offsetX, offsetY, position } = nodeProps;
    vNode.el.style.display = "flex";
    vNode.el.id = "notification_" + seed;
    let transformY = 0;
    getGlobal().vaToastInstances.filter((item) => {
      const {
        offsetX: itemOffsetX,
        offsetY: itemOffsetY,
        position: itemPosition
      } = getNodeProps(item);
      return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
    }).forEach((item) => {
      transformY += getTranslateValue(item, position);
    });
    vNode.el.style.transform = `translate(0, ${transformY}px)`;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/plugin/index.js
var createVaToastPlugin = (app2) => ({
  init(options) {
    return createToastInstance(options, app2 == null ? void 0 : app2._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app2 == null ? void 0 : app2._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaToast", createVaToastPlugin(app2));
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/plugin/index.js
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app2, "$vaDropdown", vaDropdownPlugin);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useCaptureEvent.js
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, { capture: true, ...options }));
  onBeforeUnmount(() => window.removeEventListener(event, cb, { capture: true, ...options }));
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTemplateRef.js
var useTemplateRef = (key) => {
  const vm = getCurrentInstance();
  const el = shallowRef();
  const updateEl = () => {
    var _a;
    el.value = (_a = vm.proxy) == null ? void 0 : _a.$refs[key];
  };
  onMounted(updateEl);
  onUpdated(updateEl);
  onBeforeUnmount(updateEl);
  return el;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useHTMLElement.js
var extractHTMLElement = (el) => el && "$el" in el ? el.$el : el;
var useHTMLElement = (key) => {
  if (isRef(key)) {
    return computed({
      get() {
        return extractHTMLElement(key.value);
      },
      set(value) {
        key.value = value;
      }
    });
  }
  if (key) {
    const el2 = useTemplateRef(key);
    return computed({
      get() {
        return extractHTMLElement(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef();
  return computed({
    set(value) {
      el.value = extractHTMLElement(value);
    },
    get() {
      return el.value;
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useClickOutside.js
var checkIfElementChild = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray = (a) => Array.isArray(a) ? a : [a];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("click", (event) => {
    const clickTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const isClickInside = safeArray(elements).some((element) => {
      const el = extractHTMLElement(unref(element));
      return el && checkIfElementChild(el, clickTarget);
    });
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useModalLevel.js
var modalsStack = shallowReactive([]);
var useModalLevel = () => {
  const modalId = uniqueId_1();
  const modalLevel = computed(
    () => modalsStack.findIndex(({ id }) => id === modalId)
  );
  const registerModal = () => {
    if (modalLevel.value !== -1) {
      return;
    }
    modalsStack.push({
      id: modalId
    });
  };
  const unregisterModal = () => {
    if (modalLevel.value === -1) {
      return;
    }
    modalsStack.splice(modalLevel.value, 1);
  };
  const isTopLevelModal = computed(
    () => modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1
  );
  const isLowestLevelModal = computed(
    () => modalLevel.value === 0
  );
  const isMoreThenOneModalOpen = computed(() => modalsStack.length > 1);
  return {
    modalId,
    modalLevel,
    registerModal,
    unregisterModal,
    isTopLevelModal,
    isLowestLevelModal,
    isMoreThenOneModalOpen
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useStateful.js
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var createStatefulProps = (modelValueType, statefulDefault = false) => {
  return {
    stateful: { type: Boolean, default: statefulDefault },
    modelValue: { type: modelValueType }
  };
};
var useStatefulEmits = ["update:modelValue"];
var useStateful = (props, emit, key = "modelValue", options = {}) => {
  const { defaultValue, eventName } = options;
  const event = eventName || `update:${key.toString()}`;
  const valueState = ref(defaultValue === void 0 ? props[key] : defaultValue);
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props[key], (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get: () => {
      if (props.stateful) {
        return valueState.value;
      }
      return props[key];
    },
    set: (value) => {
      if (props.stateful) {
        valueState.value = value;
      }
      emit(event, value);
    }
  });
  return { valueComputed };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTrapFocus.js
var FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
var trapInEl = null;
var useTrapFocus = () => {
  const document2 = useDocument();
  const window3 = useWindow();
  let focusableElements = [];
  let firstFocusableElement = null;
  let lastFocusableElement = null;
  let isFocusTrapped = false;
  const focusFirstElement = () => {
    firstFocusableElement == null ? void 0 : firstFocusableElement.focus();
  };
  const focusLastElement = () => {
    lastFocusableElement == null ? void 0 : lastFocusableElement.focus();
  };
  const onKeydown = (evt) => {
    var _a, _b;
    const isTabPressed = evt.code === "Tab";
    const isShiftPressed = evt.shiftKey;
    if (!isTabPressed) {
      return;
    }
    if (!isFocusTrapped) {
      isFocusTrapped = true;
      evt.preventDefault();
      isShiftPressed ? focusLastElement() : focusFirstElement();
      return;
    }
    if (((_a = document2.value) == null ? void 0 : _a.activeElement) === lastFocusableElement && !isShiftPressed) {
      evt.preventDefault();
      focusFirstElement();
      return;
    }
    if (((_b = document2.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
      evt.preventDefault();
      focusLastElement();
    }
  };
  const trapFocusIn = (el) => {
    trapInEl = el;
    freeFocus();
    trapFocus();
  };
  const trapFocus = () => {
    var _a;
    if (!trapInEl) {
      return;
    }
    focusableElements = Array.from(trapInEl.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    (_a = window3.value) == null ? void 0 : _a.addEventListener("keydown", onKeydown);
  };
  const freeFocus = () => {
    var _a;
    focusableElements = [];
    firstFocusableElement = null;
    lastFocusableElement = null;
    isFocusTrapped = false;
    (_a = window3.value) == null ? void 0 : _a.removeEventListener("keydown", onKeydown);
  };
  return {
    trapFocus,
    freeFocus,
    trapFocusIn
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useBem.js
var useBem = (prefix2, modifiers) => {
  if (__DEV__ && !prefix2) {
    console.warn('You must pass the @param "prefix" to the useBem hook!');
  }
  const modifiersList = computed(() => isFunction_1(modifiers) ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${kebabCase_1(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_, key) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
    },
    get(_, key, receiver) {
      switch (key) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/utils/unwrapEl.js
var unwrapEl = (el) => {
  if (!el) {
    return;
  }
  if ("$el" in el) {
    return el.$el;
  }
  return el;
};

// node_modules/vuestic-ui/dist/web-components/src/utils/focus.js
var focusElement = (el) => {
  if (!el) {
    return;
  }
  el.focus();
  el.dispatchEvent(new Event("focus", { bubbles: true }));
};
var blurElement = (el) => {
  if (!el) {
    return;
  }
  el.blur();
  el.dispatchEvent(new Event("blur", { bubbles: true }));
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFocus.js
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const isFocused = ref(false);
  const onFocus = (e) => {
    isFocused.value = true;
    emit == null ? void 0 : emit("focus", e);
  };
  const onBlur = (e) => {
    isFocused.value = false;
    emit == null ? void 0 : emit("blur", e);
  };
  const focus = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    focusElement(unwrapEl(el == null ? void 0 : el.value));
  };
  const blur = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    blurElement(unwrapEl(el == null ? void 0 : el.value));
  };
  let element;
  onMounted(() => {
    var _a, _b;
    element = (_b = (_a = el == null ? void 0 : el.value) == null ? void 0 : _a.$el) != null ? _b : el == null ? void 0 : el.value;
    if (element) {
      element.addEventListener("focus", onFocus);
      element.addEventListener("blur", onBlur);
    }
  });
  onBeforeUnmount(() => {
    if (element) {
      element.removeEventListener("focus", onFocus);
      element.removeEventListener("blur", onBlur);
    }
  });
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useHover.js
function useHover(el, disabled) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  disabled && watch(disabled, (v) => {
    if (v) {
      isHovered.value = false;
    }
  });
  onMounted(() => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    const getTarget = useHTMLElement(el);
    useEvent("mouseenter", onMouseEnter, getTarget);
    useEvent("mouseleave", onMouseLeave, getTarget);
  });
  return { isHovered, onMouseEnter, onMouseLeave };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useHoverStyle.js
var useHoverStyleProps = {
  hoverBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  hoverOpacity: { type: Number, default: 0.15 },
  hoverMaskColor: { type: String, default: "textInverted" }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/usePressed.js
function usePressed(el) {
  const isPressed = ref(false);
  const onMouseDown = () => {
    isPressed.value = true;
  };
  const onMouseUp = () => {
    isPressed.value = false;
  };
  onMounted(() => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    const getTarget = useHTMLElement(el);
    useEvent("mousedown", onMouseDown, getTarget);
    useEvent(["mouseup", "mouseleave"], onMouseUp, getTarget);
  });
  return { isPressed, onMouseDown, onMouseUp };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/usePressedStyle.js
var usePressedStyleProps = {
  pressedBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  pressedOpacity: { type: Number, default: 0.13 },
  pressedMaskColor: { type: String, default: "textPrimary" }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useRouterLink.js
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: "" },
  replace: { type: Boolean, default: false },
  append: { type: Boolean, default: false },
  exact: { type: Boolean, default: false },
  activeClass: { type: String, default: "" },
  exactActiveClass: { type: String, default: "" },
  href: { type: String, default: "" },
  target: { type: String, default: "" },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props) => {
  const globalProperties = computed(() => {
    var _a;
    return (_a = getCurrentInstance()) == null ? void 0 : _a.appContext.config.globalProperties;
  });
  computed(() => {
    var _a;
    return !!((_a = globalProperties.value) == null ? void 0 : _a.$nuxt);
  });
  const vueRouter = computed(() => {
    var _a;
    return (_a = globalProperties.value) == null ? void 0 : _a.$router;
  });
  const vueRoute = computed(() => {
    var _a;
    return (_a = globalProperties.value) == null ? void 0 : _a.$route;
  });
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    if (props.to) {
      return "router-link";
    }
    return props.tag || "div";
  });
  const isLinkTag = computed(() => ["a", "router-link", "nuxt-link"].includes(tagComputed.value));
  const linkAttributesComputed = computed(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props.target,
      href: hrefComputed.value
    } : {
      target: props.target,
      to: props.to,
      replace: props.replace,
      append: props.append,
      activeClass: props.activeClass,
      exact: props.exact,
      exactActiveClass: props.exactActiveClass
    };
  });
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a;
    return props.href || (props.to ? (_a = vueRouter.value) == null ? void 0 : _a.resolve(props.to, vueRoute.value).href : "");
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSlotPassed.js
var checkSlotChildrenDeep = (v, initial = true) => {
  var _a;
  if (!v || initial && (!isFunction_1(v) || !((_a = v()) == null ? void 0 : _a.length))) {
    return false;
  }
  const slotData = initial ? v() : v;
  if (Array.isArray(slotData)) {
    return slotData.some((el) => {
      return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
  }
  return !!slotData.children;
};
var useSlotPassed = (name = "default") => {
  const { slots } = getCurrentInstance();
  return computed(() => checkSlotChildrenDeep(slots[name]));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/hooks/useButtonBackground.js
var useButtonBackground = (colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
  const backgroundColor = computed(() => {
    if (props.plain) {
      return "transparent";
    }
    return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
  });
  const hoveredBgState = computed(() => !props.plain && isHovered.value);
  const pressedBgState = computed(() => !props.plain && isPressed.value);
  const backgroundColorOpacity = computed(() => {
    if (pressedBgState.value && props.pressedBehavior === "opacity") {
      return props.pressedOpacity;
    }
    if (hoveredBgState.value && props.hoverBehavior === "opacity") {
      return props.hoverOpacity;
    }
    return props.backgroundOpacity;
  });
  const hoveredMaskState = computed(() => hoveredBgState.value && props.hoverBehavior === "mask");
  const pressedMaskState = computed(() => pressedBgState.value && props.pressedBehavior === "mask");
  const backgroundMaskOpacity = computed(() => {
    if (pressedMaskState.value) {
      return props.pressedOpacity;
    }
    if (hoveredMaskState.value) {
      return props.hoverOpacity;
    }
    return 0;
  });
  const backgroundMaskColor = computed(() => {
    if (pressedMaskState.value) {
      return getColor(props.pressedMaskColor);
    }
    if (hoveredMaskState.value) {
      return getColor(props.hoverMaskColor);
    }
    return "transparent";
  });
  return {
    backgroundColor,
    backgroundColorOpacity,
    backgroundMaskOpacity,
    backgroundMaskColor
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/hooks/useButtonAttributes.js
var useButtonAttributes = (props) => {
  const { linkAttributesComputed, isLinkTag } = useRouterLink(props);
  const typeComputed = computed(() => isLinkTag.value ? void 0 : props.type);
  const buttonAttributesComputed = computed(() => {
    const disabledAttributes = {
      "aria-disabled": !!props.disabled,
      disabled: !!props.disabled
    };
    if (isLinkTag.value) {
      return disabledAttributes;
    }
    return {
      type: typeComputed.value,
      tabindex: props.loading || props.disabled ? -1 : 0,
      ...disabledAttributes
    };
  });
  return computed(() => ({ ...linkAttributesComputed.value, ...buttonAttributesComputed.value }));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/hooks/useButtonTextColor.js
var getOpacity = (opacity) => {
  var _a, _b, _c;
  if (isServer()) {
    return opacity;
  }
  if (opacity > 0) {
    const userAgent = (_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent;
    const isSafari = userAgent && /^((?!chrome|android).)*safari/i.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.userAgent);
    const isLatestSafari = userAgent && /(version.)15|16/i.test((_c = window == null ? void 0 : window.navigator) == null ? void 0 : _c.userAgent);
    if (isSafari && !isLatestSafari) {
      return opacity < 1 ? 1 - opacity : opacity;
    }
  }
  return opacity;
};
var useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, colorToRgba: colorToRgba2, getStateMaskGradientBackground: getStateMaskGradientBackground2 } = useColors();
  const plainColorStyles = computed(() => ({
    background: "transparent",
    color: textColorComputed.value,
    "-webkit-background-clip": "text",
    "background-clip": "text",
    opacity: getPlainTextOpacity.value
  }));
  const getStateColor = (maskColor, stateOpacity, stateBehavior) => {
    const maskStateColor = getColor(maskColor);
    let stateStyles;
    if (stateBehavior === "opacity") {
      stateStyles = { color: colorToRgba2(textColorComputed.value, stateOpacity) };
    } else {
      stateStyles = {
        background: getStateMaskGradientBackground2(colorComputed.value, maskStateColor, stateOpacity),
        color: stateOpacity < 1 ? colorToRgba2(textColorComputed.value, getOpacity(stateOpacity)) : maskStateColor
      };
    }
    return { ...plainColorStyles.value, ...stateStyles };
  };
  const hoverTextColorComputed = computed(() => {
    return getStateColor(props.hoverMaskColor, props.hoverOpacity, props.hoverBehavior);
  });
  const pressedTextColorComputed = computed(() => {
    return getStateColor(props.pressedMaskColor, props.pressedOpacity, props.pressedBehavior);
  });
  const getPlainTextOpacity = computed(() => {
    if (props.disabled) {
      return void 0;
    }
    if (props.textOpacity === 1 || isHovered.value && !isPressed.value) {
      return 1;
    }
    return isPressed.value ? 0.9 : props.textOpacity;
  });
  return computed(() => {
    const defaultColorStyles = {
      color: textColorComputed.value,
      background: "transparent"
    };
    props.plain && Object.assign(defaultColorStyles, plainColorStyles.value, { background: textColorComputed.value });
    if (!props.plain) {
      return defaultColorStyles;
    }
    if (isPressed.value) {
      return pressedTextColorComputed.value;
    }
    if (isHovered.value) {
      return hoverTextColorComputed.value;
    }
    return defaultColorStyles;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-icon/index.js
var VaIcon2 = withConfigTransport(VaIcon);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-circle/VaProgressCircle.js
var _style_03 = ":root,\n:host {\n  /* Circle */\n  --va-progress-circle-position: relative;\n  --va-progress-circle-overflow: hidden;\n  /* Circle Wrapper */\n  --va-progress-circle-width: 80%;\n  --va-progress-circle-height: 80%;\n  /* Circle Overlay */\n  --va-progress-circle-overlay-transition: all ease 2s;\n  /* Circle Info */\n  --va-progress-circle-font-size: 0.75rem;\n}\n.va-progress-circle {\n  position: var(--va-progress-circle-position);\n  overflow: var(--va-progress-circle-overflow);\n  font-family: var(--va-font-family);\n}\n.va-progress-circle__wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  margin: auto;\n  transform: rotate(-90deg);\n  width: var(--va-progress-circle-width);\n  height: var(--va-progress-circle-height);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-progress-circle--indeterminate .va-progress-circle__wrapper {\n  animation: va-progress-circle__wrapper--indeterminate 2s linear infinite;\n}\n.va-progress-circle__overlay {\n  transition: var(--va-progress-circle-overlay-transition);\n}\n.va-progress-circle--indeterminate .va-progress-circle__overlay {\n  animation: va-progress-circle__overlay--indeterminate 2s ease-in-out infinite;\n}\n.va-progress-circle__info {\n  font-size: var(--va-progress-circle-font-size);\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n@keyframes va-progress-circle__wrapper--indeterminate {\n100% {\n    transform: rotate(270deg);\n}\n}\n@keyframes va-progress-circle__overlay--indeterminate {\n0% {\n    stroke-dasharray: 1, 125;\n    stroke-dashoffset: 0;\n}\n50% {\n    stroke-dasharray: 125, 125;\n    stroke-dashoffset: -65px;\n}\n100% {\n    stroke-dasharray: 125, 125;\n    stroke-dashoffset: -125px;\n}\n}";
var _sfc_main3 = defineComponent({
  name: "VaProgressCircle",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: Number, default: 0.06 },
    color: { type: String, default: "primary" }
  },
  setup(props) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed(() => clamp_1(props.thickness, 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp_1(props.modelValue, 0, 100) / 100));
    const colorComputed = computed(() => getColor(props.color, void 0, true));
    const { t } = useTranslation();
    return {
      infoStyle: computed(() => ({ color: colorComputed.value })),
      rootStyle: computed(() => ({
        width: sizeComputed.value,
        height: sizeComputed.value
      })),
      rootClass: computed(() => ({
        "va-progress-circle--indeterminate": props.indeterminate
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        "aria-label": t("progressState"),
        "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
      })),
      colorComputed,
      radius,
      dasharray,
      dashoffset,
      cappedThickness
    };
  }
});
var _hoisted_12 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-circle", _ctx.rootClass],
    style: _ctx.rootStyle
  }, _ctx.ariaAttributesComputed), [
    (openBlock(), createElementBlock("svg", _hoisted_12, [
      createBaseVNode("circle", {
        class: "va-progress-circle__overlay",
        cx: "50%",
        cy: "50%",
        r: _ctx.radius,
        fill: "none",
        stroke: _ctx.colorComputed,
        "stroke-width": _ctx.cappedThickness + "%",
        "stroke-dasharray": _ctx.dasharray,
        "stroke-dashoffset": _ctx.dashoffset
      }, null, 8, _hoisted_22)
    ])),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.infoStyle),
      class: "va-progress-circle__info"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)) : createCommentVNode("", true)
  ], 16);
}
var _VaProgressCircle = _export_sfc(_sfc_main3, [["render", _sfc_render3], ["styles", [_style_03]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-circle/index.js
var VaProgressCircle = withConfigTransport(_VaProgressCircle);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/VaButton.js
var _style_04 = ':root,\n:host {\n  /* General */\n  --va-button-display: inline-flex;\n  --va-button-justify-content: center;\n  --va-button-align-items: center;\n  --va-button-background-image: none;\n  --va-button-box-shadow: none;\n  --va-button-border-width: 0;\n  --va-button-border-color: unset;\n  --va-button-border-style: none;\n  --va-button-font-weight: 600;\n  --va-button-transition: none;\n  --va-button-padding: 0;\n  --va-button-cursor: pointer;\n  /* Small */\n  --va-button-sm-size: 1.5rem;\n  --va-button-sm-content-py: 0.25rem;\n  --va-button-sm-content-px: 0.375rem;\n  --va-button-sm-only-icon-content-px: 0.25rem;\n  --va-button-sm-font-size: 0.8125rem;\n  --va-button-sm-letter-spacing: 0;\n  --va-button-sm-line-height: 1rem;\n  --va-button-sm-border-radius: 0.125rem;\n  --va-button-sm-icon-side-padding: 0.188rem;\n  /* Medium */\n  --va-button-size: 2.25rem;\n  --va-button-content-py: 0.5rem;\n  --va-button-content-px: 0.75rem;\n  --va-button-only-icon-content-px: 0.5rem;\n  --va-button-font-size: 0.9375rem;\n  --va-button-letter-spacing: 0;\n  --va-button-line-height: 1.25rem;\n  --va-button-border-radius: 0.25rem;\n  --va-button-icon-side-padding: 0.375rem;\n  /* Large */\n  --va-button-lg-size: 3rem;\n  --va-button-lg-content-py: 0.75rem;\n  --va-button-lg-content-px: 1rem;\n  --va-button-lg-only-icon-content-px: 1rem;\n  --va-button-lg-font-size: 1.05rem;\n  --va-button-lg-letter-spacing: 0;\n  --va-button-lg-line-height: 1.5rem;\n  --va-button-lg-border-radius: 0.5rem;\n  --va-button-lg-icon-side-padding: 0.5rem;\n  /* Bordered */\n  --va-button-bordered-border: 1px;\n  --va-button-bordered-style: solid;\n}\n.va-button {\n  position: relative;\n  padding: var(--va-button-padding);\n  display: var(--va-button-display);\n  justify-content: var(--va-button-justify-content);\n  align-items: var(--va-button-align-items);\n  border-width: var(--va-button-border-width);\n  border-color: var(--va-button-border-color);\n  border-style: var(--va-button-border-style);\n  background-image: var(--va-button-background-image);\n  box-shadow: var(--va-button-box-shadow);\n  font-family: var(--va-font-family);\n  font-weight: var(--va-button-font-weight);\n  text-decoration: none;\n  text-transform: initial;\n  transition: var(--va-button-transition);\n  box-sizing: border-box;\n  cursor: var(--va-button-cursor);\n}\n.va-button::after, .va-button::before {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  border-radius: inherit;\n}\n.va-button::before {\n  background: var(--6057e024);\n  opacity: var(--cb320172);\n}\n.va-button::after {\n  background-color: var(--38d51418);\n  opacity: var(--5880f900);\n}\n.va-button__content {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  z-index: 1;\n}\n.va-button__content__title, .va-button__content__icon {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: auto;\n  white-space: nowrap;\n}\n.va-button__content--loading {\n  opacity: 0;\n}\n.va-button--small {\n  line-height: var(--va-button-sm-line-height);\n  border-radius: var(--va-button-sm-border-radius);\n  letter-spacing: var(--va-button-sm-letter-spacing);\n  min-height: var(--va-button-sm-size);\n  min-width: var(--va-button-sm-size);\n}\n.va-button--small .va-button__content {\n  font-size: var(--va-button-sm-font-size);\n  padding: var(--va-button-sm-content-py) var(--va-button-sm-content-px);\n}\n.va-button--small.va-button--bordered {\n  line-height: calc(var(--va-button-sm-line-height) - 2 * var(--va-button-bordered-border));\n}\n.va-button--small .va-button__left-icon,\n.va-button--small .va-button__right-icon {\n  font-size: var(--va-button-sm-line-height) !important;\n}\n.va-button--small .va-button__left-icon {\n  margin-right: var(--va-button-sm-icons-spacing);\n}\n.va-button--small .va-button__right-icon {\n  margin-left: var(--va-button-sm-icons-spacing);\n}\n.va-button--small.va-button--left-icon .va-button__content {\n  padding-left: var(--va-button-sm-icon-side-padding);\n}\n.va-button--small.va-button--left-icon .va-button__left-icon {\n  margin-right: 2px;\n}\n.va-button--small.va-button--right-icon .va-button__content {\n  padding-right: var(--va-button-sm-icon-side-padding);\n}\n.va-button--small.va-button--right-icon .va-button__right-icon {\n  margin-left: 2px;\n}\n.va-button--small.va-button--icon-only .va-button__content {\n  padding-right: var(--va-button-sm-content-px);\n  padding-left: var(--va-button-sm-content-px);\n}\n.va-button--normal {\n  line-height: var(--va-button-line-height);\n  border-radius: var(--va-button-border-radius);\n  letter-spacing: var(--va-button-letter-spacing);\n  min-height: var(--va-button-size);\n  min-width: var(--va-button-size);\n}\n.va-button--normal .va-button__content {\n  font-size: var(--va-button-font-size);\n  padding: var(--va-button-content-py) var(--va-button-content-px);\n  line-height: var(--va-button-line-height);\n}\n.va-button--normal.va-button--bordered .va-button__content {\n  line-height: calc(var(--va-button-line-height) - 2 * var(--va-button-bordered-border));\n}\n.va-button--normal .va-button__left-icon,\n.va-button--normal .va-button__right-icon {\n  font-size: var(--va-button-line-height) !important;\n}\n.va-button--normal .va-button__left-icon {\n  margin-right: var(--va-button-icons-spacing);\n}\n.va-button--normal .va-button__right-icon {\n  margin-left: var(--va-button-icons-spacing);\n}\n.va-button--normal.va-button--left-icon .va-button__content {\n  padding-left: var(--va-button-icon-side-padding);\n}\n.va-button--normal.va-button--left-icon .va-button__left-icon {\n  margin-right: 4px;\n}\n.va-button--normal.va-button--right-icon .va-button__content {\n  padding-right: var(--va-button-icon-side-padding);\n}\n.va-button--normal.va-button--right-icon .va-button__right-icon {\n  margin-left: 4px;\n}\n.va-button--normal.va-button--icon-only .va-button__content {\n  padding-right: var(--va-button-content-px);\n  padding-left: var(--va-button-content-px);\n}\n.va-button--large {\n  line-height: var(--va-button-lg-line-height);\n  border-radius: var(--va-button-lg-border-radius);\n  letter-spacing: var(--va-button-lg-letter-spacing);\n  min-height: var(--va-button-lg-size);\n  min-width: var(--va-button-lg-size);\n}\n.va-button--large .va-button__content {\n  font-size: var(--va-button-lg-font-size);\n  padding: var(--va-button-lg-content-py) var(--va-button-lg-content-px);\n}\n.va-button--large.va-button--bordered {\n  line-height: calc(var(--va-button-lg-line-height) - 2 * var(--va-button-bordered-border));\n}\n.va-button--large .va-button__left-icon,\n.va-button--large .va-button__right-icon {\n  font-size: var(--va-button-lg-line-height) !important;\n}\n.va-button--large .va-button__left-icon {\n  margin-right: var(--va-button-lg-icons-spacing);\n}\n.va-button--large .va-button__right-icon {\n  margin-left: var(--va-button-lg-icons-spacing);\n}\n.va-button--large.va-button--left-icon .va-button__content {\n  padding-left: var(--va-button-lg-icon-side-padding);\n}\n.va-button--large.va-button--left-icon .va-button__left-icon {\n  margin-right: 4px;\n}\n.va-button--large.va-button--right-icon .va-button__content {\n  padding-right: var(--va-button-lg-icon-side-padding);\n}\n.va-button--large.va-button--right-icon .va-button__right-icon {\n  margin-left: 4px;\n}\n.va-button--large.va-button--icon-only .va-button__content {\n  padding-right: var(--va-button-lg-content-px);\n  padding-left: var(--va-button-lg-content-px);\n}\n.va-button--plain {\n  min-width: auto;\n  min-height: auto;\n}\n.va-button--plain .va-button__content {\n  padding: 0;\n  z-index: unset;\n}\n.va-button--round {\n  border-radius: 999px;\n}\n.va-button--bordered {\n  border-width: var(--va-button-bordered-border);\n  border-style: var(--va-button-bordered-style);\n}\n.va-button.va-button--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-button--icon-only .va-button__left-icon,\n.va-button--icon-only .va-button__right-icon {\n  margin-left: 0;\n  margin-right: 0;\n}\n.va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-button--loading {\n  pointer-events: none;\n}\n.va-button--block {\n  display: flex;\n  min-width: 100%;\n}\n.va-button__loader {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}';
var __default__ = defineComponent({
  name: "VaButton",
  components: { VaIcon: VaIcon2, VaProgressCircle },
  props: {
    ...useComponentPresetProp,
    ...useSizeProps,
    ...useHoverStyleProps,
    ...usePressedStyleProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: Number, default: 1 },
    backgroundOpacity: { type: Number, default: 1 },
    borderColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  },
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed } = useSize(props);
    const loaderSizeComputed = computed(() => {
      const size = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size ? `${+size[1] / 2}${size[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props);
    const attributesComputed = useButtonAttributes(props);
    const { disabled } = toRefs(props);
    const button = shallowRef();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed(() => props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed(() => ({
      size: props.size,
      color: iconColorComputed.value
    }));
    const wrapperClassComputed = computed(() => ({ "va-button__content--loading": props.loading }));
    const isSlotContentPassed = useSlotPassed();
    const isOneIcon = computed(() => !!(props.iconRight && !props.icon || !props.iconRight && props.icon));
    const isOnlyIcon = computed(() => !isSlotContentPassed.value && isOneIcon.value);
    const computedClass = useBem("va-button", () => ({
      ...pick_1(props, ["disabled", "block", "loading", "round", "plain"]),
      small: props.size === "small",
      normal: !props.size || props.size === "medium",
      large: props.size === "large",
      opacity: props.textOpacity < 1,
      bordered: !!props.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
      rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
    }));
    const isTransparentBg = computed(() => props.plain || props.backgroundOpacity < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed(() => ({
      borderColor: props.borderColor ? getColor(props.borderColor) : "transparent",
      ...contentColorComputed.value
    }));
    const publicMethods = { focus, blur };
    return {
      button,
      tagComputed,
      computedClass,
      computedStyle,
      textColorComputed,
      loaderSizeComputed,
      attributesComputed,
      wrapperClassComputed,
      iconAttributesComputed,
      backgroundColor,
      backgroundMaskColor,
      backgroundMaskOpacity,
      backgroundColorOpacity,
      ...publicMethods
    };
  }
});
var __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "6057e024": _ctx.backgroundColor,
    "cb320172": _ctx.backgroundColorOpacity,
    "38d51418": _ctx.backgroundMaskColor,
    "5880f900": _ctx.backgroundMaskOpacity
  }));
};
var __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
var _sfc_main4 = __default__;
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "button",
    class: ["va-button", _ctx.computedClass],
    style: _ctx.computedStyle
  }, _ctx.attributesComputed), {
    default: withCtx(() => [
      createBaseVNode("span", {
        class: normalizeClass(["va-button__content", _ctx.wrapperClassComputed])
      }, [
        renderSlot(_ctx.$slots, "prepend", normalizeProps(guardReactiveProps({ icon: _ctx.icon, iconAttributes: _ctx.iconAttributesComputed })), () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            class: "va-button__left-icon",
            name: _ctx.icon
          }, _ctx.iconAttributesComputed), null, 16, ["name"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "default"),
        renderSlot(_ctx.$slots, "append", normalizeProps(guardReactiveProps({ icon: _ctx.iconRight, iconAttributes: _ctx.iconAttributesComputed })), () => [
          _ctx.iconRight ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            class: "va-button__right-icon",
            name: _ctx.iconRight
          }, _ctx.iconAttributesComputed), null, 16, ["name"])) : createCommentVNode("", true)
        ])
      ], 2),
      _ctx.loading ? renderSlot(_ctx.$slots, "loading", normalizeProps(mergeProps({ key: 0 }, {
        size: _ctx.loaderSizeComputed,
        color: _ctx.textColorComputed
      })), () => [
        createVNode(_component_va_progress_circle, {
          class: "va-button__loader",
          size: _ctx.loaderSizeComputed,
          color: _ctx.textColorComputed,
          thickness: 0.15,
          indeterminate: ""
        }, null, 8, ["size", "color", "thickness"])
      ]) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var VaButton = _export_sfc(_sfc_main4, [["render", _sfc_render4], ["styles", [...VaIcon2.styles || [], ...VaProgressCircle.styles || [], _style_04]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/index.js
var VaButton2 = withConfigTransport(VaButton);

// node_modules/vuestic-ui/dist/web-components/src/composables/useCurrentComponentId.js
var useCurrentComponentId = () => {
  const instance = getCurrentInstance();
  return `${instance.appContext.app._uid}_${instance.uid}`;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/hooks/useBlur.js
var openedModals = [];
var useBlur = (shouldBlur, isModalShown) => {
  const id = useCurrentComponentId();
  const document2 = useDocument();
  const blur = () => {
    var _a;
    if (openedModals.includes(id)) {
      return;
    }
    openedModals.push(id);
    (_a = document2.value) == null ? void 0 : _a.body.classList.add("va-modal-overlay-background--blurred");
  };
  const removeBlur = () => {
    var _a;
    const modalIndex = openedModals.indexOf(id);
    if (modalIndex === -1) {
      return;
    }
    openedModals.splice(modalIndex, 1);
    if (openedModals.length === 0) {
      (_a = document2.value) == null ? void 0 : _a.body.classList.remove("va-modal-overlay-background--blurred");
    }
  };
  watchEffect(() => {
    if (!shouldBlur.value) {
      return;
    }
    if (isModalShown.value) {
      blur();
    } else {
      removeBlur();
    }
  });
  onBeforeUnmount(removeBlur);
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/VaModal.js
var _style_05 = ":root,\n:host {\n  --va-modal-title-margin-bottom: 1.5rem;\n  --va-modal-position: fixed;\n  --va-modal-top: 0;\n  --va-modal-left: 0;\n  --va-modal-display: flex;\n  --va-modal-width: 100%;\n  --va-modal-height: 100%;\n  --va-modal-align-items: center;\n  --va-modal-justify-content: center;\n  --va-modal-overflow: hidden;\n  --va-modal-outline: 0;\n  --va-modal-z-index: var(--va-z-index-teleport-overlay);\n  --va-modal-container-z-index: 100;\n  --va-modal-basic-duration: 0.3s;\n  --va-modal-opacity-transition: calc(var(--va-modal-basic-duration) * 0.5) cubic-bezier(1, 0.5, 0.8, 1);\n  --va-modal-transform-transition: var(--va-modal-basic-duration) ease;\n  --va-modal-overlay-background-blur-radius: 4px;\n  --va-modal-padding: var(--va-modal-padding-top) var(--va-modal-padding-right) var(--va-modal-padding-bottom) var(--va-modal-padding-left);\n  --va-modal-padding-top: 1.25rem;\n  --va-modal-padding-right: 1.5rem;\n  --va-modal-padding-bottom: 1.5rem;\n  --va-modal-padding-left: 1.5rem;\n  /* Dialog */\n  --va-modal-dialog-min-height: 3.125rem;\n  --va-modal-dialog-height: fit-content;\n  --va-modal-dialog-border-radius: 0.375rem;\n  --va-modal-dialog-margin: 1rem;\n  --va-modal-dialog-box-shadow: 0 4px 70px -18px var(--va-shadow);\n  --va-modal-dialog-max-width: 768px;\n  --va-modal-dialog-max-height: calc(100vh - 2rem);\n  --va-modal-dialog-position: relative;\n  /* Fullscreen */\n  --va-modal-overlay-position: fixed;\n  --va-modal-overlay-top: 0;\n  --va-modal-overlay-left: 0;\n  --va-modal-overlay-z-index: calc(var(--va-modal-container-z-index) - 1);\n  --va-modal-overlay-width: 100vw;\n  --va-modal-overlay-height: 100vh;\n  --va-modal-overlay-opacity-transition: opacity math.div(2 * var(--va-modal-basic-duration), 3) cubic-bezier(1, 0.5, 0.8, 1);\n}\n.va-modal-overlay-background--blurred > :not(div[class*=va-]) {\n  filter: blur(var(--va-modal-overlay-background-blur-radius));\n  position: absolute;\n  height: 100%;\n  width: 100%;\n}\n.va-modal {\n  position: var(--va-modal-position);\n  display: var(--va-modal-display);\n  align-items: var(--va-modal-align-items);\n  justify-content: var(--va-modal-justify-content);\n  width: var(--va-modal-width);\n  height: var(--va-modal-height);\n  top: var(--va-modal-top);\n  left: var(--va-modal-left);\n  overflow: var(--va-modal-overflow);\n  outline: var(--va-modal-outline);\n  z-index: var(--va-modal-z-index);\n  font-family: var(--va-font-family);\n}\n.va-modal__title {\n  margin-bottom: 1.5rem;\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n}\n.va-modal__container {\n  z-index: var(--va-modal-container-z-index);\n  max-width: 100%;\n}\n.va-modal-enter-from .va-modal__container, .va-modal-leave-to .va-modal__container {\n  opacity: 0;\n  transform: translateY(-30%);\n}\n.va-modal-enter-active .va-modal__container, .va-modal-leave-active .va-modal__container {\n  transition: opacity var(--va-modal-opacity-transition), transform var(--va-modal-transform-transition);\n}\n.va-modal__dialog {\n  min-height: var(--va-modal-dialog-min-height);\n  height: var(--va-modal-dialog-height);\n  border-radius: var(--va-modal-dialog-border-radius, var(--va-block-border-radius));\n  margin: var(--va-modal-dialog-margin);\n  box-shadow: var(--va-modal-dialog-box-shadow, var(--va-block-box-shadow));\n  max-width: var(--va-modal-dialog-max-width);\n  max-height: var(--va-modal-dialog-max-height);\n  position: var(--va-modal-dialog-position);\n  overflow: auto;\n}\n.va-modal__overlay {\n  position: var(--va-modal-overlay-position);\n  top: var(--va-modal-overlay-top);\n  left: var(--va-modal-overlay-left);\n  z-index: var(--va-modal-overlay-z-index);\n  width: var(--va-modal-overlay-width);\n  height: var(--va-modal-overlay-height);\n}\n.va-modal-enter-from .va-modal__overlay, .va-modal-leave-to .va-modal__overlay {\n  opacity: 0;\n}\n.va-modal-enter-active .va-modal__overlay, .va-modal-leave-active .va-modal_overlay {\n  transition: var(--va-modal-overlay-opacity-transition);\n}\n.va-modal--fullscreen {\n  min-width: 100vw !important;\n  min-height: 100vh !important;\n  border-radius: 0;\n  margin: 0;\n}\n@media all and (max-width: 576px) {\n.va-modal--mobile-fullscreen {\n    margin: 0 !important;\n    min-width: 100vw !important;\n    min-height: 100vh !important;\n    border-radius: 0;\n}\n}\n.va-modal--size-small {\n  max-width: 576px;\n}\n@media all and (max-width: 576px) {\n.va-modal--size-small {\n    max-width: 100vw !important;\n}\n}\n.va-modal--size-small .va-modal__inner {\n  max-width: 576px;\n}\n@media all and (max-width: 576px) {\n.va-modal--size-small .va-modal__inner {\n    max-width: 100vw !important;\n}\n}\n.va-modal--size-large {\n  max-width: 992px;\n}\n.va-modal--size-large .va-modal__inner {\n  max-width: 992px;\n}\n.va-modal--fixed-layout .va-modal__inner {\n  overflow: hidden;\n  padding: var(--va-modal-padding-top) 0 var(--va-modal-padding-bottom);\n  max-height: calc(100vh - 2rem);\n}\n.va-modal--fixed-layout .va-modal__inner .va-modal__header,\n.va-modal--fixed-layout .va-modal__inner .va-modal__footer,\n.va-modal--fixed-layout .va-modal__inner .va-modal__title {\n  padding: 0 var(--va-modal-padding-right) 0 var(--va-modal-padding-left);\n}\n.va-modal--fixed-layout .va-modal__inner .va-modal__message {\n  padding: 0 var(--va-modal-padding-right) 0 var(--va-modal-padding-left);\n  overflow: auto;\n}\n.va-modal--fixed-layout .va-modal__dialog {\n  overflow: hidden;\n}\n.va-modal--no-padding .va-modal__inner {\n  padding: 0;\n}\n.va-modal__message {\n  margin-bottom: 1.5rem;\n}\n.va-modal__inner {\n  overflow: visible;\n  display: flex;\n  position: relative;\n  flex-flow: column;\n  padding: var(--va-modal-padding);\n  max-width: 768px;\n  margin: auto;\n}\n.va-modal__inner > div:last-of-type {\n  margin-bottom: 0;\n}\n.va-modal__close {\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n  cursor: pointer;\n  font-size: 1.5rem;\n  font-style: normal;\n  color: var(--va-secondary);\n  z-index: 1;\n}\n.va-modal__default-cancel-button {\n  margin-right: 0.75rem;\n}\n.va-modal__footer {\n  margin-top: auto;\n  min-height: -moz-fit-content;\n  min-height: fit-content;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n}\n.va-modal__footer:last-of-type {\n  margin-bottom: 0;\n}";
var ModalElement = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a;
    return props.isTransition ? h(Transition, { ...attrs }, slots) : (_a = slots.default) == null ? void 0 : _a.call(slots, attrs);
  }
});
var _sfc_main5 = defineComponent({
  name: "VaModal",
  inheritAttrs: false,
  components: { VaButton: VaButton2, VaIcon: VaIcon2, ModalElement },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    allowBodyScroll: { type: Boolean, default: false },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "$t:ok" },
    cancelText: { type: String, default: "$t:cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false },
    beforeClose: { type: Function }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const modalDialog = shallowRef();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding,
      [`va-modal--size-${props.size}`]: props.size !== "medium"
    }));
    const computedModalContainerStyle = computed(() => ({ "z-index": props.zIndex }));
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayStyles = computed(() => {
      if (!props.overlay || !isLowestLevelModal.value) {
        return;
      }
      return {
        "background-color": `rgba(0, 0, 0, ${props.overlayOpacity})`,
        "z-index": props.zIndex && Number(props.zIndex) - 1
      };
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = (cb) => {
      const _hide = () => {
        valueComputed.value = false;
        cb == null ? void 0 : cb();
      };
      props.beforeClose ? props.beforeClose(_hide) : _hide();
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      hide(() => emit("cancel"));
    };
    const ok = () => {
      hide(() => emit("ok"));
    };
    const trapFocusInModal = () => {
      nextTick(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e) => {
      const hideModal = () => {
        if (e.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    useClickOutside([modalDialog], () => {
      if (!valueComputed.value || props.noOutsideDismiss || props.noDismiss || !isTopLevelModal.value) {
        return;
      }
      emit("click-outside");
      cancel();
    });
    const window3 = useWindow();
    watchEffect(() => {
      var _a, _b;
      if (valueComputed.value) {
        (_a = window3.value) == null ? void 0 : _a.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window3.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    useBlur(toRef(props, "blur"), valueComputed);
    const documentRef = useDocument();
    const setBodyOverflow = (overflow) => {
      if (!documentRef.value || props.allowBodyScroll) {
        return;
      }
      documentRef.value.body.style.overflow = overflow;
    };
    watch(valueComputed, (newValueComputed) => {
      if (newValueComputed) {
        registerModal();
        setBodyOverflow("scroll hidden");
        return;
      }
      if (isLowestLevelModal.value) {
        freeFocus();
        setBodyOverflow("");
      }
      unregisterModal();
    });
    watch(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    });
    onMounted(() => {
      if (valueComputed.value) {
        registerModal();
      }
    });
    const publicMethods = {
      ...useTranslation(),
      show,
      hide,
      toggle,
      cancel,
      ok,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    };
    return {
      getColor,
      rootElement,
      modalDialog,
      valueComputed,
      computedClass,
      computedDialogStyle,
      computedModalContainerStyle,
      computedOverlayStyles,
      ...publicMethods
    };
  }
});
var _hoisted_13 = ["aria-labelledby"];
var _hoisted_23 = {
  key: 0,
  class: "va-modal__anchor"
};
var _hoisted_32 = {
  key: 0,
  class: "va-modal"
};
var _hoisted_42 = { key: 0 };
var _hoisted_52 = {
  key: 1,
  class: "va-modal__header"
};
var _hoisted_62 = {
  key: 2,
  class: "va-modal__message"
};
var _hoisted_72 = {
  key: 3,
  class: "va-modal__message"
};
var _hoisted_8 = {
  key: 4,
  class: "va-modal__footer"
};
var _hoisted_9 = {
  key: 5,
  class: "va-modal__footer"
};
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_button = resolveComponent("va-button");
  const _component_modal_element = resolveComponent("modal-element");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass]),
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": _ctx.title
  }, [
    _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", _hoisted_23, [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ show: _ctx.show, hide: _ctx.hide, toggle: _ctx.toggle })))
    ])) : createCommentVNode("", true),
    (openBlock(), createBlock(Teleport, {
      to: _ctx.attachElement,
      disabled: _ctx.$props.disableAttachment
    }, [
      createVNode(_component_modal_element, mergeProps({
        name: "va-modal",
        isTransition: !_ctx.$props.withoutTransitions,
        appear: "",
        duration: 300
      }, _ctx.$attrs, {
        onBeforeEnter: _ctx.onBeforeEnterTransition,
        onAfterEnter: _ctx.onAfterEnterTransition,
        onBeforeLeave: _ctx.onBeforeLeaveTransition,
        onAfterLeave: _ctx.onAfterLeaveTransition
      }), {
        default: withCtx(() => [
          _ctx.valueComputed ? (openBlock(), createElementBlock("div", _hoisted_32, [
            _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-modal__overlay",
              style: normalizeStyle(_ctx.computedOverlayStyles)
            }, null, 4)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "va-modal__container",
              style: normalizeStyle(_ctx.computedModalContainerStyle)
            }, [
              createBaseVNode("div", {
                ref: "modalDialog",
                class: normalizeClass(["va-modal__dialog", _ctx.computedClass]),
                style: normalizeStyle(_ctx.computedDialogStyle)
              }, [
                _ctx.$props.fullscreen ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  name: "va-close",
                  class: "va-modal__close",
                  role: "button",
                  "aria-label": _ctx.t("close"),
                  tabindex: "0",
                  onClick: _ctx.cancel,
                  onKeydown: [
                    withKeys(_ctx.cancel, ["space"]),
                    withKeys(_ctx.cancel, ["enter"])
                  ]
                }, null, 8, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "va-modal__inner",
                  style: normalizeStyle({ maxWidth: _ctx.$props.maxWidth, maxHeight: _ctx.$props.maxHeight })
                }, [
                  _ctx.$slots.content ? (openBlock(), createElementBlock("div", _hoisted_42, [
                    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ cancel: _ctx.cancel, ok: _ctx.ok })))
                  ])) : createCommentVNode("", true),
                  !_ctx.$slots.content ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "va-modal__title",
                      style: normalizeStyle({ color: _ctx.getColor("primary") })
                    }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("", true),
                    _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_52, [
                      renderSlot(_ctx.$slots, "header")
                    ])) : createCommentVNode("", true),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_62, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_72, [
                      renderSlot(_ctx.$slots, "default")
                    ])) : createCommentVNode("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_8, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(_component_va_button, {
                        key: 0,
                        preset: "secondary",
                        color: "secondary",
                        class: "va-modal__default-cancel-button",
                        onClick: _ctx.cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.tp(_ctx.$props.cancelText)), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])) : createCommentVNode("", true),
                      createVNode(_component_va_button, { onClick: _ctx.ok }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.tp(_ctx.$props.okText)), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ])) : createCommentVNode("", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_9, [
                      renderSlot(_ctx.$slots, "footer")
                    ])) : createCommentVNode("", true)
                  ], 64)) : createCommentVNode("", true)
                ], 4)
              ], 6)
            ], 4)
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["isTransition", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])
    ], 8, ["to", "disabled"]))
  ], 10, _hoisted_13);
}
var _VaModal = _export_sfc(_sfc_main5, [["render", _sfc_render5], ["styles", [...VaButton2.styles || [], ...VaIcon2.styles || [], ...ModalElement.styles || [], _style_05]]]);
var VaModal = withConfigTransport(_VaModal);

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/modal.js
var getNodeProps2 = (vNode) => {
  var _a;
  return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props, appContext } = {}) => {
  var _a;
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props == null ? void 0 : props.onClose) == null ? void 0 : _a2.call(props, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props == null ? void 0 : props["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props, value);
    if ((props == null ? void 0 : props.withoutTransitions) && !value) {
      nextTick(() => {
        destroy2(el);
      });
    }
  };
  vNode = h(component, {
    ...props,
    stateful: (_a = props == null ? void 0 : props.stateful) != null ? _a : true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps2(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/plugin/index.js
var createVaModalPlugin = (app2) => ({
  init(options) {
    return createModalInstance(options, app2 == null ? void 0 : app2._context);
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaModal", createVaModalPlugin(app2));
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/utils/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app2, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app2.use(plugin(...options));
  } else {
    app2.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-fallback/VaFallback.js
var _sfc_main6 = defineComponent({
  name: "VaFallback",
  props: {
    fallbackSrc: {
      type: String
    },
    fallbackText: {
      type: String
    },
    fallbackIcon: {
      type: String
    },
    fallbackRender: {
      type: Function
    }
  },
  components: { VaIcon: VaIcon2 },
  emits: ["fallback"],
  setup(props, { emit }) {
    onMounted(() => {
      emit("fallback");
    });
    if (props.fallbackIcon) {
      return () => h(VaIcon2, {
        name: props.fallbackIcon
      });
    }
    if (props.fallbackSrc) {
      return () => h("img", {
        src: props.fallbackSrc
      });
    }
    if (props.fallbackRender) {
      return () => {
        var _a;
        return h((_a = props.fallbackRender) == null ? void 0 : _a.call(props));
      };
    }
    return () => h("span", props.fallbackText);
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-fallback/index.js
var VaFallback = withConfigTransport(_sfc_main6);

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/hooks/useAccordion.js
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props, state) => {
  let items2 = [];
  const onItemMounted = (item) => {
    items2.push(item);
  };
  const onItemUnmounted = (item) => {
    items2 = items2.filter((i) => i !== item);
  };
  const onItemChanged = (changedItem) => {
    state.value = items2.map((item) => {
      if (item === changedItem) {
        return item.state.value;
      }
      if (!props.multiple) {
        item.state.value = false;
      }
      return item.state.value;
    });
  };
  provide(AccordionServiceKey, {
    isInsideAccordion: true,
    onItemMounted,
    onItemUnmounted,
    onItemChanged,
    props: computed(() => props)
  });
  const updateItemStates = () => {
    items2.forEach((item, index) => {
      item.state.value = state.value[index];
    });
  };
  onMounted(updateItemStates);
  watch(state, updateItemStates);
  return { items: items2 };
};
var useAccordionItem = (state) => {
  const accordion = inject(AccordionServiceKey, {
    props: ref({ inset: void 0, popout: void 0 }),
    onItemChanged: () => void 0,
    onItemMounted: () => void 0,
    onItemUnmounted: () => void 0
  });
  const item = { state };
  onMounted(() => accordion.onItemMounted(item));
  onBeforeUnmount(() => accordion.onItemUnmounted(item));
  return {
    accordionProps: accordion.props,
    toggle: () => {
      state.value = !state.value;
      accordion.onItemChanged(item);
    }
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/VaAccordion.js
var _style_06 = ".va-accordion {\n  font-family: var(--va-font-family);\n}\n.va-accordion .va-collapse:not(:first-child, :last-child) .va-collapse__header {\n  border-radius: 0;\n}\n.va-accordion .va-collapse.va-collapse--expanded:last-child .va-collapse__header {\n  border-radius: 0;\n}\n.va-accordion .va-collapse:first-child .va-collapse__header {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.va-accordion .va-collapse:last-child .va-collapse__header {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}";
var _sfc_main7 = defineComponent({
  name: "VaAccordion",
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Array, default: () => [] },
    multiple: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    popout: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: [] });
    const { items: items2 } = useAccordion(props, valueComputed);
    return { collapses: items2, value: valueComputed };
  }
});
var _hoisted_14 = { class: "va-accordion" };
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_14, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaAccordion = _export_sfc(_sfc_main7, [["render", _sfc_render6], ["styles", [_style_06]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/index.js
var VaAccordion = withConfigTransport(_VaAccordion);

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/VaAffix-utils.js
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState({ coordinates: initialPosition, ...options }) : computeAffixedState({ coordinates, ...options });
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState({ ...nextState, width: coordinates.width });
  } else if (prevState.width !== coordinates.width) {
    setState({ ...prevState, width: coordinates.width });
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle_1((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear) => clear());
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/VaAffix.js
var _style_07 = ":root,\n:host {\n  --va-affix-affixed-z-index: 10;\n  --va-affix-affixed-position: fixed;\n}\n.va-affix {\n  font-family: var(--va-font-family);\n}\n.va-affix--affixed {\n  position: var(--va-affix-affixed-position);\n  z-index: var(--va-affix-affixed-z-index);\n}";
var _sfc_main8 = defineComponent({
  name: "VaAffix",
  emits: ["change"],
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  setup(props, { emit }) {
    const element = shallowRef();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props.offsetTop;
      }
      return props.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
      }
      return props.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop_1;
    onMounted(() => {
      var _a;
      initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return {
      computedClass,
      computedStyle,
      isAffixed,
      element
    };
  }
});
var _hoisted_15 = {
  ref: "element",
  class: "va-affix"
};
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_15, [
    createBaseVNode("div", {
      style: normalizeStyle({ visibility: _ctx.isAffixed ? "hidden" : "inherit" })
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.isAffixed ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.computedClass),
      style: normalizeStyle(_ctx.computedStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)) : createCommentVNode("", true)
  ], 512);
}
var _VaAffix = _export_sfc(_sfc_main8, [["render", _sfc_render7], ["styles", [_style_07]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/index.js
var VaAffix = withConfigTransport(_VaAffix);

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementBackground/useDomChangesObserver.js
var observer;
var callbacks = [];
var createMutationObserver = () => {
  if (!observer) {
    const runCallbacks = (mutations) => {
      const cache = /* @__PURE__ */ new Map();
      for (let i = 0; i < callbacks.length; i++) {
        if (mutations.some((m) => m.target.contains(callbacks[i].el.value || null))) {
          callbacks[i].cb(cache);
        }
      }
    };
    observer = new MutationObserver((mutations) => {
      runCallbacks(mutations);
    });
    observer.observe(document.documentElement, {
      attributeFilter: ["style", "class"],
      subtree: true,
      attributes: true
    });
  }
};
var destroyMutationObserver = () => {
  if (!observer) {
    return;
  }
  if (callbacks.length > 0) {
    return;
  }
  observer.disconnect();
  observer = null;
};
var useDomChangesObserver = (cb, el) => {
  onMounted(() => {
    createMutationObserver();
    callbacks.push({ cb, el });
  });
  onBeforeUnmount(() => {
    callbacks = callbacks.filter((c) => c.cb !== cb);
    destroyMutationObserver();
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementBackground/utils.js
var window2 = getWindow();
var getCSSVariableNameFromDeclaration = (color) => color.slice(4, -1);
var getElementBackgroundFromCSS = (el) => {
  const color = [...el.ownerDocument.styleSheets].filter((s) => {
    try {
      return s.cssRules;
    } catch {
      return false;
    }
  }).map((s) => [...s.cssRules || []]).flat().reduce((bg, cssRule) => {
    const { selectorText } = cssRule;
    try {
      if (!el.matches(selectorText)) {
        return bg;
      }
    } catch (error) {
      if (__DEV__) {
        console.warn(error, selectorText);
      }
    }
    if (cssRule instanceof CSSStyleRule) {
      return cssRule.style.background || cssRule.style.backgroundColor || bg;
    }
    return bg;
  }, "").trim();
  if (isCSSVariable(color)) {
    return window2 == null ? void 0 : window2.getComputedStyle(el).getPropertyValue(getCSSVariableNameFromDeclaration(color)).trim();
  }
  return color;
};
var EMPTY_TRANSITION = "all 0s ease 0s";
var getElementBackground = (element) => {
  const computedStyle = window2 == null ? void 0 : window2.getComputedStyle(element);
  if (!computedStyle) {
    return;
  }
  if (computedStyle.transition.trim() !== EMPTY_TRANSITION) {
    return getElementBackgroundFromCSS(element);
  }
  return computedStyle.backgroundColor;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useEl.js
var useEl = () => {
  const el = ref();
  const { proxy } = getCurrentInstance();
  onMounted(() => {
    el.value = proxy == null ? void 0 : proxy.$el;
  });
  onBeforeUnmount(() => {
    el.value = void 0;
  });
  return el;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementBackground/TempMap.js
var TempMap = class extends Map {
  constructor() {
    super(...arguments);
    this.timeoutId = -1;
  }
  set(key, value) {
    if (this.timeoutId === -1) {
      this.timeoutId = setTimeout(() => {
        super.clear();
      }, 300);
    }
    return super.set(key, value);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementBackground/useElementBackground.js
var isTransparent = (color) => color === "rgba(0, 0, 0, 0)";
var withCache = (cb) => {
  return (element, cache) => {
    if (!element) {
      return "#fff";
    }
    if (cache.has(element)) {
      return cache.get(element);
    }
    cache.set(element, cb(element, cache));
    return cache.get(element);
  };
};
var tempCache = new TempMap();
var useElementBackground = (element) => {
  const el = element || useEl();
  const { getColor } = useColors();
  const background = ref(getColor("background-primary"));
  const recursiveGetBackground = withCache((element2, cache) => {
    if (!element2) {
      return "#fff";
    }
    if (element2.nodeType !== Node.ELEMENT_NODE) {
      return recursiveGetBackground(element2.parentElement, cache);
    }
    const bg = getElementBackground(element2);
    if (!bg) {
      return recursiveGetBackground(element2.parentElement, cache);
    }
    if (isTransparent(bg)) {
      return recursiveGetBackground(element2.parentElement, cache);
    }
    return applyColors(recursiveGetBackground(element2.parentElement, cache), bg);
  });
  const updateBackground = (cache = tempCache) => {
    background.value = recursiveGetBackground(el.value, cache);
  };
  useDomChangesObserver(updateBackground, el);
  onMounted(updateBackground);
  return {
    background
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/useAlertStyles.js
var useAlertStyles = (props) => {
  const { getColor, getTextColor, getBoxShadowColorFromBg: getBoxShadowColorFromBg2 } = useColors();
  const { background } = useElementBackground();
  const isTransparentBackground = computed(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props.color));
  const alertStyle = computed(() => {
    let background2 = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background2 = "transparent";
    }
    if (props.border) {
      background2 = "var(--va-background-primary)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      backgroundColor: background2,
      boxShadow
    };
  });
  const contentStyle = computed(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border || props.outline ? getColor(getTextColor(background.value), void 0, true) : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/VaAlert.js
var _style_08 = ':root,\n:host {\n  /* General */\n  --va-alert-position: relative;\n  --va-alert-display: flex;\n  --va-alert-align-items: center;\n  --va-alert-margin-y: 0.25rem;\n  --va-alert-padding-x: 0.75rem;\n  --va-alert-padding-y: 0.75rem;\n  --va-alert-padding-y-dense: 0.25rem;\n  --va-alert-border-width: 0;\n  --va-alert-border-radius: 4px;\n  --va-alert-box-shadow: var(--va-box-shadow);\n  --va-alert-color: transparent;\n  --va-alert-title-font-weight: 600;\n  --va-alert-top-border-radius: 4px 4px 0 0;\n  --va-alert-right-border-radius: 0 4px 4px 0;\n  --va-alert-bottom-border-radius: 0 0 4px 4px;\n  --va-alert-left-border-radius: 4px 0 0 4px;\n  --va-badge-margin-right: 0.5rem;\n  --va-badge-padding-x: 0.5rem;\n  --va-badge-padding-y: 0.125rem;\n  --va-badge-border-radius: 0.5rem;\n  --va-badge-font-size: 0.625rem;\n  --va-badge-letter-spacing: 0.0625rem;\n  --va-alert-close-padding-x: 0.5rem;\n  --va-alert-close-padding-y: 0.0625rem;\n  --va-alert-close-font-size: 1rem;\n  --va-alert-stripe-border-size: var(--va-stripe-border-size);\n}\n.va-alert {\n  position: var(--va-alert-position);\n  padding: var(--va-alert-padding-y) var(--va-alert-padding-x);\n  margin: var(--va-alert-margin-y) auto;\n  display: var(--va-alert-display);\n  align-items: var(--va-alert-align-items);\n  border: var(--va-alert-border-width, var(--va-control-border)) solid transparent;\n  border-radius: var(--va-alert-border-radius, var(--va-block-border-radius));\n  font-family: var(--va-font-family);\n}\n.va-alert__border {\n  content: "";\n  position: absolute;\n}\n.va-alert__border--top {\n  border-radius: var(--va-alert-top-border-radius);\n  width: 100%;\n  height: var(--va-alert-stripe-border-size);\n  top: 0;\n  left: 0;\n}\n.va-alert__border--right {\n  border-radius: var(--va-alert-right-border-radius);\n  height: 100%;\n  width: var(--va-alert-stripe-border-size);\n  bottom: 0;\n  right: 0;\n}\n.va-alert__border--bottom {\n  border-radius: var(--va-alert-bottom-border-radius);\n  width: 100%;\n  height: var(--va-alert-stripe-border-size);\n  bottom: 0;\n  left: 0;\n}\n.va-alert__border--left {\n  border-radius: var(--va-alert-left-border-radius);\n  height: 100%;\n  width: var(--va-alert-stripe-border-size);\n  bottom: 0;\n  left: 0;\n}\n.va-alert__icon {\n  display: flex;\n  align-items: center;\n  padding-right: var(--va-alert-padding-x);\n}\n.va-alert__title {\n  display: flex;\n  align-items: center;\n}\n.va-alert__content {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  flex-grow: 1;\n  color: var(--va-alert-color);\n}\n.va-alert:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-alert__close {\n  padding-left: var(--va-alert-close-padding-x);\n  font-size: var(--va-alert-close-font-size);\n}\n.va-alert__close--closeable {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n.va-alert__close--closeable:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n@media (max-width: 575.98px) {\n.va-alert__content {\n    flex-direction: column;\n    align-items: flex-start;\n}\n.va-alert__close {\n    align-self: flex-start;\n    display: flex;\n    align-items: flex-start;\n    padding: 0 var(--va-alert-close-padding-x) 0 0;\n    margin: 0;\n}\n}';
var _sfc_main9 = defineComponent({
  name: "VaAlert",
  components: { VaIcon: VaIcon2 },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  },
  setup(props, { slots, emit }) {
    const alertStyles = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit);
    const hide = () => {
      valueComputed.value = false;
    };
    const hasIcon = computed(() => props.icon || slots.icon);
    const hasTitle = computed(() => props.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props.border}`);
    const closeIcon = computed(() => props.closeText || "close");
    const uniqueId2 = computed(generateUniqueId);
    const titleIdComputed = computed(() => `aria-title-${uniqueId2.value}`);
    const descriptionIdComputed = computed(() => `aria-description-${uniqueId2.value}`);
    return {
      ...useTranslation(),
      ...alertStyles,
      valueComputed,
      hasIcon,
      hasTitle,
      borderClass,
      closeIcon,
      hide,
      titleIdComputed,
      descriptionIdComputed
    };
  }
});
var _hoisted_16 = ["role", "aria-labelledby", "aria-describedby"];
var _hoisted_24 = ["id"];
var _hoisted_33 = ["id"];
var _hoisted_43 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_53 = ["aria-label"];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "fade"
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-alert",
        style: normalizeStyle(_ctx.alertStyle),
        role: _ctx.closeable ? "alertdialog" : "alert",
        "aria-labelledby": _ctx.titleIdComputed,
        "aria-describedby": _ctx.descriptionIdComputed
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.borderStyle),
          class: normalizeClass([_ctx.borderClass, "va-alert__border"])
        }, null, 6),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__icon",
          "aria-hidden": "true"
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, { name: _ctx.icon }, null, 8, ["name"])
          ])
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__content"
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle(_ctx.titleStyle),
            class: "va-alert__title",
            id: _ctx.titleIdComputed
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 12, _hoisted_24)) : createCommentVNode("", true),
          createBaseVNode("span", { id: _ctx.descriptionIdComputed }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.description), 1)
            ])
          ], 8, _hoisted_33)
        ], 4),
        _ctx.closeable ? (openBlock(), createElementBlock("div", _hoisted_43, [
          createBaseVNode("div", {
            role: "button",
            class: "va-alert__close--closeable",
            tabindex: "0",
            "aria-label": _ctx.closeText || _ctx.t("closeAlert"),
            style: normalizeStyle(_ctx.contentStyle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.hide && _ctx.hide(...args)),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys((...args) => _ctx.hide && _ctx.hide(...args), ["space"])),
              _cache[2] || (_cache[2] = withKeys((...args) => _ctx.hide && _ctx.hide(...args), ["enter"]))
            ]
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              !_ctx.closeText ? (openBlock(), createBlock(_component_va_icon, {
                key: 0,
                name: _ctx.closeIcon,
                size: "small"
              }, null, 8, ["name"])) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(_ctx.closeText), 1)
            ])
          ], 44, _hoisted_53)
        ])) : createCommentVNode("", true)
      ], 12, _hoisted_16)
    ]),
    _: 3
  })) : createCommentVNode("", true);
}
var _VaAlert = _export_sfc(_sfc_main9, [["render", _sfc_render8], ["styles", [...VaIcon2.styles || [], _style_08]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/index.js
var VaAlert = withConfigTransport(_VaAlert);

// node_modules/vuestic-ui/dist/web-components/src/composables/useFixedBar.js
var useFixedBarProps = {
  hideOnScroll: { type: Boolean, default: false },
  fixed: { type: Boolean, default: false },
  bottom: { type: Boolean, default: false }
};
function useFixedBar(props, isScrolledDown) {
  const isHiddenComputed = computed(() => isScrolledDown.value ? !!props.hideOnScroll : false);
  const transformComputed = computed(() => {
    if (!props.bottom && !isHiddenComputed.value) {
      return;
    }
    if (props.bottom && isHiddenComputed.value) {
      return "translateY(100%)";
    }
    if (props.bottom) {
      return props.fixed ? "translateY(-100%)" : "translateY(0)";
    }
    return "translateY(-100%)";
  });
  const positionComputed = computed(() => {
    if (props.fixed) {
      return "fixed";
    }
    return isHiddenComputed.value ? "absolute" : void 0;
  });
  const fixedBarStyleComputed = computed(() => {
    const result = {
      top: props.bottom && (isHiddenComputed.value || props.fixed) ? "100%" : void 0,
      transform: props.hideOnScroll || props.fixed ? transformComputed.value : void 0
    };
    positionComputed.value && Object.assign(result, { position: positionComputed.value });
    return result;
  });
  return { fixedBarStyleComputed };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useScroll.js
function getTargetElement(target) {
  if (!target) {
    throw new Error("No target was provided for `useScroll` hook!");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
  const scrollRoot = shallowRef();
  let targetElement;
  const isScrolledDown = ref(false);
  const prevScrollPosition = ref(0);
  const onScroll = (e) => {
    const target2 = e.target;
    const scrollValue = e.target instanceof Window ? target2.scrollY : target2.scrollTop;
    isScrolledDown.value = prevScrollPosition.value < scrollValue;
    prevScrollPosition.value = scrollValue;
  };
  onMounted(() => {
    targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScroll, fixed);
  });
  onBeforeUnmount(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScroll);
  });
  return { scrollRoot, isScrolledDown };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-app-bar/VaAppBar.js
var _style_09 = ":root,\n:host {\n  --va-app-bar-position: relative;\n  --va-app-bar-height: auto;\n  --va-app-bar-shadow: 0 0 12px 2px;\n  --va-app-bar-z-index: calc(var(--va-z-index-teleport-overlay) - 100);\n  --va-app-bar-transition: transform 0.5s ease;\n}\n.va-app-bar {\n  display: flex;\n  align-items: center;\n  position: var(--va-app-bar-position);\n  transition: all 0.5s ease;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--va-app-bar-height);\n  min-height: var(--va-app-bar-height);\n  min-width: 100%;\n  font-family: var(--va-font-family);\n  z-index: var(--va-app-bar-z-index);\n}\n.va-app-bar--bottom {\n  top: 100%;\n  transform: translateY(-100%);\n}";
var _sfc_main10 = defineComponent({
  name: "VaAppBar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    gradient: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: void 0 }
  },
  setup(props) {
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed, props.target);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, getGradientBackground: getGradientBackground2, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const showShadowComputed = computed(() => isScrolledDown.value ? !!props.shadowOnScroll : false);
    const shadowColorComputed = computed(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor2(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      background: props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value,
      boxShadow: computedShadow.value
    }));
    return { scrollRoot, computedStyle };
  }
});
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    role: "toolbar",
    class: "va-app-bar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaAppBar = _export_sfc(_sfc_main10, [["render", _sfc_render9], ["styles", [_style_09]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-app-bar/index.js
var VaAppBar = withConfigTransport(_VaAppBar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-aspect-ratio/VaAspectRatio.js
var _style_010 = ":root {\n  --va-aspect-ratio-position: relative;\n  --va-aspect-ratio-overflow: visible;\n}\n.va-aspect-ratio {\n  position: var(--va-aspect-ratio-position);\n  overflow: var(--va-aspect-ratio-overflow);\n  display: flex;\n  max-width: var(--5ab067ca);\n}";
var __default__2 = defineComponent({
  name: "VaAspectRatio",
  props: {
    ...useComponentPresetProp,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    contentHeight: { type: Number, default: 1 },
    contentWidth: { type: Number, default: 1 },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v) => v >= 0
    }
  },
  setup(props) {
    const aspectRatio = computed(() => {
      if (props.ratio === "auto" && props.contentHeight === 1 && props.contentWidth === 1) {
        return 0;
      }
      if (!isNaN(+props.ratio)) {
        return props.ratio;
      }
      return props.contentWidth / props.contentHeight;
    });
    const stylesComputed = computed(() => {
      if (!aspectRatio.value) {
        return;
      }
      return { paddingBottom: `${1 / aspectRatio.value * 100}%` };
    });
    const maxWidthComputed = computed(() => props.maxWidth ? `${props.maxWidth}px` : void 0);
    return { stylesComputed, maxWidthComputed };
  }
});
var __injectCSSVars__2 = () => {
  useCssVars((_ctx) => ({
    "5ab067ca": _ctx.maxWidthComputed
  }));
};
var __setup__2 = __default__2.setup;
__default__2.setup = __setup__2 ? (props, ctx) => {
  __injectCSSVars__2();
  return __setup__2(props, ctx);
} : __injectCSSVars__2;
var _sfc_main11 = __default__2;
var _hoisted_17 = { class: "va-aspect-ratio" };
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_17, [
    _ctx.stylesComputed ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.stylesComputed)
    }, null, 4)) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaAspectRatio = _export_sfc(_sfc_main11, [["render", _sfc_render10], ["styles", [_style_010]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-aspect-ratio/index.js
var VaAspectRatio = withConfigTransport(_VaAspectRatio);

// node_modules/vuestic-ui/dist/web-components/src/utils/component-options/resolve-component-props.js
function normalizeProps2(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps2(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps2(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m) => mergeProps2(to, m, optionsType));
  const props = normalizeProps2(from[optionsType]);
  for (const key in props) {
    to[key] = props[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  var _a, _b;
  const mixins = (_a = options.mixins) != null ? _a : [];
  const extendsOptions = (_b = options.extends) != null ? _b : [];
  const result = {};
  mergeProps2(result, extendsOptions, optionsType);
  for (let i = 0; i < mixins.length; i++) {
    mergeProps2(result, mixins[i], optionsType);
  }
  Object.assign(result, normalizeProps2(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};

// node_modules/vuestic-ui/dist/web-components/src/utils/component-options/extract-component-options.js
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/web-components/src/utils/component-options/filter-props.js
var filterComponentProps = (childProps) => {
  const { props } = getCurrentInstance();
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = props[propName];
      return acc;
    }, {});
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar/hooks/useAvatarProps.js
var useAvatarProps = {
  color: { type: String, default: "primary" },
  textColor: { type: String },
  square: { type: Boolean, default: false },
  fontSize: { type: String, default: "" }
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar/VaAvatar.js
var _style_011 = ":root,\n:host {\n  /* General */\n  --va-avatar-display: inline-flex;\n  --va-avatar-align-items: center;\n  --va-avatar-justify-content: center;\n  --va-avatar-text-align: center;\n  --va-avatar-vertical-align: middle;\n  --va-avatar-position: relative;\n  --va-avatar-line-height: normal;\n  --va-avatar-border-radius: 50%;\n}\n.va-avatar {\n  align-items: var(--va-avatar-align-items);\n  display: var(--va-avatar-display);\n  justify-content: var(--va-avatar-justify-content);\n  line-height: var(--va-avatar-line-height);\n  position: var(--va-avatar-position);\n  text-align: var(--va-avatar-text-align);\n  vertical-align: var(--va-avatar-vertical-align);\n  border-radius: var(--va-avatar-border-radius);\n  font-family: var(--va-font-family);\n  background-color: var(--21bd320a);\n  color: var(--708bde6b);\n  width: var(--71f30a26);\n  min-width: var(--71f30a26);\n  height: var(--71f30a26);\n}\n.va-avatar img,\n.va-avatar svg {\n  border-radius: inherit;\n  display: inline-flex;\n  height: inherit;\n  width: inherit;\n  margin: auto;\n}";
var VaFallbackProps = extractComponentProps(VaFallback);
var __default__3 = defineComponent({
  name: "VaAvatar",
  components: { VaIcon: VaIcon2, VaProgressCircle, VaFallback },
  props: {
    ...useLoadingProps,
    ...useSizeProps,
    ...useComponentPresetProp,
    ...useAvatarProps,
    ...VaFallbackProps,
    src: { type: String, default: null },
    icon: { type: String, default: "" },
    alt: { type: String, default: "" }
  },
  emits: ["error", "fallback"],
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const backgroundColorComputed = computed(() => {
      if (props.loading || props.src && !hasLoadError.value) {
        return "transparent";
      }
      return colorComputed.value;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => ({
      borderRadius: props.square ? 0 : "",
      fontSize: props.fontSize || fontSizeComputed.value
    }));
    const hasLoadError = ref(false);
    const onLoadError = (event) => {
      hasLoadError.value = true;
      emit("error", event);
    };
    watch(() => props.src, () => {
      hasLoadError.value = false;
    });
    const avatarOptions = computed(() => ({
      hasError: hasLoadError.value,
      onError: onLoadError
    }));
    return {
      hasLoadError,
      sizeComputed,
      avatarOptions,
      computedStyle,
      colorComputed,
      textColorComputed,
      backgroundColorComputed,
      VaFallbackProps: filterComponentProps(VaFallbackProps),
      onLoadError
    };
  }
});
var __injectCSSVars__3 = () => {
  useCssVars((_ctx) => ({
    "21bd320a": _ctx.backgroundColorComputed,
    "708bde6b": _ctx.textColorComputed,
    "71f30a26": _ctx.sizeComputed
  }));
};
var __setup__3 = __default__3.setup;
__default__3.setup = __setup__3 ? (props, ctx) => {
  __injectCSSVars__3();
  return __setup__3(props, ctx);
} : __injectCSSVars__3;
var _sfc_main12 = __default__3;
var _hoisted_18 = ["aria-hidden"];
var _hoisted_25 = ["src", "alt"];
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_va_fallback = resolveComponent("va-fallback");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: "va-avatar",
    style: normalizeStyle(_ctx.computedStyle),
    "aria-hidden": !_ctx.$props.src,
    "aria-live": "polite"
  }, [
    _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
      key: 0,
      size: _ctx.sizeComputed,
      color: _ctx.colorComputed,
      indeterminate: ""
    }, null, 8, ["size", "color"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, _ctx.avatarOptions)), () => [
      _ctx.$props.src && !_ctx.hasLoadError ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        onError: _cache[0] || (_cache[0] = (...args) => _ctx.onLoadError && _ctx.onLoadError(...args))
      }, null, 40, _hoisted_25)) : _ctx.hasLoadError && _ctx.$props.src ? renderSlot(_ctx.$slots, "fallback", { key: 1 }, () => [
        createVNode(_component_va_fallback, mergeProps(_ctx.VaFallbackProps, {
          onFallback: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("fallback"))
        }), null, 16)
      ]) : _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 2,
        name: _ctx.$props.icon
      }, null, 8, ["name"])) : createCommentVNode("", true)
    ])
  ], 12, _hoisted_18);
}
var _VaAvatar = _export_sfc(_sfc_main12, [["render", _sfc_render11], ["styles", [...VaIcon2.styles || [], ...VaProgressCircle.styles || [], ...VaFallback.styles || [], _style_011]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar/index.js
var VaAvatar = withConfigTransport(_VaAvatar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar-group/VaAvatarGroup.js
var _style_012 = ":root {\n  --va-avatar-group-gap: -1rem;\n}\n.va-avatar-group {\n  display: flex;\n  flex-wrap: nowrap;\n}\n.va-avatar-group .va-avatar + .va-avatar {\n  margin-left: var(--va-avatar-group-gap);\n}\n.va-avatar-group--vertical {\n  flex-direction: column;\n}\n.va-avatar-group--vertical .va-avatar + .va-avatar {\n  margin-left: 0;\n  margin-top: var(--va-avatar-group-gap);\n}";
var _sfc_main13 = defineComponent({
  name: "VaAvatarGroup",
  components: {
    VaAvatar
  },
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    ...useAvatarProps,
    max: {
      type: Number,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    options: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const classComputed = useBem("va-avatar-group", () => ({
      ...pick_1(props, ["vertical"])
    }));
    const maxOptions = computed(() => props.options.slice(0, props.max));
    const visibleItemsCount = computed(() => props.max ? props.max + 1 : 1);
    const restOptionsCount = computed(() => props.options.length - (props.max || 0));
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatarGroup");
    const avatarProps = computed(() => ({
      ...props,
      fontSize: fontSizeComputed.value,
      size: sizeComputed.value
    }));
    return {
      classComputed,
      maxOptions,
      visibleItemsCount,
      restOptionsCount,
      avatarProps
    };
  }
});
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_avatar = resolveComponent("va-avatar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-avatar-group", _ctx.classComputed]),
    role: "group"
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.maxOptions, (option, idx) => {
      return openBlock(), createBlock(_component_va_avatar, mergeProps({ key: idx }, { ..._ctx.avatarProps, ...option }, {
        role: "listitem",
        tabindex: "0"
      }), null, 16);
    }), 128)),
    renderSlot(_ctx.$slots, "rest", normalizeProps(guardReactiveProps(_ctx.avatarProps)), () => [
      createVNode(_component_va_avatar, mergeProps({ color: "secondary" }, _ctx.avatarProps, { role: "listitem" }), {
        default: withCtx(() => [
          createTextVNode(" +" + toDisplayString(_ctx.restOptionsCount), 1)
        ]),
        _: 1
      }, 16)
    ])
  ], 2);
}
var _VaAvatarGroup = _export_sfc(_sfc_main13, [["render", _sfc_render12], ["styles", [...VaAvatar.styles || [], _style_012]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar-group/index.js
var VaAvatarGroup = withConfigTransport(_VaAvatarGroup);

// node_modules/vuestic-ui/dist/web-components/src/components/va-backtop/VaBacktop.js
var _style_013 = ":root,\n:host {\n  --va-backtop-position: fixed;\n  --va-backtop-top: auto;\n  --va-backtop-left: auto;\n  --va-backtop-right: auto;\n  --va-backtop-bottom: auto;\n  --va-backtop-cursor: pointer;\n  --va-backtop-z-index: 3;\n}\n.va-backtop {\n  position: var(--va-backtop-position);\n  top: var(--va-backtop-top);\n  left: var(--va-backtop-left);\n  right: var(--va-backtop-right);\n  bottom: var(--va-backtop-bottom);\n  cursor: var(--va-backtop-cursor);\n  z-index: var(--va-backtop-z-index);\n  font-family: var(--va-font-family);\n}";
var _sfc_main14 = defineComponent({
  name: "VaBacktop",
  components: { VaButton: VaButton2 },
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    }
  },
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > props.visibilityHeight;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement2();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    return {
      computedStyle,
      visible,
      scrollToTop,
      ...useTranslation()
    };
  }
});
var _hoisted_19 = ["aria-label"];
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": _ctx.t("backToTop"),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "va-arrow-up",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 44, _hoisted_19)) : createCommentVNode("", true);
}
var _VaBacktop = _export_sfc(_sfc_main14, [["render", _sfc_render13], ["styles", [...VaButton2.styles || [], _style_013]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-backtop/index.js
var VaBacktop = withConfigTransport(_VaBacktop);

// node_modules/vuestic-ui/dist/web-components/src/composables/usePlacementAliases.js
var verticalPlacement = ["top", "bottom"];
var horizontalPlacement = ["left", "right"];
var placementPosition = [...verticalPlacement, ...horizontalPlacement];
var placementAlignment = ["start", "end", "center"];
var placementsPositions = placementPosition.reduce((acc, position) => {
  acc.push(position);
  placementAlignment.forEach((alignment) => acc.push(`${position}-${alignment}`));
  return acc;
}, ["auto"]);
var placementAliasesPositions = verticalPlacement.reduce((acc, yPosition) => {
  horizontalPlacement.forEach((xPosition) => {
    acc.push(`${yPosition}-${xPosition}`);
    acc.push(`${xPosition}-${yPosition}`);
  });
  return acc;
}, []);
var placementsPositionsWithAliases = [...placementsPositions, ...placementAliasesPositions];
var aliasToPlacement = {
  "top-left": "top-start",
  "left-top": "top-start",
  "top-right": "top-end",
  "right-top": "top-end",
  "bottom-left": "bottom-start",
  "left-bottom": "bottom-start",
  "bottom-right": "bottom-end",
  "right-bottom": "bottom-end"
};
var usePlacementAliasesProps = {
  placement: {
    type: String,
    default: "auto",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  }
};
var usePlacementAliases = (props) => {
  const placementArray = computed(() => {
    const placement = aliasToPlacement[props.placement] || props.placement;
    return placement.split("-");
  });
  const position = computed(() => {
    const position2 = placementArray.value[0];
    return position2 === "auto" ? "bottom" : position2;
  });
  const align = computed(() => {
    return placementArray.value[1] || "center";
  });
  return { position, align };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useParsableMeasure.js
var useParsableMeasure = () => {
  const isParsableMeasure2 = (value) => {
    if (typeof value === "string") {
      return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
    }
    return false;
  };
  const isParsablePositiveMeasure2 = (value) => {
    if (typeof value === "number") {
      return value >= 0;
    }
    return isParsableMeasure2(value) && parseInt(value) >= 0;
  };
  const parseSizeValue3 = (value, pageFontSize = 16) => {
    const valueUnref = unref(value);
    if (typeof valueUnref === "string") {
      const parsedValue = parseInt(valueUnref);
      if (isNaN(parsedValue)) {
        return 0;
      }
      return valueUnref.endsWith("rem") ? parsedValue * unref(pageFontSize) : parsedValue;
    }
    return valueUnref;
  };
  return { isParsableMeasure: isParsableMeasure2, isParsablePositiveMeasure: isParsablePositiveMeasure2, parseSizeValue: parseSizeValue3 };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/hooks/useFloatingPositionStyles.js
var { isParsableMeasure, parseSizeValue } = useParsableMeasure();
var useFloatingPositionProps = {
  overlap: { type: Boolean, default: false },
  placement: {
    type: String,
    default: "top-end",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  },
  offset: {
    type: [Number, String],
    default: 0,
    validator: (value) => {
      if (typeof value === "string") {
        return isParsableMeasure(value);
      }
      return !isNaN(value);
    }
  }
};
var useFloatingPosition = (props, floating) => {
  if (!floating.value) {
    return {};
  }
  const { position, align } = usePlacementAliases(props);
  const centerAlignment = computed(() => align.value === "center" ? "-50%" : "0%");
  const transformComputed = computed(() => {
    const options = {
      top: { transform: `translateX(${centerAlignment.value}) translateY(-100%)` },
      bottom: { transform: "translateX(0) translateY(100%)" },
      left: { transform: "translateX(-100%) translateY(-50%)" },
      right: { transform: `translateX(100%) translateY(${centerAlignment.value})` }
    };
    return options[position.value];
  });
  const getOverlapMargin = computed(() => {
    var _a;
    if (!props.overlap) {
      return {};
    }
    const result = { [`margin-${position.value}`]: "var(--va-badge-overlap)" };
    const alignComplianceTable = {
      top: { end: "left", multiplier: -1 },
      bottom: { start: "left", multiplier: 1 }
    };
    const alignComplianceValue = (_a = alignComplianceTable[position.value]) == null ? void 0 : _a[align.value];
    if (alignComplianceValue) {
      Object.assign(result, {
        [`margin-${alignComplianceValue}`]: `calc(${alignComplianceTable[position.value].multiplier} * var(--va-badge-overlap))`
      });
    }
    return result;
  });
  const getAlignment = computed(() => {
    const baseSide = ["left", "right"].includes(position.value) ? "top" : "left";
    const alignmentOptions = { start: { [baseSide]: 0 }, center: { [baseSide]: "50%" }, end: { [baseSide]: "100%" } };
    return alignmentOptions[align.value];
  });
  const offset = toRef(props, "offset");
  return computed(() => ({
    [position.value]: `${parseSizeValue(offset)}px`,
    ...transformComputed.value,
    ...getAlignment.value,
    ...getOverlapMargin.value
  }));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/VaBadge.js
var _style_014 = ":root,\n:host {\n  /* General */\n  --va-badge-py: 0;\n  --va-badge-font-size: 0.625rem;\n  --va-badge-border: 0.125rem;\n  --va-badge-size: calc(var(--va-badge-font-size) * var(--va-badge-line-height) + var(--va-badge-border) * 2);\n  --va-badge-overlap: calc(var(--va-badge-size) / 3);\n  --va-badge-line-height: 1.4;\n  --va-badge-margin: 0;\n  --va-badge-width: fit-content;\n  /* Dot */\n  --va-badge-dot-size: 0.5rem;\n  /* Text wrapper */\n  --va-badge-text-wrapper-transition: 0.2s cubic-bezier(0.4, 0, 0.6, 1);\n  --va-badge-text-wrapper-display: inline-flex;\n  --va-badge-text-wrapper-border: solid 0.125rem;\n  --va-badge-text-wrapper-border-radius: 0.125rem;\n  --va-badge-text-wrapper-font-weight: 700;\n  --va-badge-text-wrapper-line-height: 1.4;\n  --va-badge-text-wrapper-letter-spacing: 0.0375rem;\n  --va-badge-text-wrapper-justify-content: center;\n  --va-badge-text-wrapper-white-space: nowrap;\n  --va-badge-text-wrapper-width: min-content;\n  --va-badge-text-wrapper-height: auto;\n  --va-badge-text-wrapper-min-width: initial;\n  --va-badge-text-wrapper-min-height: initial;\n  --va-badge-text-wrapper-margin: 0;\n  --va-badge-text-transform: uppercase;\n  /* Text */\n  --va-badge-text-py: 0;\n  --va-badge-text-px: 0.25rem;\n}\n.va-badge {\n  display: inline-flex;\n  position: relative;\n  font-family: var(--va-font-family);\n  width: var(--va-badge-width);\n}\n.va-badge__text-wrapper {\n  transition: var(--va-badge-text-wrapper-transition, var(--va-transition));\n  display: var(--va-badge-text-wrapper-display);\n  border: var(--va-badge-text-wrapper-border, var(--va-control-border));\n  border-radius: var(--va-badge-text-wrapper-border-radius);\n  font-weight: var(--va-badge-text-wrapper-font-weight);\n  line-height: var(--va-badge-text-wrapper-line-height);\n  letter-spacing: var(--va-badge-text-wrapper-letter-spacing, var(--va-letter-spacing));\n  justify-content: var(--va-badge-text-wrapper-justify-content);\n  white-space: var(--va-badge-text-wrapper-white-space);\n  width: var(--va-badge-text-wrapper-width);\n  height: var(--va-badge-text-wrapper-height);\n  min-width: var(--va-badge-text-wrapper-min-width);\n  min-height: var(--va-badge-text-wrapper-min-height);\n  margin: var(--va-badge-text-wrapper-margin);\n}\n.va-badge--visible-empty .va-badge__text-wrapper {\n  min-width: var(--va-badge-size);\n  min-height: var(--va-badge-size);\n}\n.va-badge--dot .va-badge__text-wrapper {\n  min-width: var(--va-badge-dot-size);\n  min-height: var(--va-badge-dot-size);\n  border-width: 0;\n  border-radius: 100%;\n  padding: 0;\n}\n.va-badge--empty .va-badge__text-wrapper {\n  width: 0;\n  height: 0;\n  min-width: 0;\n  min-height: 0;\n  border-width: 0;\n}\n.va-badge--multi-line .va-badge__text-wrapper {\n  white-space: normal;\n}\n.va-badge--floating .va-badge__text-wrapper {\n  position: absolute;\n  z-index: 2;\n}\n.va-badge__text {\n  margin: var(--va-badge-margin);\n  text-transform: var(--va-badge-text-transform);\n  overflow: hidden;\n  min-width: calc(var(--va-badge-font-size) * var(--va-badge-line-height));\n  padding: var(--va-badge-text-py) var(--va-badge-text-px);\n  text-align: center;\n  display: inline-flex;\n  justify-content: center;\n  text-overflow: clip;\n  white-space: nowrap;\n  font-size: var(--va-badge-font-size);\n}\n.va-badge--multi-line .va-badge__text {\n  overflow: auto;\n  max-height: initial;\n  text-align: initial;\n  text-overflow: initial;\n  white-space: normal;\n}\n.va-badge--dot .va-badge__text {\n  display: none;\n}\n.va-badge--floating .va-badge__text {\n  align-items: center;\n  padding: var(--va-badge-py) 0.15rem;\n}";
var _sfc_main15 = defineComponent({
  name: "VaBadge",
  props: {
    ...useComponentPresetProp,
    ...useFloatingPositionProps,
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    transparent: { type: Boolean, default: false }
  },
  setup(props, { slots }) {
    const isEmpty = computed(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed(() => !!(slots.default || props.dot));
    const badgeClass = useBem("va-badge", () => ({
      ...pick_1(props, ["visibleEmpty", "dot", "multiLine"]),
      empty: isEmpty.value,
      floating: isFloating.value
    }));
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const positionStylesComputed = useFloatingPosition(props, isFloating);
    const stylesComputed = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1,
      ...unref(positionStylesComputed)
    }));
    return { badgeClass, stylesComputed };
  }
});
var _hoisted_110 = { class: "va-badge__text" };
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-badge", _ctx.badgeClass]),
    role: "alert"
  }, [
    createBaseVNode("span", {
      class: "va-badge__text-wrapper",
      style: normalizeStyle(_ctx.stylesComputed)
    }, [
      createBaseVNode("span", _hoisted_110, [
        renderSlot(_ctx.$slots, "text", {}, () => [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ])
      ])
    ], 4),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaBadge = _export_sfc(_sfc_main15, [["render", _sfc_render14], ["styles", [_style_014]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/index.js
var VaBadge = withConfigTransport(_VaBadge);

// node_modules/vuestic-ui/dist/web-components/src/composables/useAlign.js
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/web-components/src/utils/has-own-property.js
var hasOwnProperty2 = (object, key) => {
  return Object.prototype.hasOwnProperty.call(object, key);
};

// node_modules/vuestic-ui/dist/web-components/src/utils/resolveSlot.js
var resolveSlot = (slot) => {
  return slot && isFunction_1(slot) ? slot() : slot;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/VaBreadcrumbs.js
var _style_015 = ":root,\n:host {\n  /* General */\n  --va-breadcrumbs-display: flex;\n  --va-breadcrumbs-width: 100%;\n  --va-breadcrumbs-justify-content: center;\n  /* Item */\n  --va-breadcrumbs-item-display: inline-flex;\n  /* Separator */\n  --va-breadcrumbs-separator-padding: var(--va-breadcrumbs-separator-py) var(--va-breadcrumbs-separator-px);\n  --va-breadcrumbs-separator-py: 0;\n  --va-breadcrumbs-separator-px: 0.5rem;\n  --va-breadcrumbs-separator-display: inline-flex;\n}\n.va-breadcrumbs {\n  display: var(--va-breadcrumbs-display);\n  width: var(--va-breadcrumbs-width);\n  justify-content: var(--va-breadcrumbs-justify-content);\n  font-family: var(--va-font-family);\n}\n.va-breadcrumbs__item {\n  display: var(--va-breadcrumbs-item-display);\n}\n.va-breadcrumbs__separator {\n  padding: var(--va-breadcrumbs-separator-padding);\n  display: var(--va-breadcrumbs-separator-display);\n}";
var _sfc_main16 = defineComponent({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp,
    separator: { type: String, default: "/" },
    color: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null }
  },
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : getColor(props.color);
    });
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : getColor(props.color);
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a, _b;
          return !!((_b = (_a = node2 == null ? void 0 : node2.type) == null ? void 0 : _a.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = resolveSlot(slots.separator) || [props.separator];
      return h("span", {
        "aria-hidden": true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty2(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      const defaultSlotContent = resolveSlot(slots.default);
      if (!defaultSlotContent) {
        return;
      }
      const childNodes = defaultSlotContent.reduce(childNodeFilter, []) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty2(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h(
        "span",
        {
          class: "va-breadcrumbs__item",
          "aria-current": isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
          style: {
            color: !isLastIndexChildNodes(index) && !isDisabledChild(child) ? computedThemesActiveColor.value : null
          }
        },
        [child]
      );
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { t } = useTranslation();
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      "aria-label": isAllChildLinks.value ? t("breadcrumbs") : void 0
    }, getChildren());
  }
});
var _VaBreadcrumbs = _export_sfc(_sfc_main16, [["styles", [_style_015]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.js
var _style_016 = ":root,\n:host {\n  /* General */\n  --va-breadcrumb-item-display: inline-flex;\n  --va-breadcrumb-item-color: inherit;\n  /* Hovered */\n  --va-breadcrumb-item-hover-opacity: 0.7;\n  /* Focused */\n  --va-breadcrumb-item-focus-text-decoration: underline;\n}\n.va-breadcrumb-item {\n  display: var(--va-breadcrumb-item-display);\n  color: var(--va-breadcrumb-item-color);\n}\n.va-breadcrumb-item--link {\n  color: inherit;\n}\n.va-breadcrumb-item--link:hover {\n  opacity: var(--va-breadcrumb-item-hover-opacity);\n}\n.va-breadcrumb-item--link:focus {\n  -webkit-text-decoration: var(--va-breadcrumb-item-focus-text-decoration);\n          text-decoration: var(--va-breadcrumb-item-focus-text-decoration);\n}";
var _sfc_main17 = defineComponent({
  name: "VaBreadcrumbsItem",
  props: {
    ...useRouterLinkProps,
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  },
  setup: (props) => {
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return { tagComputed, hrefComputed, classComputed };
  }
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-breadcrumb-item", _ctx.classComputed]),
    "active-class": _ctx.$props.activeClass,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to,
    target: _ctx.$props.target,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ]),
    _: 3
  }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
}
var _VaBreadcrumbsItem = _export_sfc(_sfc_main17, [["render", _sfc_render15], ["styles", [_style_016]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/index.js
var VaBreadcrumbsItem = withConfigTransport(_VaBreadcrumbsItem);
var VaBreadcrumbs = withConfigTransport(_VaBreadcrumbs);

// node_modules/vuestic-ui/dist/web-components/src/composables/useEmitProxy.js
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [eventToListenerName(getEvent(key))]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [getEvent(key)]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-config/VaConfig.js
var _sfc_main18 = defineComponent({
  name: "VaConfig",
  props: {
    ...useComponentPresetProp,
    components: { type: Object, default: () => ({}) }
  },
  setup(props) {
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, props.components]);
    provideLocalConfig(nextChain);
    return {};
  }
});
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var VaConfig = _export_sfc(_sfc_main18, [["render", _sfc_render16]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-group/VaButtonGroup.js
var _style_017 = ':root,\n:host {\n  --va-button-group-display: flex;\n  --va-button-group-justify-content: stretch;\n  --va-button-group-border-radius: 999px;\n  --va-button-group-gap: 0.25rem;\n  /* Button */\n  --va-button-group-button-margin: 0;\n  --va-button-group-button-width: auto;\n  --va-button-group-button-padding: 0.25rem;\n}\n.va-button-group {\n  display: var(--va-button-group-display);\n  justify-content: var(--va-button-group-justify-content);\n  border-radius: var(--va-button-group-border-radius);\n  font-family: var(--va-font-family);\n  width: -moz-max-content;\n  width: max-content;\n}\n.va-button-group--grow {\n  width: 100%;\n  --va-button-group-button-width: 100%;\n}\n.va-button-group--square {\n  border-radius: var(--va-button-border-radius);\n}\n.va-button-group--small.va-button-group--square {\n  border-radius: var(--va-button-sm-border-radius);\n}\n.va-button-group--large.va-button-group--square {\n  border-radius: var(--va-button-lg-border-radius);\n}\n.va-button-group .va-button {\n  margin: var(--va-button-group-button-margin);\n  width: var(--va-button-group-button-width);\n  box-shadow: none;\n  outline: none;\n}\n.va-button-group .va-button:focus-visible {\n  outline: none !important;\n}\n.va-button-group .va-button:focus-visible::before {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}\n.va-button-group > .va-button:last-child {\n  padding-right: var(--va-button-group-button-padding);\n}\n.va-button-group > .va-button:first-child {\n  padding-left: var(--va-button-group-button-padding);\n}\n.va-button-group > .va-button:not(:last-child) {\n  padding-right: var(--va-button-group-gap);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right: 0;\n}\n.va-button-group > .va-button:not(:last-child) .va-button__content {\n  margin-right: 0;\n}\n.va-button-group > .va-button + .va-button {\n  padding-left: var(--va-button-group-gap);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-left: 0;\n}\n.va-button-group > .va-button + .va-button .va-button__content {\n  margin-left: 0;\n}';
var VaButtonProps = omit_1(extractComponentProps(VaButton2), ["block"]);
var _sfc_main19 = defineComponent({
  name: "VaButtonGroup",
  components: { VaConfig },
  props: {
    ...VaButtonProps,
    ...useComponentPresetProp,
    grow: {
      type: Boolean,
      default: false
    }
  },
  setup: (props) => {
    const buttonConfig = computed(() => ({ VaButton: { ...props } }));
    const computedClass = useBem("va-button-group", () => ({
      square: !props.round,
      grow: props.grow,
      small: props.size === "small",
      large: props.size === "large"
    }));
    return { buttonConfig, computedClass };
  }
});
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-group", _ctx.computedClass])
  }, [
    createVNode(_component_va_config, { components: _ctx.buttonConfig }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["components"])
  ], 2);
}
var _VaButtonGroup = _export_sfc(_sfc_main19, [["render", _sfc_render17], ["styles", [...VaConfig.styles || [], _style_017]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-group/index.js
var VaButtonGroup = withConfigTransport(_VaButtonGroup);

// node_modules/vuestic-ui/dist/web-components/src/composables/useDebounce.js
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce_1(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};

// node_modules/vuestic-ui/dist/web-components/src/utils/map-object.js
var mapObject = (o, cb) => {
  const copy = {};
  Object.keys(o).forEach((key) => {
    copy[key] = cb(o[key], key);
  });
  return copy;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useRequestAnimationFrame.js
var useRequestAnimationFrame = (cb) => {
  let animationFrameRequest = -1;
  const observe = () => {
    animationFrameRequest = requestAnimationFrame(observe);
    cb();
  };
  onMounted(() => {
    observe();
  });
  onBeforeUnmount(() => {
    cancelAnimationFrame(animationFrameRequest);
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useDomRect.js
var keys2 = ["x", "y", "width", "height", "top", "left", "right", "bottom"];
var isDomRectEqual = (a, b) => {
  for (let i = 0; i < keys2.length; i++) {
    if (a[keys2[i]] !== b[keys2[i]]) {
      return false;
    }
  }
  return true;
};
var useDomRect = (target) => {
  const domRect = ref(null);
  let prev = {};
  useRequestAnimationFrame(() => {
    if (!target.value) {
      return;
    }
    const rect = target.value.getBoundingClientRect();
    if (!isDomRectEqual(rect, prev)) {
      domRect.value = rect;
    }
    prev = rect;
  });
  watch(target, (newVal) => {
    if (newVal) {
      domRect.value = newVal.getBoundingClientRect();
    } else {
      domRect.value = null;
    }
  });
  return {
    domRect
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useDropdown.js
var coordsToCss = ({ x, y }) => ({ left: `${x}px`, top: `${y}px` });
var parseOffset = (offset) => {
  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
var calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
  if (align === "start") {
    return anchorStart;
  }
  if (align === "end") {
    return anchorStart + anchorSize - contentSize;
  }
  return anchorStart + (anchorSize - contentSize) / 2;
};
var calculateContentCoords = (position, align, anchor, content) => {
  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
  switch (position) {
    case "top":
      return { x: alignmentX, y: anchor.top - content.height };
    case "left":
      return { y: alignmentY, x: anchor.left - content.width };
    case "right":
      return { y: alignmentY, x: anchor.right };
    case "bottom":
    default:
      return { x: alignmentX, y: anchor.bottom };
  }
};
var calculateOffsetCoords = (position, offset) => {
  const { main, cross } = parseOffset(offset);
  switch (position) {
    case "left":
      return { y: cross, x: -main };
    case "right":
      return { y: cross, x: main };
    case "top":
      return { y: -main, x: cross };
    case "bottom":
    default:
      return { y: main, x: cross };
  }
};
var calculateContentOverflow = (coords, content, viewport) => {
  const xMax = viewport.right;
  const yMax = viewport.bottom;
  const xMin = viewport.left;
  const yMin = viewport.top;
  return {
    top: Math.max(yMin - coords.y, 0),
    bottom: Math.max(coords.y + content.height - yMax, 0),
    left: Math.max(xMin - coords.x, 0),
    right: Math.max(coords.x + content.width - xMax, 0)
  };
};
var clamp2 = (min, v, max) => Math.max(Math.min(v, max), min);
var calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {
  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport);
  const x = coords.x - right + left;
  const y = coords.y - bottom + top;
  const { x: offsetX, y: offsetY } = offsetCoords;
  return {
    x: clamp2(anchor.left + offsetX - content.width, x, anchor.right + offsetX),
    y: clamp2(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY)
  };
};
var getAutoPlacement = (position, align, coords, content, viewport) => {
  const overflow = calculateContentOverflow(coords, content, viewport);
  const convertPlacement = (position2, align2) => ({ position: position2, align: align2 });
  const newPlacements = {
    top: "bottom",
    bottom: "top",
    right: "left",
    left: "right"
  };
  if (!overflow[position]) {
    return convertPlacement(position, align);
  }
  const newPlacement = newPlacements[position];
  if (newPlacement === "bottom" || newPlacement === "top") {
    if (overflow.left) {
      return convertPlacement(newPlacement, "start");
    }
    if (overflow.right) {
      return convertPlacement(newPlacement, "end");
    }
  }
  if (newPlacement === "left" || newPlacement === "right") {
    if (overflow.top) {
      return convertPlacement(newPlacement, "start");
    }
    if (overflow.bottom) {
      return convertPlacement(newPlacement, "end");
    }
  }
  return convertPlacement(newPlacement, "center");
};
var findFirstRelativeParent = (el) => {
  while (el) {
    const positionValue = window.getComputedStyle(el).getPropertyValue("position") || el.style.position;
    if (positionValue === "relative") {
      return el;
    }
    el = el.parentElement;
  }
  return document.body;
};
var useDropdown = (anchorRef, contentRef, options, props) => {
  const documentRef = useDocument();
  const rootRef = computed(() => {
    if (!documentRef.value) {
      return void 0;
    }
    const { root: root2 } = unref(options);
    if (root2) {
      let el;
      if (typeof root2 === "string") {
        el = documentRef.value.querySelector(root2);
      } else {
        el = root2;
      }
      if (!el) {
        return documentRef.value.body;
      }
      return findFirstRelativeParent(el);
    }
    return documentRef.value.body;
  });
  const { domRect: anchorDomRect } = useDomRect(anchorRef);
  const { domRect: contentDomRect } = useDomRect(contentRef);
  const css = {
    width: "max-content",
    position: "absolute"
  };
  const { position, align } = usePlacementAliases(props);
  watchPostEffect(() => {
    var _a, _b;
    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
      return;
    }
    const { offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options);
    let coords = calculateContentCoords(position.value, align.value, anchorDomRect.value, contentDomRect.value);
    let offsetCoords = { x: 0, y: 0 };
    if (offset) {
      offsetCoords = calculateOffsetCoords(position.value, offset);
      coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
    }
    const rootRect = rootRef.value.getBoundingClientRect();
    const viewportRect = (_b = (_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) != null ? _b : rootRect;
    if (autoPlacement) {
      const { position: newPosition, align: newAlign } = getAutoPlacement(position.value, align.value, coords, contentDomRect.value, viewportRect);
      if (newPosition !== position.value || newAlign !== align.value) {
        coords = calculateContentCoords(newPosition, newAlign, anchorDomRect.value, contentDomRect.value);
        if (offset) {
          offsetCoords = calculateOffsetCoords(newPosition, offset);
          coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
        }
      }
    }
    if (stickToEdges) {
      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);
    }
    coords.x -= rootRect.x;
    coords.y -= rootRect.y;
    if (contentRef.value) {
      let widthCss = {};
      if (keepAnchorWidth) {
        const { width } = anchorDomRect.value;
        widthCss = { width: `${width}px`, maxWidth: `${width}px` };
      }
      Object.assign(contentRef.value.style, {
        ...css,
        ...coordsToCss(coords),
        ...widthCss
      });
    }
  });
  return {
    anchorDomRect,
    contentDomRect
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useHTMLElementSelector.js
var useHTMLElementSelector = (key) => {
  return computed(() => {
    if (typeof (key == null ? void 0 : key.value) === "string") {
      return document.querySelector(key.value);
    }
    return extractHTMLElement(key == null ? void 0 : key.value);
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useIsMounted.js
var useIsMounted = () => {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  onBeforeUnmount(() => {
    isMounted.value = false;
  });
  return isMounted;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useAnchorSelector.js
var useAnchorSelector = (props) => {
  const anchorRef = ref();
  const document2 = useDocument();
  const computedAnchorRef = computed({
    set(v) {
      anchorRef.value = v;
    },
    get() {
      var _a, _b, _c, _d;
      if (props.anchorSelector) {
        return (_b = (_a = document2.value) == null ? void 0 : _a.querySelector(props.anchorSelector)) != null ? _b : anchorRef.value;
      } else if (props.innerAnchorSelector && anchorRef.value) {
        return (_d = (_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) != null ? _d : anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useCursorAnchor.js
var useCursorAnchor = (anchorRef, noUpdate) => {
  const mouse = reactive({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e) => {
    const { x, y } = anchorRef.value.getBoundingClientRect();
    mouse.x = e.clientX - x;
    mouse.y = e.clientY - y;
  }, anchorRef);
  const mouseOffset = {
    x: 0,
    y: 0
  };
  watchEffect(() => {
    if (noUpdate.value) {
      return;
    }
    mouseOffset.x = mouse.x;
    mouseOffset.y = mouse.y;
  });
  return computed(() => {
    if (!anchorRef.value) {
      return void 0;
    }
    const target = anchorRef.value;
    const getBoundingClientRect = () => {
      const rect = target.getBoundingClientRect();
      const x = rect.left + mouseOffset.x;
      const y = rect.top + mouseOffset.y;
      return {
        ...rect,
        x,
        y,
        bottom: y + 1,
        right: x + 1,
        left: x,
        top: y
      };
    };
    return new Proxy(target, {
      get(target2, key) {
        if (key === "getBoundingClientRect") {
          return getBoundingClientRect;
        }
        return target2[key];
      }
    });
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useDropdownNavigation.js
var isTyping = (e) => {
  const target = e.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
var openKey = ["ArrowDown", "ArrowUp", "Enter", "Space"];
var useKeyboardNavigation = (anchorRef, isOpened) => {
  useEvent("keydown", (e) => {
    if (isTyping(e)) {
      return;
    }
    if (!openKey.includes(e.key)) {
      return;
    }
    isOpened.value = !isOpened.value;
    e.preventDefault();
  }, anchorRef);
  useEvent("keydown", (e) => {
    if (e.key === "Escape" && isOpened.value) {
      isOpened.value = false;
      e.preventDefault();
    }
  }, true);
};
var useMouseNavigation = (anchorRef, listeners) => {
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (isTyping(e)) {
      return;
    }
    listeners[e.type](e);
  }, anchorRef);
  useEvent(["mouseleave", "mouseenter"], (e) => {
    listeners[e.type](e);
  }, anchorRef);
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/VaDropdown.js
var _style_018 = ":root,\n:host {\n  --va-dropdown-line-height: 1;\n  --va-dropdown-content-wrapper-z-index: var(--va-z-index-teleport-overlay, 9);\n  --va-dropdown-display: inline-flex;\n}\n.va-dropdown {\n  /* Solved the alignment problem (if we try to align inline and block elements) */\n  line-height: var(--va-dropdown-line-height);\n  font-family: var(--va-font-family);\n  display: var(--va-dropdown-display);\n  position: relative;\n  max-width: 100%;\n  vertical-align: middle;\n}\n.va-dropdown--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-dropdown__content-wrapper {\n  z-index: var(--va-dropdown-content-wrapper-z-index);\n  font-family: var(--va-font-family);\n  top: 0;\n  left: 0;\n}";
var _sfc_main20 = defineComponent({
  name: "VaDropdown",
  props: {
    ...createStatefulProps(Boolean, true),
    ...useComponentPresetProp,
    ...usePlacementAliasesProps,
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    target: { type: [String, Object], default: void 0 },
    preventOverflow: { type: Boolean, default: false },
    keepAnchorWidth: { type: Boolean, default: false },
    isContentHoverable: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    offset: { type: [Array, Number], default: 0 },
    stickToEdges: { type: Boolean, default: false },
    autoPlacement: { type: Boolean, default: true },
    cursor: { type: Boolean, default: false },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    keyboardNavigation: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "close", "open"],
  setup(props, { emit }) {
    const contentRef = shallowRef();
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const computedClass = useBem("va-dropdown", () => pick_1(props, ["disabled"]));
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onMouseEnter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseLeave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close && props.trigger !== "none") {
        valueComputed.value = false;
      }
    };
    const elRef = useHTMLElement("anchorRef");
    if (props.keyboardNavigation) {
      useKeyboardNavigation(elRef, valueComputed);
    }
    useMouseNavigation(elRef, {
      click(e) {
        if (props.trigger !== "click" && kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-click", props.closeOnAnchorClick, e);
        } else {
          if (props.trigger !== "click") {
            return;
          }
          valueComputed.value = true;
          emit("anchor-click", e);
        }
      },
      contextmenu(e) {
        if (kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        e.preventDefault();
        if (valueComputed.value) {
          emitAndClose("anchor-right-click", props.closeOnAnchorClick, e);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-right-click", e);
        }
      },
      dblclick(e) {
        if (props.trigger !== "dblclick" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-dblclick", props.closeOnAnchorClick, e);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-dblclick", e);
        }
      },
      mouseenter: onMouseEnter,
      mouseleave: onMouseLeave
    });
    const { anchorRef: computedAnchorRef } = useAnchorSelector(props);
    useClickOutside([computedAnchorRef, contentRef], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    const cursorAnchor = useCursorAnchor(computedAnchorRef, valueComputed);
    const document2 = useDocument();
    const isPopoverFloating = computed(() => props.preventOverflow || props.cursor);
    const target = useHTMLElementSelector(computed(() => props.target || "body"));
    const targetComputed = computed(() => {
      var _a, _b, _c;
      if (computedAnchorRef.value && !((_b = (_a = target.value) == null ? void 0 : _a.contains) == null ? void 0 : _b.call(_a, computedAnchorRef.value))) {
        return (_c = document2.value) == null ? void 0 : _c.body;
      }
      return target.value;
    });
    const teleportTargetComputed = computed(() => {
      if (!isPopoverFloating.value) {
        return elRef.value;
      }
      return targetComputed.value;
    });
    const teleportDisabled = computed(() => props.disabled || !isPopoverFloating.value);
    useDropdown(
      computed(() => props.cursor ? cursorAnchor.value : computedAnchorRef.value),
      contentRef,
      computed(() => ({
        keepAnchorWidth: props.keepAnchorWidth,
        offset: props.offset,
        stickToEdges: props.stickToEdges,
        autoPlacement: props.autoPlacement,
        root: teleportTargetComputed.value,
        viewport: targetComputed.value
      })),
      props
    );
    const idComputed = computed(generateUniqueId);
    return {
      ...useTranslation(),
      teleportTargetComputed,
      teleportDisabled,
      isMounted: useIsMounted(),
      anchorRef: computedAnchorRef,
      valueComputed,
      contentRef,
      computedClass,
      idComputed,
      emitAndClose,
      onMouseEnter,
      onMouseLeave,
      hide: () => {
        valueComputed.value = false;
      },
      show: () => {
        valueComputed.value = true;
      }
    };
  }
});
var _hoisted_111 = ["aria-label", "aria-disabled", "aria-expanded", "aria-controls"];
var _hoisted_26 = ["id"];
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-dropdown", _ctx.computedClass]),
    ref: "anchorRef",
    role: "button",
    "aria-label": _ctx.t("toggleDropdown"),
    "aria-disabled": _ctx.$props.disabled,
    "aria-expanded": !!_ctx.valueComputed,
    "aria-controls": _ctx.idComputed,
    style: { "position": "relative" }
  }, [
    renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show }))),
    _ctx.isMounted ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.teleportTargetComputed,
      disabled: _ctx.teleportDisabled
    }, [
      _ctx.valueComputed ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "contentRef",
        class: "va-dropdown__content-wrapper",
        id: _ctx.idComputed,
        onMouseover: _cache[0] || (_cache[0] = ($event) => _ctx.$props.isContentHoverable && _ctx.onMouseEnter()),
        onMouseout: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.emitAndClose("content-click", _ctx.closeOnContentClick), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show })))
      ], 40, _hoisted_26)) : createCommentVNode("", true)
    ], 8, ["to", "disabled"])) : createCommentVNode("", true)
  ], 10, _hoisted_111);
}
var _VaDropdown = _export_sfc(_sfc_main20, [["render", _sfc_render18], ["styles", [_style_018]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/index.js
var VaDropdown = withConfigTransport(_VaDropdown);

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.js
var _style_019 = ":root,\n:host {\n  --va-dropdown-content-padding: 0.5rem;\n  --va-dropdown-content-box-shadow: var(--va-box-shadow);\n  --va-dropdown-content-border-radius: 4px;\n}\n.va-dropdown__content {\n  padding: var(--va-dropdown-content-padding);\n  box-shadow: var(--va-dropdown-content-box-shadow);\n  border-radius: var(--va-dropdown-content-border-radius);\n  font-family: var(--va-font-family);\n}";
var _sfc_main21 = defineComponent({
  name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "background-secondary" },
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return { computedStyle };
  }
});
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-dropdown__content",
    style: normalizeStyle(_ctx.computedStyle),
    role: "listbox"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaDropdownContent = _export_sfc(_sfc_main21, [["render", _sfc_render19], ["styles", [_style_019]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/components/VaDropdownContent/index.js
var VaDropdownContent = withConfigTransport(_VaDropdownContent);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-dropdown/VaButtonDropdown.js
var _style_020 = ':root,\n:host {\n  --va-button-dropdown-button-margin: 0;\n}\n.va-button-dropdown {\n  display: inline-block;\n  font-family: var(--va-font-family);\n  vertical-align: middle;\n}\n.va-button-dropdown .va-button {\n  margin: var(--va-button-dropdown-button-margin);\n}\n.va-button-dropdown--split .va-dropdown .va-dropdown__anchor {\n  margin: var(--va-button-dropdown-button-margin);\n}\n.va-button-dropdown--split .va-button-group__left-icon .va-dropdown .va-button {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.va-button-dropdown--split .va-button-group__left-icon > .va-button {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-left: none;\n}\n.va-button-dropdown--split :not(.va-button-group__left-icon) .va-dropdown .va-button {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.va-button-dropdown--split .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy(
  [{ listen: "click", emit: "main-button-click" }]
);
var VaButtonProps2 = omit_1(extractComponentProps(VaButton2), ["iconRight", "block"]);
var VaDropdownProps = extractComponentProps(VaDropdown);
var _sfc_main22 = defineComponent({
  name: "VaButtonDropdown",
  components: {
    VaButton: VaButton2,
    VaDropdown,
    VaButtonGroup,
    VaDropdownContent
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  props: {
    ...useComponentPresetProp,
    ...VaButtonProps2,
    ...VaDropdownProps,
    ...useStatefulProps,
    ...usePlacementAliasesProps,
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    icon: { type: String, default: "va-arrow-down" },
    openedIcon: { type: String, default: "va-arrow-up" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    iconColor: { type: String, default: "" },
    disabled: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String }
  },
  setup(props, { emit, slots }) {
    const { valueComputed } = useStateful(props, emit);
    const computedIcon = computed(() => valueComputed.value ? props.openedIcon : props.icon);
    const computedClass = useBem("va-button-dropdown", () => ({
      split: props.split
    }));
    const computedButtonIcons = computed(() => {
      if (props.hideIcon) {
        return {};
      }
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return { [propName]: computedIcon.value };
    });
    const buttonPropsFiltered = computed(() => {
      let ignoredProps = ["to", "href", "loading", "icon"];
      const presetProps = [
        "plain",
        "textOpacity",
        "backgroundOpacity",
        "hoverOpacity",
        "hoverBehavior",
        "hoverOpacity",
        "pressedOpacity",
        "pressedBehavior",
        "pressedOpacity"
      ];
      if (props.preset) {
        ignoredProps = [...ignoredProps, ...presetProps];
      }
      const filteredProps = omit_1(VaButtonProps2, ignoredProps);
      return Object.keys(filteredProps);
    });
    const buttonPropsComputed = computed(
      () => Object.entries(props).filter(([key, _]) => buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value]) => {
        Object.assign(acc, { [key]: value });
        return acc;
      }, {})
    );
    const computedMainButtonProps = computed(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const splitButtonClassComputed = computed(() => ({ "va-button-group__left-icon": props.leftIcon }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    return {
      ...useTranslation(),
      vaDropdownProps: filterComponentProps(VaDropdownProps),
      hideDropdown,
      valueComputed,
      computedIcon,
      computedClass,
      computedButtonIcons,
      buttonPropsComputed,
      computedMainButtonProps,
      splitButtonClassComputed,
      listeners: createListeners(emit),
      mainButtonListeners: createMainButtonListeners(emit)
    };
  }
});
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-dropdown", _ctx.computedClass])
  }, [
    !_ctx.$props.split ? (openBlock(), createBlock(_component_va_dropdown, mergeProps({ key: 0 }, _ctx.vaDropdownProps, {
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
    }), {
      anchor: withCtx(() => [
        createVNode(_component_va_button, mergeProps({ ..._ctx.computedButtonIcons, ..._ctx.buttonPropsComputed }, toHandlers(_ctx.listeners), {
          onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["onKeydown"])
      ]),
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "content", {}, () => [
          createVNode(_component_va_dropdown_content, null, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          })
        ])
      ]),
      _: 3
    }, 16, ["modelValue", "disabled"])) : (openBlock(), createBlock(_component_va_button_group, mergeProps({
      key: 1,
      class: _ctx.splitButtonClassComputed
    }, _ctx.buttonPropsComputed), {
      default: withCtx(() => [
        !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 0,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true),
        createVNode(_component_va_dropdown, mergeProps({
          modelValue: _ctx.valueComputed,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
        }, _ctx.vaDropdownProps, {
          disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
        }), {
          anchor: withCtx(() => [
            createVNode(_component_va_button, mergeProps({
              "aria-label": _ctx.t("toggleDropdown"),
              disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
              icon: _ctx.computedIcon,
              "icon-color": _ctx.$props.iconColor
            }, toHandlers(_ctx.listeners), {
              onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
            }), null, 16, ["aria-label", "disabled", "icon", "icon-color", "onKeydown"])
          ]),
          default: withCtx(() => [
            createVNode(_component_va_dropdown_content, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["modelValue", "disabled"]),
        _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 1,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["class"]))
  ], 2);
}
var _VaButtonDropdown = _export_sfc(_sfc_main22, [["render", _sfc_render20], ["styles", [...VaButton2.styles || [], ...VaDropdown.styles || [], ...VaButtonGroup.styles || [], ...VaDropdownContent.styles || [], _style_020]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-dropdown/index.js
var VaButtonDropdown = withConfigTransport(_VaButtonDropdown);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-toggle/VaButtonToggle.js
var _style_021 = '.va-button-toggle .va-button {\n  height: auto;\n}\n.va-button-toggle .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var VaButtonGroupProps = extractComponentProps(VaButtonGroup);
var _sfc_main23 = defineComponent({
  name: "VaButtonToggle",
  components: {
    VaButtonGroup,
    VaButton: VaButton2
  },
  emits: ["update:modelValue"],
  props: {
    ...VaButtonGroupProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" }
  },
  setup(props, { emit }) {
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    VaButtonGroupProps.color;
    const colorComputed = computed(() => getColor(props.color));
    const isToggled = (value) => value === props.modelValue;
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      }
      return shiftHSLAColor2(colorComputed.value, { l: props.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed(() => {
      if (!props.preset || props.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props.pressedOpacity };
    });
    const activeButtonPropsComputed = computed(() => ({
      color: activeButtonColor.value,
      textColor: props.activeButtonTextColor,
      ...activeButtonBackgroundOpacityComputed.value
    }));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option.value)) {
        return iconsProps;
      }
      return {
        ...isToggled(option.value) && activeButtonPropsComputed.value,
        ...iconsProps
      };
    };
    const buttonGroupPropsComputed = computed(
      () => omit_1(props, ["modelValue", "options", "activeButtonTextColor", "toggleColor"])
    );
    const changeValue = (value) => emit("update:modelValue", value);
    return {
      buttonGroupPropsComputed,
      getButtonProps,
      changeValue,
      isToggled
    };
  }
});
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createBlock(_component_va_button_group, mergeProps({ class: "va-button-toggle" }, _ctx.buttonGroupPropsComputed), {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
        return openBlock(), createBlock(_component_va_button, mergeProps({
          key: option.value,
          "aria-pressed": _ctx.isToggled(option.value)
        }, _ctx.getButtonProps(option), {
          onClick: ($event) => _ctx.changeValue(option.value)
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(option.label), 1)
          ]),
          _: 2
        }, 1040, ["aria-pressed", "onClick"]);
      }), 128))
    ]),
    _: 1
  }, 16);
}
var _VaButtonToggle = _export_sfc(_sfc_main23, [["render", _sfc_render21], ["styles", [...VaButtonGroup.styles || [], ...VaButton2.styles || [], _style_021]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-toggle/index.js
var VaButtonToggle = withConfigTransport(_VaButtonToggle);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/VaCard.js
var _style_022 = ':root,\n:host {\n  --va-card-display: block;\n  --va-card-position: relative;\n  --va-card-overflow: visible;\n  --va-card-box-shadow: var(--va-box-shadow);\n  --va-card-border-radius: 0.375rem;\n  --va-card-color: #34495e;\n  --va-card-background-color: var(--va-background-secondary);\n  --va-card-padding: 1.25rem;\n  /* Outlined */\n  --va-card-outlined-border: 3px solid var(--va-background-element);\n  --va-card-outlined-box-shadow: none;\n  /* Stripe */\n  --va-card-stripe-border-size: var(--va-stripe-border-size);\n  /* Dark */\n  --va-card-dark-color: #ffffff;\n  --va-card-dark-background-color: #34495e;\n  /* Actions */\n  --va-card-actions-btn-margin: 4px;\n}\n.va-card {\n  display: var(--va-card-display);\n  position: var(--va-card-position);\n  overflow: var(--va-card-overflow);\n  box-shadow: var(--va-card-box-shadow, var(--va-block-box-shadow));\n  border-radius: var(--va-card-border-radius, var(--va-block-border-radius));\n  color: var(--va-card-color);\n  background-color: var(--va-card-background-color);\n  font-family: var(--va-font-family);\n}\n.va-card > div:first-child {\n  border-top-right-radius: var(--va-card-border-radius);\n  border-top-left-radius: var(--va-card-border-radius);\n}\n.va-card > div:last-child {\n  border-bottom-right-radius: var(--va-card-border-radius);\n  border-bottom-left-radius: var(--va-card-border-radius);\n}\n.va-card--square {\n  border-radius: 0;\n}\n.va-card--outlined {\n  box-shadow: var(--va-card-outlined-box-shadow);\n  border: var(--va-card-outlined-border, var(--va-block-border));\n}\n.va-card--no-border {\n  border: none;\n}\n.va-card--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-card--link {\n  cursor: pointer;\n}\n.va-card--stripe::after {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: var(--va-card-stripe-border-size);\n  top: 0;\n  left: 0;\n  background: var(--0e93fe42);\n  border-top-right-radius: var(--va-card-border-radius);\n  border-top-left-radius: var(--va-card-border-radius);\n}';
var __default__4 = defineComponent({
  name: "VaCard",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "background-secondary" }
  },
  setup(props) {
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor();
    const stripeColorComputed = computed(() => getColor(props.stripeColor));
    const classComputed = useBem("va-card", () => ({
      ...pick_1(props, ["square", "outlined", "disabled", "stripe"]),
      noBorder: !props.bordered,
      link: isLinkTag.value
    }));
    const cardStyles = computed(() => {
      const background = props.gradient && props.color ? getGradientBackground(getColor(props.color)) : getColor(props.color);
      return {
        background,
        color: textColorComputed.value
      };
    });
    return {
      classComputed,
      cardStyles,
      stripeColorComputed,
      tagComputed,
      hrefComputed
    };
  }
});
var __injectCSSVars__4 = () => {
  useCssVars((_ctx) => ({
    "0e93fe42": _ctx.stripeColorComputed
  }));
};
var __setup__4 = __default__4.setup;
__default__4.setup = __setup__4 ? (props, ctx) => {
  __injectCSSVars__4();
  return __setup__4(props, ctx);
} : __injectCSSVars__4;
var _sfc_main24 = __default__4;
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-card", _ctx.classComputed]),
    style: normalizeStyle(_ctx.cardStyles),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
}
var _VaCard = _export_sfc(_sfc_main24, [["render", _sfc_render22], ["styles", [_style_022]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-content/VaCardContent.js
var _style_023 = ".va-card__title, .va-card__content, .va-card__actions, .va-card__actions--vertical {\n  padding: var(--va-card-padding);\n}\n.va-card__title + .va-card__title,\n.va-card__title + .va-card__content,\n.va-card__title + .va-card__actions,\n.va-card__title + .va-card_actions__vertical, .va-card__content + .va-card__title,\n.va-card__content + .va-card__content,\n.va-card__content + .va-card__actions,\n.va-card__content + .va-card_actions__vertical, .va-card__actions + .va-card__title,\n.va-card__actions + .va-card__content,\n.va-card__actions + .va-card__actions,\n.va-card__actions + .va-card_actions__vertical, .va-card__actions--vertical + .va-card__title,\n.va-card__actions--vertical + .va-card__content,\n.va-card__actions--vertical + .va-card__actions,\n.va-card__actions--vertical + .va-card_actions__vertical {\n  padding-top: 0;\n}\n.va-card__content .va-card-block {\n  flex: 1;\n}";
var _sfc_main25 = defineComponent({
  name: "VaCardContent"
});
var _hoisted_112 = { class: "va-card__content" };
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_112, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VaCardContentBase = _export_sfc(_sfc_main25, [["render", _sfc_render23], ["styles", [_style_023]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-title/VaCardTitle.js
var _style_024 = ".va-card__title[data-v-875a3baa] {\n  display: flex;\n  align-items: center;\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n}\n.va-card__title[data-v-875a3baa], .va-card__content[data-v-875a3baa], .va-card__actions[data-v-875a3baa], .va-card__actions--vertical[data-v-875a3baa] {\n  padding: var(--va-card-padding);\n}\n.va-card__title + .va-card__title[data-v-875a3baa],\n.va-card__title + .va-card__content[data-v-875a3baa],\n.va-card__title + .va-card__actions[data-v-875a3baa],\n.va-card__title + .va-card_actions__vertical[data-v-875a3baa], .va-card__content + .va-card__title[data-v-875a3baa],\n.va-card__content + .va-card__content[data-v-875a3baa],\n.va-card__content + .va-card__actions[data-v-875a3baa],\n.va-card__content + .va-card_actions__vertical[data-v-875a3baa], .va-card__actions + .va-card__title[data-v-875a3baa],\n.va-card__actions + .va-card__content[data-v-875a3baa],\n.va-card__actions + .va-card__actions[data-v-875a3baa],\n.va-card__actions + .va-card_actions__vertical[data-v-875a3baa], .va-card__actions--vertical + .va-card__title[data-v-875a3baa],\n.va-card__actions--vertical + .va-card__content[data-v-875a3baa],\n.va-card__actions--vertical + .va-card__actions[data-v-875a3baa],\n.va-card__actions--vertical + .va-card_actions__vertical[data-v-875a3baa] {\n  padding-top: 0;\n}";
var _sfc_main26 = defineComponent({
  name: "VaCardTitle",
  props: {
    ...useComponentPresetProp,
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      titleStyles: computed(() => ({
        color: props.textColor ? getColor(props.textColor) : ""
      }))
    };
  }
});
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-card-title va-card__title",
    style: normalizeStyle(_ctx.titleStyles)
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 4);
}
var VaCardTitleBase = _export_sfc(_sfc_main26, [["render", _sfc_render24], ["styles", [_style_024]], ["__scopeId", "data-v-875a3baa"]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-actions/VaCardActions.js
var _style_025 = ".va-card__title, .va-card__content, .va-card__actions, .va-card__actions--vertical {\n  padding: var(--va-card-padding);\n}\n.va-card__title + .va-card__title,\n.va-card__title + .va-card__content,\n.va-card__title + .va-card__actions,\n.va-card__title + .va-card_actions__vertical, .va-card__content + .va-card__title,\n.va-card__content + .va-card__content,\n.va-card__content + .va-card__actions,\n.va-card__content + .va-card_actions__vertical, .va-card__actions + .va-card__title,\n.va-card__actions + .va-card__content,\n.va-card__actions + .va-card__actions,\n.va-card__actions + .va-card_actions__vertical, .va-card__actions--vertical + .va-card__title,\n.va-card__actions--vertical + .va-card__content,\n.va-card__actions--vertical + .va-card__actions,\n.va-card__actions--vertical + .va-card_actions__vertical {\n  padding-top: 0;\n}\n.va-card__actions button,\n.va-card__actions .va-button {\n  margin: 0 var(--va-card-actions-btn-margin);\n}\n.va-card__actions button:first-child,\n.va-card__actions .va-button:first-child {\n  margin-left: 0;\n}\n.va-card__actions button:last-child,\n.va-card__actions .va-button:last-child {\n  margin-right: 0;\n}\n.va-card__actions--vertical button,\n.va-card__actions--vertical .va-button {\n  margin: var(--va-card-actions-btn-margin) 0;\n}\n.va-card__actions--vertical button:first-child,\n.va-card__actions--vertical .va-button:first-child {\n  margin-top: 0;\n}\n.va-card__actions--vertical button:last-child,\n.va-card__actions--vertical .va-button:last-child {\n  margin-bottom: 0;\n}";
var _sfc_main27 = defineComponent({
  name: "VaCardActions",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp
  },
  setup(props) {
    const { alignComputed } = useAlign(props);
    const classComputed = useBem("va-card__actions", () => ({
      ...pick_1(props, ["vertical"])
    }));
    return {
      classComputed,
      alignComputed
    };
  }
});
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-card__actions", _ctx.classComputed]),
    style: normalizeStyle(_ctx.alignComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var VaCardActionsBase = _export_sfc(_sfc_main27, [["render", _sfc_render25], ["styles", [_style_025]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-block/VaCardBlock.js
var _style_026 = ".va-card-block {\n  display: flex;\n  flex-direction: column;\n}\n.va-card-block > div:first-child {\n  border-top-right-radius: var(--va-card-border-radius);\n  border-top-left-radius: var(--va-card-border-radius);\n}\n.va-card-block > div:last-child {\n  border-bottom-right-radius: var(--va-card-border-radius);\n  border-bottom-left-radius: var(--va-card-border-radius);\n}\n.va-card-block > div {\n  flex: auto;\n}\n.va-card-block--horizontal {\n  flex-direction: row;\n}\n.va-card-block--horizontal > div:first-child {\n  border-top-left-radius: var(--va-card-border-radius);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: var(--va-card-border-radius);\n}\n.va-card-block--horizontal > div:last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: var(--va-card-border-radius);\n  border-bottom-right-radius: var(--va-card-border-radius);\n}\n.va-card-block--horizontal > .va-divider {\n  flex: 0;\n}";
var _sfc_main28 = defineComponent({
  name: "VaCardBlock",
  props: {
    horizontal: {
      type: Boolean,
      default: false
    }
  },
  setup: (props) => ({
    classComputed: computed(() => ({
      "va-card-block--horizontal": props.horizontal
    }))
  })
});
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-card-block", _ctx.classComputed])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var VaCardBlockBase = _export_sfc(_sfc_main28, [["render", _sfc_render26], ["styles", [_style_026]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/index.js
var VaCardContent = withConfigTransport(VaCardContentBase);
var VaCardTitle = withConfigTransport(VaCardTitleBase);
var VaCardActions = withConfigTransport(VaCardActionsBase);
var VaCardBlock = withConfigTransport(VaCardBlockBase);
var VaCard = withConfigTransport(_VaCard);

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/hooks/useCarousel.js
var useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    goTo,
    prev,
    next
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/hooks/useCarouselAnimation.js
var useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  let direction = 1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      if (props.infinite) {
        currentSlide.value += 1;
        if (currentSlide.value >= props.items.length) {
          currentSlide.value = 0;
        }
      } else {
        if (currentSlide.value <= 0) {
          direction = 1;
        }
        if (currentSlide.value >= props.items.length - 1) {
          direction = -1;
        }
        currentSlide.value += direction;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props.effect === "fade") {
      return {
        ...slidesContainerStyle.value,
        transition: "none"
      };
    }
    if (props.vertical) {
      return {
        ...slidesContainerStyle.value,
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      };
    }
    return {
      ...slidesContainerStyle.value,
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    };
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last2 = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last2) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last2 && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/hooks/useCarouselColors.js
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("background-element"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSwipe.js
var mouseEvents = ["mousedown", "mousemove"];
var touchEvents = ["touchstart", "touchmove"];
var commonAllowedDirections = {
  vertical: ["", "all", "vertical"],
  horizontal: ["", "all", "horizontal"]
};
var verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, "up", "down"];
var horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, "left", "right"];
var useSwipeProps = {
  swipable: { type: Boolean, default: false },
  swipeDistance: { type: Number, default: 75 },
  swipeDirection: { type: String, default: "all" }
};
var useSwipe = (props, container, cb) => {
  const swipeStarted = ref(false);
  const swipePath = reactive({
    start: { x: 0, y: 0 },
    end: { x: 0, y: 0 }
  });
  const swipeDuration = reactive({
    start: 0,
    end: 0
  });
  const setState = (e, type) => {
    let event;
    if (mouseEvents.includes(e.type)) {
      event = e;
    }
    if (touchEvents.includes(e.type)) {
      const touchEvent = e;
      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
    }
    if (!event) {
      return;
    }
    swipePath[type].x = event.pageX;
    swipePath[type].y = event.pageY;
    swipeDuration[type] = new Date().getTime();
  };
  const onSwipeStart = (e) => {
    if (!props.swipable || swipeStarted.value) {
      return;
    }
    swipeStarted.value = true;
    setState(e, "start");
  };
  const onSwipeMove = (e) => {
    if (!swipeStarted.value) {
      return;
    }
    setState(e, "end");
  };
  const resetSwipe = () => {
    ["start", "end"].forEach((type) => {
      swipePath[type].x = 0;
      swipePath[type].y = 0;
      swipeDuration[type] = 0;
    });
    swipeStarted.value = false;
  };
  const isSwipeAllowed = reactive({
    vertical: false,
    horizontal: false
  });
  watchEffect(() => {
    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);
    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);
  });
  const calcDistance = (axis) => {
    return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
  };
  const getAcceptableValue = (direction, result) => {
    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : "";
  };
  const swipeState = reactive({ direction: "", duration: 0 });
  watch(swipePath, () => {
    const xDistance = calcDistance("x");
    const yDistance = calcDistance("y");
    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {
      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
        const result = xDistance > 0 ? "left" : "right";
        swipeState.direction = getAcceptableValue("horizontal", result);
      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
        const result = yDistance > 0 ? "down" : "up";
        swipeState.direction = getAcceptableValue("vertical", result);
      }
      swipeState.duration = swipeDuration.end - swipeDuration.start;
      resetSwipe();
    }
  }, { deep: true });
  watch(swipeState, () => cb(swipeState), { deep: true });
  if (props.swipable) {
    useEvent(["touchstart", "mousedown"], onSwipeStart, container);
    useEvent(["touchmove", "mousemove"], onSwipeMove, container);
    useEvent(["touchcancel", "mouseup", "touchend", "mouseleave"], resetSwipe, container);
  }
  return { swipeState };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/hooks/useNativeImgAttributes.js
var useNativeImgAttributesProps = {
  src: { type: String, required: true },
  alt: { type: String, default: "" },
  title: { type: String, default: "" },
  sizes: { type: String, default: "" },
  srcset: { type: String, default: "" },
  draggable: { type: Boolean, default: true },
  loading: {
    type: String
  },
  crossorigin: {
    type: String
  },
  decoding: {
    type: String
  },
  fetchpriority: {
    type: String,
    default: "auto"
  },
  referrerpolicy: {
    type: String
  }
};
var useNativeImgAttributes = (props) => {
  return computed(
    () => pick_1(props, ["src", "alt", "title", "sizes", "srcset", "loading", "referrerpolicy", "fetchpriority", "decoding", "crossorigin", "draggable"])
  );
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useDeprecated.js
var OPTIONS_LIST = {
  props: "prop",
  attrs: "prop",
  slots: "slot"
};
var useDeprecated = (deprecatedList, deprecationSource = ["props", "attrs"]) => {
  if (!__DEV__) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  const instanceName = instance.type.name;
  const deprecatedItems = unref(deprecatedList);
  deprecationSource.every((source) => {
    var _a;
    const option = OPTIONS_LIST[source];
    const throwWarning = (key) => console.warn(`The '${key}' ${option} (${instanceName} component) is deprecated! Please, check the documentation.`);
    if (source === "props") {
      const propsOptions = ((_a = instance.propsOptions) == null ? void 0 : _a[0]) || {};
      const propsValues = instance.props || {};
      deprecatedItems.forEach((propName) => {
        propsOptions[propName] && propsValues[propName] !== propsOptions[propName].default && throwWarning(propName);
      });
      return true;
    }
    Object.keys({ ...instance[source] }).forEach((key) => {
      if (deprecatedItems.includes(key)) {
        throwWarning(key);
      }
    });
    return true;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useIntersectionObserver.js
var useIntersectionObserver = (cb, options = ref({}), target = ref([]), enabled = true) => {
  const observer2 = ref();
  const disconnectObserver = () => {
    var _a;
    (_a = observer2.value) == null ? void 0 : _a.disconnect();
  };
  const observeTarget = (target2) => {
    var _a;
    const disclosedTarget = extractHTMLElement(unref(target2));
    disclosedTarget && ((_a = observer2.value) == null ? void 0 : _a.observe(disclosedTarget));
  };
  const observeAll = (targets) => {
    targets.forEach(observeTarget);
  };
  const initObserver = () => {
    observer2.value = new IntersectionObserver(cb, options.value);
  };
  const isIntersectionDisabled = computed(() => !enabled || !(typeof window !== "undefined" && "IntersectionObserver" in window));
  watch([target, options], ([newTarget]) => {
    if (isIntersectionDisabled.value) {
      return;
    }
    disconnectObserver();
    if (!newTarget) {
      return;
    }
    initObserver();
    Array.isArray(newTarget) ? observeAll(newTarget) : observeTarget(newTarget);
  }, { immediate: true });
  onBeforeUnmount(disconnectObserver);
  return { isIntersectionDisabled };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/VaImage.js
var _style_027 = ":host {\n  --va-image-position: absolute;\n  --va-image-object-position: 50% 50%;\n}\n.va-image__content {\n  position: var(--va-image-position);\n  inset: 0;\n}\n.va-image__content img {\n  width: 100%;\n  height: 100%;\n  object-fit: var(--64b11d12);\n  object-position: var(--va-image-object-position);\n}\n.va-image__overlay {\n  position: absolute;\n  inset: 0;\n}\n.va-image__placeholder, .va-image__loader, .va-image__error, .va-image__overlay {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}";
var VaFallbackProps2 = extractComponentProps(VaFallback);
var __default__5 = defineComponent({
  name: "VaImage",
  components: { VaAspectRatio, VaFallback },
  emits: ["loaded", "error", "fallback"],
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps2,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v) => v >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" },
    contain: { type: Boolean, default: false }
  },
  setup(props, { emit, slots }) {
    useDeprecated(["contain"]);
    const root2 = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a = image.value) == null ? void 0 : _a.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer2) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer2.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root2, props.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a;
        if (!((_a = image.value) == null ? void 0 : _a.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props.src, init);
    const isPlaceholderPassed = computed(() => {
      var _a;
      return ((_a = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a;
      return isLoading.value && !((_a = slots == null ? void 0 : slots.loader) == null ? void 0 : _a.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a;
      return isError.value && (!((_a = slots == null ? void 0 : slots.error) == null ? void 0 : _a.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick_1(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps2);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a = useGlobalConfig()) == null ? void 0 : _a.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => {
      if (props.contain) {
        return "contain";
      }
      return props.fit;
    });
    return {
      fitComputed,
      root: root2,
      image,
      isLoading,
      handleLoad,
      isError,
      handleError,
      isReadyForRender,
      isPlaceholderShown,
      isSuccessfullyLoaded,
      imgAttributesComputed,
      aspectRationAttributesComputed,
      isAnyFallbackPassed,
      fallbackProps
    };
  }
});
var __injectCSSVars__5 = () => {
  useCssVars((_ctx) => ({
    "64b11d12": _ctx.fitComputed
  }));
};
var __setup__5 = __default__5.setup;
__default__5.setup = __setup__5 ? (props, ctx) => {
  __injectCSSVars__5();
  return __setup__5(props, ctx);
} : __injectCSSVars__5;
var _sfc_main29 = __default__5;
var _hoisted_113 = ["aria-busy"];
var _hoisted_27 = {
  key: 0,
  class: "va-image__overlay"
};
var _hoisted_34 = {
  key: 1,
  class: "va-image__error"
};
var _hoisted_44 = {
  key: 2,
  class: "va-image__loader"
};
var _hoisted_54 = {
  key: 3,
  class: "va-image__placeholder"
};
var _hoisted_63 = ["src"];
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_fallback = resolveComponent("va-fallback");
  const _component_va_aspect_ratio = resolveComponent("va-aspect-ratio");
  return openBlock(), createBlock(_component_va_aspect_ratio, mergeProps({
    ref: "root",
    class: "va-image"
  }, _ctx.aspectRationAttributesComputed), {
    default: withCtx(() => [
      withDirectives(createBaseVNode("picture", {
        class: "va-image__content",
        "aria-busy": _ctx.isLoading
      }, [
        _ctx.$slots.sources ? renderSlot(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode("", true),
        _ctx.isReadyForRender ? (openBlock(), createElementBlock("img", mergeProps({
          key: 1,
          ref: "image"
        }, _ctx.imgAttributesComputed, {
          onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
          onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
        }), null, 16)) : createCommentVNode("", true)
      ], 8, _hoisted_113), [
        [vShow, _ctx.isSuccessfullyLoaded]
      ]),
      _ctx.$slots.default && _ctx.isSuccessfullyLoaded ? (openBlock(), createElementBlock("div", _hoisted_27, [
        renderSlot(_ctx.$slots, "default")
      ])) : createCommentVNode("", true),
      _ctx.isError && (_ctx.$slots.error || _ctx.isAnyFallbackPassed) ? (openBlock(), createElementBlock("div", _hoisted_34, [
        renderSlot(_ctx.$slots, "error", {}, () => [
          createVNode(_component_va_fallback, mergeProps(_ctx.fallbackProps, {
            onFallback: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("fallback"))
          }), null, 16)
        ])
      ])) : createCommentVNode("", true),
      _ctx.isLoading && _ctx.$slots.loader ? (openBlock(), createElementBlock("div", _hoisted_44, [
        renderSlot(_ctx.$slots, "loader")
      ])) : createCommentVNode("", true),
      _ctx.isPlaceholderShown ? (openBlock(), createElementBlock("div", _hoisted_54, [
        renderSlot(_ctx.$slots, "placeholder", {}, () => [
          _ctx.$props.placeholderSrc ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.$props.placeholderSrc,
            alt: ""
          }, null, 8, _hoisted_63)) : createCommentVNode("", true)
        ])
      ])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16);
}
var _VaImage = _export_sfc(_sfc_main29, [["render", _sfc_render27], ["styles", [...VaAspectRatio.styles || [], ...VaFallback.styles || [], _style_027]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/index.js
var VaImage = withConfigTransport(_VaImage);

// node_modules/vuestic-ui/dist/web-components/src/components/va-hover/VaHover.js
var _sfc_main30 = defineComponent({
  name: "VaHover",
  props: {
    ...createStatefulProps(Boolean, true),
    ...useComponentPresetProp,
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  },
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return { onMouseEnter, onMouseLeave, valueComputed };
  }
});
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-hover",
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ hover: _ctx.valueComputed })))
  ], 32);
}
var _VaHover = _export_sfc(_sfc_main30, [["render", _sfc_render28]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-hover/index.js
var VaHover = withConfigTransport(_VaHover);

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/VaCarousel.js
var _style_028 = ':root,\n:host {\n  --va-carousel-background: var(--va-background-secondary);\n  --va-carousel-border-radius: var(--va-block-border-radius);\n  --va-carousel-box-shadow: var(--va-box-shadow);\n  --va-carousel-slides-transition: all 0.3s ease-in-out;\n  --va-carousel-indicators-gap: 0.25rem;\n  --va-carousel-min-height: 80px;\n  /** Fake padding for absolute position elements */\n  --va-carousel-padding: 16px;\n}\n@keyframes va-carousel-fade-appear {\n0% {\n    opacity: 0;\n}\n100% {\n    opacity: 1;\n}\n}\n.va-carousel {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  max-height: 100%;\n  min-height: var(--va-carousel-min-height);\n  background: var(--va-carousel-background);\n  box-shadow: var(--va-carousel-box-shadow);\n  border-radius: var(--va-carousel-border-radius);\n  position: relative;\n  overflow: hidden;\n}\n.va-carousel__content {\n  flex: 1;\n  width: 100%;\n  white-space: nowrap;\n}\n.va-carousel__slides {\n  width: 100%;\n  height: 100%;\n  transition: var(--va-carousel-slides-transition);\n}\n.va-carousel__slide {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.va-carousel__indicators {\n  width: 100%;\n  position: absolute;\n  bottom: var(--va-carousel-padding);\n  display: flex;\n  justify-content: center;\n  z-index: 2;\n  overflow-x: auto;\n  left: 50%;\n  transform: translateX(-50%);\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n}\n.va-carousel__indicators::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-carousel__indicators::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-carousel__indicators::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n}\n.va-carousel__indicators > * {\n  margin: 0 var(--va-carousel-indicators-gap);\n}\n.va-carousel__arrow {\n  z-index: 1;\n  width: -moz-max-content;\n  width: max-content;\n  height: -moz-max-content;\n  height: max-content;\n}\n.va-carousel__arrow--right {\n  right: var(--va-carousel-padding);\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.va-carousel__arrow--left {\n  left: var(--va-carousel-padding);\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.va-carousel--vertical .va-carousel__slide {\n  display: flex;\n}\n.va-carousel--vertical .va-carousel__arrow {\n  z-index: 1;\n}\n.va-carousel--vertical .va-carousel__arrow--right {\n  bottom: var(--va-carousel-padding);\n  top: auto;\n  left: 50%;\n  transform: translateX(-50%);\n}\n.va-carousel--vertical .va-carousel__arrow--left {\n  top: var(--va-carousel-padding);\n  left: 50%;\n  transform: translateX(-50%);\n}\n.va-carousel--vertical .va-carousel__indicators {\n  left: var(--va-carousel-padding);\n  flex-direction: column;\n  width: auto;\n  height: 100%;\n  top: 50%;\n  transform: translateY(-50%);\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.va-carousel--vertical .va-carousel__indicators > * {\n  margin: var(--va-carousel-indicators-gap) 0;\n}\n.va-carousel .va-image {\n  height: 100%;\n  width: 100%;\n}\n.va-carousel .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var VaImageProps = extractComponentProps(VaImage, ["src", "alt"]);
var _sfc_main31 = defineComponent({
  name: "VaCarousel",
  components: { VaImage, VaButton: VaButton2, VaHover },
  props: {
    ...useSwipeProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...VaImageProps,
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: Number, default: 1e3 },
    autoscrollPauseDuration: { type: Number, default: 2e3 },
    infinite: { type: Boolean, default: false },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" },
    ratio: { type: Number }
  },
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed: currentSlide } = useStateful(props, emit, "modelValue", { defaultValue: 0 });
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton
    } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props, currentSlide);
    const isObjectSlides = computed(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => index === currentSlide.value;
    const slideStyleComputed = computed(() => ({
      animation: props.effect === "fade" ? "fadeKeyframe" : void 0
    }));
    const slidesContainer = shallowRef();
    const onSwipe = (state) => {
      switch (state.direction) {
        case "right":
        case "up":
          doShowPrevButton.value && prev();
          break;
        case "left":
        case "down":
          doShowNextButton.value && next();
      }
    };
    useSwipe(props, slidesContainer, onSwipe);
    return {
      vaImageProps: filterComponentProps(VaImageProps),
      doShowNextButton,
      doShowPrevButton,
      computedSlidesStyle,
      slideStyleComputed,
      goTo: withPause(goTo),
      prev: withPause(prev),
      next: withPause(next),
      slides,
      isObjectSlides,
      isCurrentSlide,
      ...useCarouselColor(),
      ...useTranslation(),
      slidesContainer
    };
  }
});
var _hoisted_114 = ["aria-label"];
var _hoisted_28 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_35 = { class: "va-carousel__content" };
var _hoisted_45 = ["aria-hidden", "aria-current", "aria-label"];
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_hover = resolveComponent("va-hover");
  const _component_va_image = resolveComponent("va-image");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-carousel", {
      "va-carousel--vertical": _ctx.$props.vertical,
      [`va-carousel--${_ctx.$props.effect}`]: true
    }]),
    style: normalizeStyle({ height: _ctx.ratio ? "auto" : _ctx.height }),
    role: "region",
    "aria-label": _ctx.t("carousel")
  }, [
    _ctx.$props.arrows ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.doShowPrevButton ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-carousel__arrow va-carousel__arrow--left",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.prev && _ctx.prev(...args)),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.prev && _ctx.prev(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "va-arrow-up" : "va-arrow-left",
                "aria-label": _ctx.t("goPreviousSlide")
              }, null, 8, ["color", "icon", "aria-label"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true),
      _ctx.doShowNextButton ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-carousel__arrow va-carousel__arrow--right",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.next && _ctx.next(...args)),
        onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.next && _ctx.next(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "next-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "va-arrow-down" : "va-arrow-right",
                "aria-label": _ctx.t("goNextSlide")
              }, null, 8, ["color", "icon", "aria-label"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_28, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
        return openBlock(), createElementBlock("div", mergeProps({
          class: ["va-carousel__indicator", { "va-carousel__indicator--active": index === _ctx.modelValue }],
          key: index
        }, _ctx.indicatorTrigger === "hover" ? { onmouseover: () => _ctx.goTo(index) } : { onclick: () => _ctx.goTo(index) }), [
          renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
            createVNode(_component_va_hover, { stateful: "" }, {
              default: withCtx(({ hover }) => [
                createVNode(_component_va_button, {
                  "aria-label": _ctx.t(`goSlide`, { index: index + 1 }),
                  round: "",
                  color: _ctx.isCurrentSlide(index) ? _ctx.computedActiveColor : hover ? _ctx.computedHoverColor : _ctx.computedColor
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(index + 1), 1)
                  ]),
                  _: 2
                }, 1032, ["aria-label", "color"])
              ]),
              _: 2
            }, 1024)
          ])
        ], 16);
      }), 128))
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_35, [
      createBaseVNode("div", {
        ref: "slidesContainer",
        class: "va-carousel__slides",
        style: normalizeStyle(_ctx.computedSlidesStyle),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.slides, (item, index) => {
          return openBlock(), createElementBlock("div", {
            key: item,
            role: "listitem",
            class: "va-carousel__slide",
            style: normalizeStyle(_ctx.slideStyleComputed),
            "aria-hidden": !_ctx.isCurrentSlide(index),
            "aria-current": _ctx.isCurrentSlide(index),
            "aria-label": _ctx.t("slideOf", { index: index + 1, length: _ctx.slides.length })
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
              createVNode(_component_va_image, mergeProps(_ctx.vaImageProps, {
                src: _ctx.isObjectSlides ? item.src : item,
                alt: _ctx.isObjectSlides ? item.alt : "",
                draggable: false
              }), null, 16, ["src", "alt"])
            ])
          ], 12, _hoisted_45);
        }), 128))
      ], 4)
    ])
  ], 14, _hoisted_114);
}
var _VaCarousel = _export_sfc(_sfc_main31, [["render", _sfc_render29], ["styles", [...VaImage.styles || [], ...VaButton2.styles || [], ...VaHover.styles || [], _style_028]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/index.js
var VaCarousel = withConfigTransport(_VaCarousel);

// node_modules/vuestic-ui/dist/web-components/src/composables/useKeyboardOnlyFocus.js
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked = true;
    },
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useSyncProp.js
function useSyncProp(propName, props, emit, defaultValue) {
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return props[propName] === void 0 ? statefulValue.value : props[propName];
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-form/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/web-components/src/composables/useValidation.js
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString_1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction_1(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  modelValue: { required: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
var useValidationEmits = ["update:error", "update:errorMessages"];
var useValidation = (props, emit, options) => {
  const { reset, focus } = options;
  const { isFocused, onFocus, onBlur } = useFocus();
  let canValidate = true;
  const [computedError] = useSyncProp("error", props, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props, emit, []);
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
  };
  const withoutValidation = (cb) => {
    canValidate = false;
    cb();
  };
  const validate = () => {
    if (!props.rules || !props.rules.length || !canValidate) {
      canValidate = true;
      return true;
    }
    let error = false;
    let errorMessages = [];
    const rules = flatten_1(props.rules);
    normalizeValidationRules(rules, props.modelValue).forEach((validationResult) => {
      if (isString_1(validationResult)) {
        errorMessages = [...errorMessages, validationResult];
        error = true;
      } else if (validationResult === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  watch(isFocused, (newVal) => !newVal && validate());
  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation });
  const context = {
    resetValidation,
    focus,
    validate,
    reset,
    hasError: () => computedError.value
  };
  const form = inject(FormServiceKey, void 0);
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": !!computedErrorMessages.value.length,
    "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
  }));
  onMounted(() => {
    form == null ? void 0 : form.onChildMounted(context);
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.onChildUnmounted(context);
  });
  return {
    computedError,
    computedErrorMessages,
    listeners: { onFocus, onBlur },
    validate,
    resetValidation,
    withoutValidation,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSelectable.js
var useSelectableProps = {
  ...useStatefulProps,
  ...useLoadingProps,
  ...useValidationProps,
  arrayValue: { type: [String, Boolean, Object, Number], default: void 0 },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => withoutValidation(() => {
    emit("update:modelValue", false);
    resetValidation();
  });
  const focus = () => {
    var _a;
    (_a = input.value) == null ? void 0 : _a.focus();
  };
  const {
    computedError,
    computedErrorMessages,
    validate,
    validationAriaAttributes,
    withoutValidation,
    resetValidation
  } = useValidation(props, emit, { reset, focus });
  const { valueComputed } = useStateful(props, emit);
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [label.value, container.value].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      computedError.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== void 0 && props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a;
    if (modelIsArray.value) {
      return (_a = props.modelValue) == null ? void 0 : _a.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/components/VaMessageList/VaMessageList.js
var _style_029 = ".va-message-list {\n  margin-top: var(--va-message-list-margin-top);\n  color: var(--va-message-list-color);\n}\n.va-message-list__message {\n  display: flex;\n  vertical-align: var(--va-message-list-vertical-align);\n  font-size: var(--va-message-list-font-size);\n  line-height: var(--va-message-list-line-height);\n}\n.va-message-list__icon {\n  margin-right: var(--va-message-list-icon-margin-right);\n}";
var _sfc_main32 = defineComponent({
  name: "VaMessageList",
  components: { VaIcon: VaIcon2 },
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: Number, default: 1 },
    color: { type: String },
    hasError: { type: Boolean, default: false }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      messages: computed(() => {
        if (!props.modelValue) {
          return [];
        }
        if (!Array.isArray(props.modelValue)) {
          return [props.modelValue];
        }
        return props.modelValue.slice(0, props.limit);
      }),
      computedStyle: computed(() => props.color ? { color: getColor(props.color) } : {})
    };
  }
});
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.messages.length ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-message-list",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.messages, (message, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: "va-message-list__message"
      }, [
        _ctx.hasError ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-message-list__icon",
          name: "va-warning",
          size: 16
        })) : createCommentVNode("", true),
        createTextVNode(toDisplayString(message), 1)
      ]);
    }), 128))
  ], 4)) : createCommentVNode("", true);
}
var _VaMessageList = _export_sfc(_sfc_main32, [["render", _sfc_render30], ["styles", [...VaIcon2.styles || [], _style_029]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/components/VaMessageList/index.js
var VaMessageList = withConfigTransport(_VaMessageList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/components/VaMessageListWrapper.js
var _style_030 = ".va-message-list-wrapper {\n  font-family: var(--va-font-family);\n}";
var _sfc_main33 = defineComponent({
  name: "VaMessageListWrapper",
  components: { VaMessageList },
  props: {
    ...useValidationProps
  },
  setup(props) {
    return {
      messagesColor: computed(() => {
        if (props.error) {
          return "danger";
        }
        if (props.success) {
          return "success";
        }
        return "";
      }),
      hasError: toRef(props, "error"),
      messagesComputed: computed(() => props.error ? props.errorMessages : props.messages),
      errorLimit: computed(() => props.error ? Number(props.errorCount) : 99)
    };
  }
});
var _hoisted_115 = { class: "va-message-list-wrapper" };
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", _hoisted_115, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_va_message_list, {
      color: _ctx.messagesColor,
      limit: _ctx.errorLimit,
      "has-error": _ctx.hasError,
      "model-value": _ctx.messagesComputed
    }, null, 8, ["color", "limit", "has-error", "model-value"])
  ]);
}
var VaMessageListWrapper = _export_sfc(_sfc_main33, [["render", _sfc_render31], ["styles", [...VaMessageList.styles || [], _style_030]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-checkbox/VaCheckbox.js
var _style_031 = ":root,\n:host {\n  --va-checkbox-display: inline-block;\n  --va-checkbox-input-padding: 0;\n  --va-checkbox-input-cursor: pointer;\n  --va-checkbox-disabled-cursor: default;\n  --va-checkbox-readonly-cursor: initial;\n  --va-checkbox-label-display: inline-block;\n  --va-checkbox-font-size: 15px;\n  --va-checkbox-line-height: 20px;\n  /* Square */\n  --va-checkbox-square-width: 1.35rem;\n  --va-checkbox-square-min-width: 1.35rem;\n  --va-checkbox-square-height: 1.35rem;\n  --va-checkbox-square-background-color: var(--va-background-element);\n  --va-checkbox-square-border: solid 0.125rem var(--va-background-border);\n  --va-checkbox-square-border-radius: 0.25rem;\n}\n.va-checkbox {\n  display: var(--va-checkbox-display);\n  max-width: -moz-fit-content;\n  max-width: fit-content;\n  font-family: var(--va-font-family);\n}\n.va-checkbox__input-container {\n  align-items: center;\n  display: flex;\n  padding: var(--va-checkbox-input-padding);\n  cursor: var(--va-checkbox-input-cursor);\n  font-size: var(--va-checkbox-font-size);\n  line-height: var(--va-checkbox-line-height);\n}\n.va-checkbox--disabled .va-checkbox__input-container {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  cursor: var(--va-checkbox-disabled-cursor);\n}\n.va-checkbox--readonly .va-checkbox__input-container {\n  cursor: var(--va-checkbox-readonly-cursor);\n}\n.va-checkbox--left-label .va-checkbox__input-container {\n  flex-direction: row-reverse;\n}\n.va-checkbox .va-checkbox__square {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: var(--va-checkbox-square-width);\n  min-width: var(--va-checkbox-square-min-width);\n  height: var(--va-checkbox-square-height);\n  position: relative;\n  background-color: var(--va-checkbox-square-background-color);\n  border: var(--va-checkbox-square-border, var(--va-control-border));\n  border-radius: var(--va-checkbox-square-border-radius);\n}\n.va-checkbox--on-keyboard-focus.va-checkbox .va-checkbox__square {\n  transition: all, 0.6s, ease-in;\n  outline: 2px solid var(--va-focus);\n}\n.va-checkbox__input {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n  white-space: nowrap;\n  -webkit-clip-path: inset(100%);\n          clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}\n.va-checkbox__label {\n  display: var(--va-checkbox-label-display);\n  position: relative;\n}\n.va-checkbox__icon {\n  pointer-events: none;\n  position: absolute;\n}\n.va-checkbox--selected .va-checkbox__icon {\n  color: var(--va-checkbox-selected-icon-color);\n}\n.va-checkbox--indeterminate .va-checkbox__icon {\n  color: var(--va-checkbox-indeterminate-icon-color);\n}";
var VaCheckboxValueType = [Boolean, Array, String, Object];
var _sfc_main34 = defineComponent({
  name: "VaCheckbox",
  components: { VaMessageListWrapper, VaIcon: VaIcon2 },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 }
  },
  setup(props, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor();
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : "",
        padding: !props.label ? "" : props.leftLabel ? "0 0.5rem 0 0" : "0 0 0 0.5rem"
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const computedIconName = computed(
      () => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon
    );
    const uniqueId2 = computed(generateUniqueId);
    const computedId = computed(() => props.id || uniqueId2.value);
    const computedName = computed(() => props.name || uniqueId2.value);
    const inputAttributesComputed = computed(() => ({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      "aria-label": props.ariaLabel,
      "aria-disabled": props.disabled,
      "aria-readOnly": props.readonly,
      "aria-checked": isActive.value,
      ...validationAriaAttributes.value
    }));
    return {
      isActive,
      computedClass,
      labelStyle,
      inputStyle,
      computedIconName,
      textColorComputed,
      computedError,
      computedErrorMessages,
      keyboardFocusListeners,
      toggleSelection,
      onBlur,
      onFocus,
      inputAttributesComputed,
      computedId,
      computedName
    };
  }
});
var _hoisted_116 = ["id", "indeterminate", "value", "checked"];
var _hoisted_29 = ["for"];
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-checkbox", _ctx.computedClass]),
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-checkbox__input-container",
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-checkbox__square",
          style: normalizeStyle(_ctx.inputStyle),
          onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-checkbox__input",
            id: _ctx.computedId,
            indeterminate: _ctx.indeterminate,
            value: _ctx.label,
            checked: _ctx.isActive
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop", "prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]))
          }), null, 16, _hoisted_116),
          withDirectives(createVNode(_component_va_icon, {
            class: "va-checkbox__icon",
            size: "20px",
            name: _ctx.computedIconName,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"]), [
            [vShow, _ctx.isActive]
          ])
        ], 36),
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          ref: "label",
          class: "va-checkbox__label",
          for: _ctx.computedId,
          style: normalizeStyle(_ctx.labelStyle),
          onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 44, _hoisted_29)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaCheckbox = _export_sfc(_sfc_main34, [["render", _sfc_render32], ["styles", [...VaMessageListWrapper.styles || [], ...VaIcon2.styles || [], _style_031]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-checkbox/index.js
var VaCheckbox = withConfigTransport(_VaCheckbox);

// node_modules/vuestic-ui/dist/web-components/src/components/va-chip/VaChip.js
var _style_032 = ":root,\n:host {\n  --va-chip-display: inline-flex;\n  --va-chip-border: 0.125rem solid transparent;\n  --va-chip-position: relative;\n  --va-chip-border-radius: 2rem;\n  --va-chip-width: auto;\n  --va-chip-height: auto;\n  --va-chip-min-width: initial;\n  --va-chip-min-height: initial;\n  --va-chip-padding: 0 0.3rem;\n  --va-chip-color: #ffffff;\n  --va-chip-cursor: default;\n  --va-chip-font-size: 1rem;\n  --va-chip-vertical-align: middle;\n  --va-chip-inner-display: inline-flex;\n  --va-chip-inner-align-items: center;\n  --va-chip-inner-width: 100%;\n  --va-chip-hover-opacity: 0.85;\n  --va-chip-content-display: flex;\n  --va-chip-content-width: var(--va-chip-inner-width, 100%);\n  --va-chip-content-align-items: center;\n  --va-chip-content-justify-content: center;\n  --va-chip-content-padding: 0 0.3rem;\n  --va-chip-content-line-height: 1.6;\n  /* Square */\n  --va-chip-square-border-radius: 0.2rem;\n  /* Small */\n  --va-chip-sm-height: 1.5rem;\n  --va-chip-sm-font-size: 0.875rem;\n  /* Large */\n  --va-chip-lg-height: 2.5rem;\n  --va-chip-lg-font-size: 1.25rem;\n}\n.va-chip {\n  display: var(--va-chip-display);\n  border: var(--va-chip-border, var(--va-control-border));\n  position: var(--va-chip-position);\n  border-radius: var(--va-chip-border-radius);\n  width: var(--va-chip-width);\n  height: var(--va-chip-height);\n  min-width: var(--va-chip-min-width);\n  min-height: var(--va-chip-min-height);\n  padding: var(--va-chip-padding);\n  color: var(--va-chip-color);\n  cursor: var(--va-chip-cursor);\n  font-size: var(--va-chip-font-size);\n  font-family: var(--va-font-family);\n  vertical-align: var(--va-chip-vertical-align);\n}\n.va-chip__inner {\n  display: var(--va-chip-inner-display);\n  align-items: var(--va-chip-inner-align-items);\n  width: var(--va-chip-inner-width);\n  vertical-align: inherit;\n}\n.va-chip:hover:not(.va-chip--readonly) {\n  opacity: var(--va-chip-hover-opacity);\n}\n.va-chip__content {\n  display: var(--va-chip-content-display);\n  justify-content: var(--va-chip-content-justify-content);\n  align-items: var(--va-chip-content-align-items);\n  padding: var(--va-chip-content-padding);\n  line-height: var(--va-chip-content-line-height);\n  width: var(--va-chip-content-width);\n}\n.va-chip__close-icon {\n  cursor: pointer;\n}\n.va-chip--disabled .va-chip__close-icon {\n  cursor: default !important;\n}\n.va-chip--square {\n  border-radius: var(--va-chip-square-border-radius, var(--va-square-border-radius));\n}\n.va-chip--small {\n  height: var(--va-chip-sm-height);\n  font-size: var(--va-chip-sm-font-size);\n}\n.va-chip--large {\n  height: var(--va-chip-lg-height);\n  font-size: var(--va-chip-lg-font-size);\n}\n.va-chip.va-chip--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}";
var _sfc_main35 = defineComponent({
  name: "VaChip",
  components: { VaIcon: VaIcon2 },
  emits: [...useStatefulEmits, "focus"],
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
    const size = {
      small: "0.875rem",
      medium: "1rem",
      large: "1.25rem"
    };
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    return {
      ...useTranslation(),
      keyboardFocusListeners,
      valueComputed,
      hrefComputed,
      tagComputed,
      onMouseEnter,
      onMouseLeave,
      isHovered,
      close: () => {
        if (!props.disabled) {
          valueComputed.value = false;
        }
      },
      iconSize: computed(() => size[props.size]),
      tabIndexComputed: computed(() => props.disabled ? -1 : 0),
      computedClass: useBem("va-chip", () => ({
        ...pick_1(props, ["disabled", "readonly", "square"]),
        small: props.size === "small",
        large: props.size === "large"
      })),
      computedStyle: computed(() => {
        const result = {
          color: textColorComputed.value,
          borderColor: borderColor.value,
          background: "",
          boxShadow: shadowStyle.value
        };
        if (props.outline || props.flat) {
          if (hasKeyboardFocus.value) {
            result.background = getFocusColor(colorComputed.value);
          } else if (!props.readonly && isHovered.value) {
            result.background = getHoverColor(colorComputed.value);
          }
        } else {
          result.background = colorComputed.value;
        }
        return result;
      })
    };
  }
});
var _hoisted_117 = { class: "va-chip__content" };
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    key: 0,
    class: normalizeClass(["va-chip", _ctx.computedClass]),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle)
  }, {
    default: withCtx(() => [
      createBaseVNode("span", mergeProps({
        class: "va-chip__inner",
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
      }, toHandlers(_ctx.keyboardFocusListeners)), [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-chip__icon",
          name: _ctx.icon,
          size: _ctx.iconSize
        }, null, 8, ["name", "size"])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_117, [
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.closeable ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          role: "button",
          name: "va-close",
          class: "va-chip__close-icon",
          "aria-label": _ctx.t("close"),
          tabindex: _ctx.tabIndexComputed,
          size: _ctx.iconSize,
          onClick: withModifiers(_ctx.close, ["stop"]),
          onKeydown: [
            withKeys(withModifiers(_ctx.close, ["stop"]), ["enter"]),
            withKeys(withModifiers(_ctx.close, ["stop"]), ["space"])
          ]
        }, null, 8, ["aria-label", "tabindex", "size", "onClick", "onKeydown"])) : createCommentVNode("", true)
      ], 16)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("", true);
}
var _VaChip = _export_sfc(_sfc_main35, [["render", _sfc_render33], ["styles", [...VaIcon2.styles || [], _style_032]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-chip/index.js
var VaChip = withConfigTransport(_VaChip);

// node_modules/vuestic-ui/dist/web-components/src/composables/useResizeObserver.js
var useResizeObserver = (elementsList, cb) => {
  const resizeObserver = ref();
  const observeAll = (elementsList2) => {
    elementsList2.forEach((element) => {
      var _a;
      const unrefedElement = unref(element);
      unrefedElement && ((_a = resizeObserver.value) == null ? void 0 : _a.observe(unrefedElement));
    });
  };
  watch(elementsList, (newValue) => {
    var _a;
    (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
    observeAll(newValue);
  });
  onMounted(() => {
    resizeObserver.value = new ResizeObserver(cb);
    observeAll(elementsList);
  });
  onBeforeUnmount(() => {
    var _a;
    return (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
  });
  return resizeObserver;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-collapse/VaCollapse.js
var _style_033 = ":root,\n:host {\n  --va-collapse-transition: all 0.3s linear;\n  --va-collapse-popout-margin: 0.5rem -0.5rem;\n  --va-collapse-inset-margin: 0.5rem 0.5rem;\n  --va-collapse-body-wrapper-transition: all 0.3s linear;\n  --va-collapse-body-width: 100%;\n  --va-collapse-header-content-display: flex;\n  --va-collapse-header-content-justify-content: space-between;\n  --va-collapse-header-content-cursor: pointer;\n  --va-collapse-header-content-background-color: #f5f8f9;\n  --va-collapse-header-content-box-shadow: var(--va-box-shadow);\n  --va-collapse-header-content-border-radius: 0.375rem;\n  --va-collapse-header-content-align-items: center;\n  --va-collapse-header-content-padding-top: 0.75rem;\n  --va-collapse-header-content-padding-bottom: 0.75rem;\n  --va-collapse-header-content-padding-left: 1rem;\n  --va-collapse-header-content-text-width: 100%;\n  --va-collapse-header-content-text-font-weight: 600;\n  --va-collapse-header-content-icon-min-width: 1.5rem;\n  --va-collapse-header-content-icon-margin-left: 0.5rem;\n  --va-collapse-header-content-icon-margin-right: 0.5rem;\n  --va-collapse-header-content-icon-color: var(--va-background-element);\n  /* Solid */\n  --va-collapse-solid-box-shadow: var(--va-box-shadow);\n  --va-collapse-solid-border-radius: 0.375rem;\n  --va-collapse-solid-header-content-background-color: #f5f8f9;\n  --va-collapse-solid-header-content-box-shadow: none;\n  --va-collapse-solid-header-content-border-radius: 0.375rem;\n  --va-collapse-solid-header-content-transition: background-color ease-in 0.3s;\n  --va-collapse-solid-body-border-radius: 0 0 0.375rem 0.375rem;\n  --va-collapse-solid-body-margin-top: 0;\n}\n.va-collapse {\n  transition: var(--va-collapse-transition, var(--va-swing-transition));\n  font-family: var(--va-font-family);\n}\n.va-collapse__body-wrapper {\n  transition: var(--va-collapse-body-wrapper-transition);\n  overflow: hidden;\n}\n.va-collapse__body {\n  top: 0;\n  left: 0;\n  width: var(--va-collapse-body-width);\n}\n.va-collapse__header {\n  display: var(--va-collapse-header-content-display);\n  justify-content: var(--va-collapse-header-content-justify-content);\n  cursor: var(--va-collapse-header-content-cursor);\n  background-color: var(--va-collapse-header-content-background-color);\n  box-shadow: var(--va-collapse-header-content-box-shadow, var(--va-block-box-shadow));\n  border-radius: var(--va-collapse-header-content-border-radius, var(--va-block-border-radius));\n  align-items: var(--va-collapse-header-content-align-items);\n  padding-top: var(--va-collapse-header-content-padding-top);\n  padding-bottom: var(--va-collapse-header-content-padding-bottom);\n  padding-left: var(--va-collapse-header-content-padding-left);\n}\n.va-collapse__header__text {\n  width: var(--va-collapse-header-content-text-width);\n  font-weight: var(--va-collapse-header-content-text-font-weight);\n}\n.va-collapse__header__icon {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: var(--va-collapse-header-content-icon-min-width);\n  margin-left: var(--va-collapse-header-content-icon-margin-left);\n  margin-right: var(--va-collapse-header-content-icon-margin-right);\n  color: var(--va-collapse-header-content-icon-color);\n}\n.va-collapse__header:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: var(--va-collapse-header-content-border-radius);\n}\n.va-collapse--solid {\n  box-shadow: var(--va-collapse-solid-box-shadow);\n  border-radius: var(--va-collapse-solid-border-radius);\n}\n.va-collapse--solid .va-collapse__header {\n  border-radius: var(--va-collapse-solid-header-content-border-radius, var(--va-block-border-radius));\n  transition: var(--va-collapse-solid-header-content-transition);\n  box-shadow: var(--va-collapse-solid-header-content-box-shadow, var(--va-block-box-shadow));\n  background-color: var(--va-collapse-solid-header-content-background-color);\n}\n.va-collapse--solid .va-collapse__body-wrapper {\n  border-radius: var(--va-collapse-solid-border-radius);\n}\n.va-collapse--solid .va-collapse__body {\n  border-radius: var(--va-collapse-solid-body-border-radius);\n  margin-top: var(--va-collapse-solid-body-margin-top);\n}\n.va-collapse--popout {\n  margin: var(--va-collapse-popout-margin);\n}\n.va-collapse--inset {\n  margin: var(--va-collapse-inset-margin);\n}\n.va-collapse--flat .va-collapse__header {\n  --va-collapse-solid-header-content-border-radius: 0;\n  --va-collapse-header-content-box-shadow: none;\n}\n.va-collapse--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}";
var _sfc_main36 = defineComponent({
  name: "VaCollapse",
  components: {
    VaIcon: VaIcon2
  },
  props: {
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    solid: { type: Boolean, default: false },
    color: { type: String, default: "background-element" },
    textColor: { type: String, default: "" },
    colorAll: { type: Boolean, default: false },
    flat: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(props, { emit, slots }) {
    const body = shallowRef();
    const [computedModelValue] = useSyncProp("modelValue", props, emit, false);
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { accordionProps, toggle } = useAccordionItem(computedModelValue);
    const { textColorComputed } = useTextColor();
    const bodyHeight = ref();
    useResizeObserver([body], () => {
      var _a, _b;
      bodyHeight.value = (_b = (_a = body.value) == null ? void 0 : _a.clientHeight) != null ? _b : 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const getBackground = () => {
      return props.color && props.colorAll ? getHoverColor2(getColor(props.color)) : "";
    };
    const uniqueId2 = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId2.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId2.value}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const computedClasses = useBem("va-collapse", () => ({
      ...pick_1(props, ["disabled", "solid", "flat"]),
      expanded: computedModelValue.value,
      active: props.solid && computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value)
    }));
    return {
      body,
      height,
      toggle,
      computedModelValue,
      headerIdComputed,
      headerAttributes,
      panelIdComputed,
      tabIndexComputed,
      textColorComputed,
      computedClasses,
      headerStyle: computed(() => ({
        paddingLeft: props.icon && 0,
        color: textColorComputed.value,
        backgroundColor: props.color ? getColor(props.color) : ""
      })),
      contentStyle: computed(() => {
        return {
          visibility: computedModelValue.value ? "visible" : "hidden",
          height: `${height.value}px`,
          transitionDuration: getTransition(),
          background: computedModelValue.value ? getBackground() : ""
        };
      })
    };
  }
});
var _hoisted_118 = { class: "va-collapse__header__text" };
var _hoisted_210 = ["id", "aria-labelledby"];
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-collapse", _ctx.computedClasses])
  }, [
    createBaseVNode("div", {
      class: "va-collapse__header-wrapper",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args)),
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["enter"])),
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["space"]))
      ]
    }, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({
        value: _ctx.computedModelValue,
        bind: _ctx.headerAttributes,
        attributes: _ctx.headerAttributes
      })), () => [
        createBaseVNode("div", mergeProps(_ctx.headerAttributes, {
          class: "va-collapse__header",
          style: _ctx.headerStyle
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-collapse__header__icon",
            name: _ctx.icon,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "header-content", normalizeProps(guardReactiveProps({ header: _ctx.header })), () => [
            createBaseVNode("div", _hoisted_118, toDisplayString(_ctx.header), 1)
          ]),
          createVNode(_component_va_icon, {
            class: "va-collapse__header__icon",
            name: _ctx.computedModelValue ? "va-arrow-up" : "va-arrow-down",
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])
        ], 16)
      ])
    ], 32),
    createBaseVNode("div", {
      class: "va-collapse__body-wrapper",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      createBaseVNode("div", {
        class: "va-collapse__body",
        ref: "body",
        role: "region",
        id: _ctx.panelIdComputed,
        "aria-labelledby": _ctx.headerIdComputed
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, _hoisted_210)
    ], 4)
  ], 2);
}
var _VaCollapse = _export_sfc(_sfc_main36, [["render", _sfc_render34], ["styles", [...VaIcon2.styles || [], _style_033]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-collapse/index.js
var VaCollapse = withConfigTransport(_VaCollapse);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-indicator/VaColorIndicator.js
var _style_034 = ".va-color-indicator {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  border-radius: var(--83ba3c2e);\n  text-align: center;\n  background-color: var(--va-background-element);\n  border: 0.125rem solid var(--va-background-border);\n  box-sizing: content-box;\n}\n.va-color-indicator__core {\n  border-radius: var(--83ba3c2e);\n  height: 1rem;\n  width: 1rem;\n}\n.va-color-indicator--selected {\n  background-color: var(--va-primary);\n  border-color: var(--va-primary);\n}\n.va-color-indicator--on-keyboard-focus {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: var(--83ba3c2e);\n}";
var __default__6 = defineComponent({
  name: "VaColorIndicator",
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false },
    size: { type: String, default: "1rem" }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const colorComputed = computed(() => getColor(props.color));
    const borderRadiusComputed = computed(() => props.square ? "0px" : "50%");
    const computedStyle = computed(() => ({
      backgroundColor: colorComputed.value,
      height: props.size,
      width: props.size
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return {
      valueComputed,
      computedStyle,
      computedClass,
      borderRadiusComputed,
      keyboardFocusListeners,
      toggleModelValue
    };
  }
});
var __injectCSSVars__6 = () => {
  useCssVars((_ctx) => ({
    "83ba3c2e": _ctx.borderRadiusComputed
  }));
};
var __setup__6 = __default__6.setup;
__default__6.setup = __setup__6 ? (props, ctx) => {
  __injectCSSVars__6();
  return __setup__6(props, ctx);
} : __injectCSSVars__6;
var _sfc_main37 = __default__6;
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-color-indicator", _ctx.computedClass],
    style: _ctx.computedStyle,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args)),
    onKeydown: [
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["enter"])),
      _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["space"]))
    ]
  }, toHandlers(_ctx.keyboardFocusListeners)), [
    createBaseVNode("div", {
      class: "va-color-indicator__core",
      style: normalizeStyle(_ctx.computedStyle)
    }, null, 4)
  ], 16);
}
var _VaColorIndicatort = _export_sfc(_sfc_main37, [["render", _sfc_render35], ["styles", [_style_034]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-indicator/index.js
var VaColorIndicator = withConfigTransport(_VaColorIndicatort);

// node_modules/vuestic-ui/dist/web-components/src/composables/useClearable.js
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "va-clear" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "small"
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useCurrentElement.js
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  onUpdated(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  onBeforeUnmount(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  return currentEl;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFocusDeep.js
var useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  return computed({
    get() {
      var _a;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused = (_a = current.value) == null ? void 0 : _a.contains(focused.value);
      if (isFocused) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused;
    },
    set(value) {
      var _a;
      let target = previouslyFocusedElement != null ? previouslyFocusedElement : current.value;
      if (!((_a = current.value) == null ? void 0 : _a.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useForm.js
var useFormProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useForm = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed(() => pick_1(props, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/hooks/useCleave.js
var DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
var useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true },
  modelValue: { type: [String, Number], default: "" }
};
var useCleave = (element, props, emit) => {
  const cleave = ref();
  const getMask = (mask) => {
    if (typeof mask === "string") {
      return DEFAULT_MASK_TOKENS[mask] ? { ...DEFAULT_MASK_TOKENS[mask] } : {};
    }
    return { ...mask };
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const initCleave = () => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    cleave.value = new cleave_esm_default(element.value, getMask(props.mask));
  };
  onMounted(() => {
    initCleave();
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  watch(() => [element.value, props.mask], () => {
    initCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return props.modelValue;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (props.mask !== "string" && !Object.keys(props.mask).length) {
      emit("update:modelValue", value);
      return;
    }
    if (cleave.value) {
      cleave.value.setRawValue(value);
      if (props.returnRaw) {
        emit("update:modelValue", cleave.value.getRawValue());
        return;
      }
      emit("update:modelValue", cleave.value.getFormattedValue());
      return;
    }
    emit("update:modelValue", value);
  };
  return {
    cleave,
    computedValue,
    onInput
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useCSSVariables.js
var useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).map(([key, value]) => ({ [`--${prefix2}-${kebabCase_1(key)}`]: value })));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/components/VaInputWrapper/VaInputWrapper.js
var _style_035 = ':root,\n:host {\n  --va-input-color: var(--va-background-element);\n  --va-input-scroll-color: var(--va-background-secondary, #e1e9f8);\n  --va-input-bordered-color: var(--va-background-border, #e1e9f8);\n  --va-input-border-width: 1px;\n  --va-input-border-radius: 4px;\n  --va-input-min-height: 36px;\n  --va-input-cursor: text;\n  --va-input-opacity: 0.1;\n  /* MessageList */\n  --va-message-list-margin-top: 4px;\n  --va-message-list-vertical-align: middle;\n  --va-message-list-color: var(--va-secondary);\n  --va-message-list-font-size: 13px;\n  --va-message-list-line-height: 16px;\n  --va-message-list-icon-font-size: 16px;\n  --va-message-list-icon-margin-right: 4px;\n  /* Success */\n  --va-input-success-color: var(--va-success);\n  /* Error */\n  --va-input-error-color: var(--va-danger);\n  /* Content Wrapper */\n  --va-input-content-horizontal-padding: 12px;\n  --va-input-content-items-gap: 6px;\n  /* Input&Textarea */\n  --va-input-line-height: 20px;\n  --va-input-font-size: 1rem;\n  --va-input-font-weight: normal;\n  --va-input-font-style: normal;\n  --va-input-font-stretch: normal;\n  --va-input-letter-spacing: normal;\n  --va-input-disabled-opacity: 0.4;\n  /* Label */\n  --va-input-container-label-max-width: calc(100% - 0.75rem);\n  --va-input-container-label-font-size: 0.6rem;\n  --va-input-container-label-letter-spacing: 0.0375rem;\n  --va-input-container-label-line-height: 1.2;\n  --va-input-container-label-font-weight: 700;\n  --va-input-container-label-text-transform: uppercase;\n  --va-input-container-label-transform-origin: top left;\n}\n:root,\n:host {\n  --va-input-wrapper-color: var(--va-primary);\n  --va-input-wrapper-background: var(--va-background-element, #f5f9fb);\n  --va-input-wrapper-background-opacity: 1;\n  --va-input-wrapper-border-color: var(--va-input-bordered-color, --va-background-border);\n  --va-input-wrapper-min-width: var(--va-form-element-min-width);\n  --va-input-wrapper-display: inline-block;\n  --va-input-wrapper-vertical-align: middle;\n  /* Counter container */\n  --va-input-wrapper-bottom-display: flex;\n  --va-input-wrapper-bottom-align-items: center;\n  --va-input-wrapper-bottom-line-height: 1.5;\n  --va-input-wrapper-bottom-font-size: 0.8rem;\n  --va-input-wrapper-bottom-color: var(--va-secondary);\n  /* Counter */\n  --va-input-wrapper-counter-flex: 0 0 auto;\n  --va-input-wrapper-counter-margin-left: auto;\n  --va-input-wrapper-counter-color: var(--va-secondary);\n}\n.va-input-wrapper {\n  --va-input-wrapper-background: var(--a310421c);\n  position: relative;\n  cursor: var(--va-input-cursor);\n  font-family: var(--va-font-family);\n  display: var(--va-input-wrapper-display);\n  vertical-align: var(--va-input-wrapper-vertical-align);\n  min-width: var(--va-input-wrapper-min-width);\n  max-width: 100%;\n  flex: 1;\n}\n.va-input-wrapper__field {\n  position: relative;\n  display: flex;\n  align-items: center;\n  flex: 1;\n  min-height: var(--va-input-min-height);\n  width: var(--va-form-element-default-width);\n  border-color: var(--va-input-wrapper-border-color);\n  border-style: solid;\n  border-width: var(--va-input-border-width);\n  padding: 0 var(--va-input-content-horizontal-padding);\n  z-index: 0;\n  overflow: hidden;\n  z-index: 0;\n  z-index: 0;\n}\n.va-input-wrapper__field::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-input-color);\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-input-wrapper__field input,\n.va-input-wrapper__field textarea {\n  color: var(--cf315028);\n}\n.va-input-wrapper__field::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-input-wrapper-background);\n  opacity: var(--va-input-wrapper-background-opacity);\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-input-wrapper__container {\n  display: flex;\n  align-items: center;\n}\n.va-input-wrapper__field > *, .va-input-wrapper__container > * {\n  margin-right: var(--va-input-content-items-gap);\n}\n.va-input-wrapper__field > *:last-child, .va-input-wrapper__container > *:last-child {\n  margin-right: 0;\n}\n.va-input-wrapper > .va-message-list {\n  margin-top: 2px;\n}\n.va-input-wrapper__prepend-inner, .va-input-wrapper__append-inner {\n  display: flex;\n  justify-content: center;\n  align-content: center;\n  align-items: center;\n}\n.va-input-wrapper__text {\n  width: 100%;\n  position: relative;\n  min-height: var(--va-input-line-height);\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n}\n.va-input-wrapper__text input,\n.va-input-wrapper__text textarea {\n  scrollbar-color: var(--va-input-scroll-color) transparent;\n  scrollbar-width: thin;\n  width: 100%;\n  min-height: var(--va-input-line-height);\n  background-color: transparent;\n  border-style: none;\n  outline: none;\n  line-height: var(--va-input-line-height);\n  font-size: var(--va-input-font-size);\n  font-family: inherit;\n  font-weight: var(--va-input-font-weight);\n  font-style: var(--va-input-font-style);\n  font-stretch: var(--va-input-font-stretch);\n  letter-spacing: var(--va-input-letter-spacing);\n  transform: translateY(-1px);\n  cursor: inherit;\n}\n.va-input-wrapper__text input::-webkit-scrollbar,\n.va-input-wrapper__text textarea::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-input-wrapper__text input::-webkit-scrollbar-track,\n.va-input-wrapper__text textarea::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-input-wrapper__text input::-webkit-scrollbar-thumb,\n.va-input-wrapper__text textarea::-webkit-scrollbar-thumb {\n  background: var(--va-input-scroll-color);\n  opacity: 0.3;\n  border-radius: 2px;\n}\n.va-input-wrapper__text input::-webkit-scrollbar,\n.va-input-wrapper__text textarea::-webkit-scrollbar {\n  width: 10px;\n}\n.va-input-wrapper__text input::-moz-placeholder, .va-input-wrapper__text textarea::-moz-placeholder {\n  color: inherit;\n  opacity: 0.5;\n}\n.va-input-wrapper__text input::placeholder,\n.va-input-wrapper__text textarea::placeholder {\n  color: inherit;\n  opacity: 0.5;\n}\n.va-input-wrapper__icons {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.va-input-wrapper__icons__reset:focus {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-input-wrapper__required-mark {\n  transform: translate(0, -2px);\n  color: var(--va-danger);\n  font-size: 18px;\n  font-weight: var(--va-input-container-label-font-weight);\n}\n.va-input-wrapper__bottom {\n  display: var(--va-input-wrapper-bottom-display);\n  align-items: var(--va-input-wrapper-bottom-align-items);\n  color: var(--va-input-wrapper-bottom-color);\n  font-size: var(--va-input-wrapper-bottom-font-size);\n  line-height: var(--va-input-wrapper-bottom-line-height);\n}\n.va-input-wrapper__bottom-counter {\n  color: var(--va-input-wrapper-counter-color);\n  flex: var(--va-input-wrapper-counter-flex);\n  margin-left: var(--va-input-wrapper-counter-margin-left);\n}\n.va-input-wrapper textarea {\n  margin: 12px 0;\n  resize: vertical;\n}\n.va-input-wrapper--labeled .va-input-wrapper__text {\n  height: 100%;\n  padding-top: 12px;\n  box-sizing: content-box;\n}\n.va-input-wrapper--labeled .va-input-wrapper__label {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  height: 12px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  display: flex;\n  padding-top: 1px;\n  max-width: var(--va-input-container-label-max-width);\n  font-size: var(--va-input-container-label-font-size);\n  letter-spacing: var(--va-input-container-label-letter-spacing, var(--va-letter-spacing));\n  line-height: var(--va-input-container-label-line-height);\n  font-weight: var(--va-input-container-label-font-weight);\n  text-transform: var(--va-input-container-label-text-transform);\n  transform-origin: top left;\n}\n.va-input-wrapper--labeled textarea {\n  margin-top: 0;\n}\n.va-input-wrapper--solid {\n  --va-input-wrapper-border-color: var(--va-input-color);\n}\n.va-input-wrapper--solid .va-input-wrapper__field {\n  border-radius: var(--va-input-border-radius);\n}\n.va-input-wrapper--outline .va-input-wrapper__field {\n  border-radius: 0;\n}\n.va-input-wrapper--bordered::after {\n  content: "";\n  border-color: var(--va-input-wrapper-border-color);\n  position: absolute;\n  height: 0;\n  border-bottom-width: var(--va-input-border-width);\n  border-bottom-style: solid;\n  width: 100%;\n  bottom: 0;\n}\n.va-input-wrapper--bordered .va-input-wrapper__field {\n  border-top-left-radius: var(--va-input-border-radius);\n  border-top-right-radius: var(--va-input-border-radius);\n  border-color: transparent !important;\n}\n.va-input-wrapper--error {\n  --va-input-wrapper-border-color: var(--va-input-error-color, --va-danger);\n  --va-input-wrapper-background: var(--va-input-error-color, --va-danger);\n  --va-input-wrapper-background-opacity: var(--va-input-opacity);\n}\n.va-input-wrapper--success {\n  --va-input-wrapper-border-color: var(--va-input-success-color, --va-success);\n  --va-input-wrapper-background: var(--va-input-success-color, --va-success);\n  --va-input-wrapper-background-opacity: var(--va-input-opacity);\n}\n.va-input-wrapper--focused {\n  --va-input-wrapper-border-color: var(--va-input-wrapper-color);\n}\n.va-input-wrapper--readonly {\n  cursor: default;\n}\n.va-input-wrapper--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}';
var __default__7 = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList, VaIcon: VaIcon2 },
  props: {
    ...useFormProps,
    ...useValidationProps,
    counterValue: { type: Number, default: void 0 },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String, default: "background-element" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    error: { type: Boolean, default: false },
    success: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner"
  ],
  setup(props) {
    const { getColor } = useColors();
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick_1(props, ["outline", "bordered", "success", "focused", "error", "disabled", "readonly"]),
      labeled: !!props.label,
      solid: !props.outline && !props.bordered
    }));
    const wrapperStyle = useCSSVariables("va-input-wrapper", () => ({
      color: colorComputed.value
    }));
    const colorComputed = computed(() => getColor(props.color));
    const backgroundComputed = computed(() => getColor(props.background));
    const borderColorComputed = computed(() => props.focused ? colorComputed.value : void 0);
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const hasMessages = computed(() => {
      var _a;
      return Boolean(
        typeof messagesComputed.value === "string" ? messagesComputed.value : (_a = messagesComputed.value) == null ? void 0 : _a.length
      );
    });
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const containerStyle = computed(() => ({
      color: textColorComputed.value,
      "caret-color": textColorComputed.value,
      "--va-input-color": props.background ? getColor(props.background) : void 0,
      borderColor: borderColorComputed.value
    }));
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => props.counterValue !== void 0);
    const counterComputed = computed(
      () => props.maxLength !== void 0 ? `${props.counterValue}/${props.maxLength}` : props.counterValue
    );
    return {
      containerStyle,
      wrapperClass,
      wrapperStyle,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      backgroundComputed,
      borderColorComputed,
      messagesColor,
      messagesComputed,
      hasMessages,
      errorLimit
    };
  },
  methods: {
    focus() {
      this.$el.focus();
    },
    blur() {
      this.$el.blur();
    }
  }
});
var __injectCSSVars__7 = () => {
  useCssVars((_ctx) => ({
    "a310421c": _ctx.backgroundComputed,
    "cf315028": _ctx.textColorComputed
  }));
};
var __setup__7 = __default__7.setup;
__default__7.setup = __setup__7 ? (props, ctx) => {
  __injectCSSVars__7();
  return __setup__7(props, ctx);
} : __injectCSSVars__7;
var _sfc_main38 = __default__7;
var _hoisted_119 = { class: "va-input-wrapper__container" };
var _hoisted_211 = { class: "va-input-wrapper__field" };
var _hoisted_36 = { class: "va-input-wrapper__text" };
var _hoisted_46 = {
  key: 0,
  class: "va-input-wrapper__required-mark"
};
var _hoisted_55 = {
  key: 0,
  class: "va-input-wrapper__bottom"
};
var _hoisted_64 = { class: "va-input-wrapper__bottom-counter" };
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    style: normalizeStyle(_ctx.wrapperStyle),
    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click", $event))
  }, [
    createBaseVNode("div", _hoisted_119, [
      _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-input-wrapper__prepend-inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
      }, [
        renderSlot(_ctx.$slots, "prepend")
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_211, [
        _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-input__container",
          ref: "container",
          style: normalizeStyle(_ctx.containerStyle),
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "prependInner")
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_36, [
          _ctx.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            "aria-hidden": "true",
            class: "va-input-wrapper__label",
            style: normalizeStyle({ color: _ctx.colorComputed })
          }, [
            createTextVNode(toDisplayString(_ctx.label) + " ", 1),
            _ctx.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_46, " * ")) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          color: "success",
          name: "va-check-circle",
          size: "small"
        })) : createCommentVNode("", true),
        _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
          key: 2,
          color: "danger",
          name: "va-warning",
          size: "small"
        })) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "icon"),
        _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: "va-input-wrapper__append-inner",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click-append-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "appendInner")
        ])) : createCommentVNode("", true)
      ]),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-input-wrapper__append-inner",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append"))
      }, [
        renderSlot(_ctx.$slots, "append")
      ])) : createCommentVNode("", true)
    ]),
    _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", _hoisted_55, [
      renderSlot(_ctx.$slots, "counter", normalizeProps(guardReactiveProps({ valueLength: _ctx.$props.counterValue, maxLength: _ctx.$props.maxLength })), () => [
        createBaseVNode("div", _hoisted_64, toDisplayString(_ctx.counterComputed), 1)
      ])
    ])) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ messages: _ctx.messagesComputed, errorLimit: _ctx.errorLimit, color: _ctx.messagesColor })), () => [
      _ctx.hasMessages ? (openBlock(), createBlock(_component_va_message_list, {
        key: 0,
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit
      }, null, 8, ["color", "model-value", "limit"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var VaInputWrapper = _export_sfc(_sfc_main38, [["render", _sfc_render36], ["styles", [...VaMessageList.styles || [], ...VaIcon2.styles || [], _style_035]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/components/VaTextarea/useTextareaRowHeight.js
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important';
`;
var SIZING_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
var getNodeHeightStyles = (node) => {
  const style = window.getComputedStyle(node);
  return {
    boxSizing: style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing"),
    padding: parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top")),
    border: parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width")),
    styles: SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";") + ";",
    lineHeight: parseInt(style.getPropertyValue("line-height"))
  };
};
var textarea = null;
var createHiddenTextarea = (original, styles) => {
  if (!textarea) {
    textarea = document.createElement("textarea");
  }
  textarea.setAttribute("style", styles + HIDDEN_TEXTAREA_STYLE);
  textarea.value = original.value || original.placeholder || "";
  const wrap = original.getAttribute("wrap");
  if (wrap !== null) {
    textarea.setAttribute("wrap", wrap);
  } else {
    textarea.removeAttribute("wrap");
  }
  return textarea;
};
var useTextareaRowHeight = (textarea2) => {
  const calculateRowHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    return getNodeHeightStyles(textarea2.value).lineHeight;
  };
  const calculateHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    const { boxSizing, padding, border, styles } = getNodeHeightStyles(textarea2.value);
    const hiddenTextarea = createHiddenTextarea(textarea2.value, styles);
    document.body.appendChild(hiddenTextarea);
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += border;
    } else if (boxSizing === "content-box") {
      height -= padding;
    }
    document.body.removeChild(hiddenTextarea);
    return height;
  };
  return {
    calculateRowHeight,
    calculateHeight
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/components/VaTextarea/VaTextarea.js
var _style_036 = ".textarea {\n  padding: 0;\n  border: 0;\n  font-family: var(--va-font-family);\n}";
var positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var _sfc_main39 = defineComponent({
  name: "VaTextarea",
  props: {
    ...useFormProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    }
  },
  emits: createEmits2(),
  setup(props, { emit }) {
    const textarea2 = shallowRef();
    const rowHeight = ref(-1);
    const height = ref(-1);
    const { calculateRowHeight, calculateHeight } = useTextareaRowHeight(textarea2);
    const isResizable = computed(() => {
      return Boolean((props.autosize || props.maxRows || props.minRows !== 1) && textarea2.value);
    });
    const updateRowHeight = () => {
      if (isResizable.value) {
        rowHeight.value = calculateRowHeight();
      }
    };
    const updateHeight = () => {
      if (isResizable.value) {
        height.value = calculateHeight();
      }
    };
    onMounted(() => {
      updateRowHeight();
      updateHeight();
    });
    watch(() => props.modelValue, () => {
      nextTick(updateHeight);
    });
    const computedStyle = computed(() => ({
      minHeight: rowHeight.value * props.minRows + "px",
      maxHeight: props.maxRows ? rowHeight.value * props.maxRows + "px" : void 0,
      height: height.value + "px",
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick_1(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    const focus = () => {
      var _a;
      (_a = textarea2.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = textarea2.value) == null ? void 0 : _a.blur();
    };
    return {
      textarea: textarea2,
      computedStyle,
      listeners: createListeners2(emit),
      computedProps,
      focus,
      blur
    };
  }
});
var _hoisted_120 = ["value"];
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", mergeProps({
    ref: "textarea",
    class: "textarea",
    style: _ctx.computedStyle
  }, { ..._ctx.computedProps, ..._ctx.listeners }, { value: _ctx.modelValue }), null, 16, _hoisted_120);
}
var VaTextarea = _export_sfc(_sfc_main39, [["render", _sfc_render37], ["styles", [_style_036]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/VaInput.js
var VaTextareaProps = extractComponentProps(VaTextarea);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur"]
);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var _sfc_main40 = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaTextarea, VaIcon },
  props: {
    ...useFormProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...VaTextareaProps,
    ...useComponentPresetProp,
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    modelValue: { type: [String, Number], default: "" },
    label: { type: String, default: "" },
    type: { type: String, default: "text" },
    loading: { type: Boolean, default: false },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    ariaLabel: { type: String, default: void 0 },
    counter: { type: Boolean, default: false },
    maxLength: { type: Number, default: void 0 },
    color: { type: String, default: "primary" },
    background: { type: String, default: "background-element" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits()
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const isFocused = useFocusDeep();
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      blurElement(unwrapEl(input.value));
    };
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const computedCleaveTarget = computed(() => props.type === "textarea" ? void 0 : input.value);
    const { computedValue, onInput } = useCleave(computedCleaveTarget, props, emit);
    const inputListeners = createInputListeners(emit);
    const onFocus = (e) => {
      inputListeners.onFocus(e);
      validationListeners.onFocus();
    };
    const onBlur = (e) => {
      inputListeners.onBlur(e);
      validationListeners.onBlur();
    };
    const inputEvents = {
      ...inputListeners,
      onFocus,
      onBlur,
      onInput
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => ({
      "aria-label": props.ariaLabel || props.label,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit_1(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick_1(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "minlength", "maxlength"])
    }));
    const valueLengthComputed = computed(
      () => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0
    );
    return {
      ...useTranslation(),
      input,
      inputEvents,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      textareaProps: filterComponentProps(VaTextareaProps),
      computedValue,
      tabIndexComputed,
      computedError,
      computedErrorMessages,
      isFocused,
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      reset,
      focus,
      blur
    };
  }
});
var _hoisted_121 = ["value"];
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaTextarea = resolveComponent("VaTextarea");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps(_ctx.fieldListeners, {
    class: ["va-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style,
    color: _ctx.$props.color,
    background: _ctx.$props.background,
    readonly: _ctx.$props.readonly,
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    label: _ctx.$props.label,
    bordered: _ctx.$props.bordered,
    outline: _ctx.$props.outline,
    requiredMark: _ctx.$props.requiredMark,
    focused: _ctx.isFocused,
    "counter-value": _ctx.valueLengthComputed,
    "max-length": _ctx.$props.maxLength,
    onClick: _ctx.focus
  }), createSlots({
    icon: withCtx((slotScope) => [
      _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
        key: 0,
        role: "button",
        "aria-label": _ctx.t("reset"),
        tabindex: _ctx.tabIndexComputed
      }, _ctx.clearIconProps, {
        onClick: withModifiers(_ctx.reset, ["stop"]),
        onKeydown: [
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
        ]
      }), null, 16, ["aria-label", "tabindex", "onClick", "onKeydown"])) : createCommentVNode("", true),
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
        key: 1,
        color: _ctx.$props.color,
        size: "small",
        name: "va-loading",
        spin: "counter-clockwise"
      }, null, 8, ["color"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      _ctx.type === "textarea" && !_ctx.$slots.content ? (openBlock(), createBlock(_component_VaTextarea, mergeProps({
        key: 0,
        ref: "input"
      }, { ..._ctx.computedChildAttributes, ..._ctx.textareaProps, ..._ctx.inputEvents }, { class: "va-input__content__input" }), null, 16)) : !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "va-input__content__input"
      }, { ..._ctx.computedInputAttributes, ..._ctx.inputEvents }, { value: _ctx.computedValue }), null, 16, _hoisted_121)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      };
    })
  ]), 1040, ["class", "style", "color", "background", "readonly", "disabled", "success", "messages", "error", "error-messages", "error-count", "label", "bordered", "outline", "requiredMark", "focused", "counter-value", "max-length", "onClick"]);
}
var _VaInput = _export_sfc(_sfc_main40, [["render", _sfc_render38], ["styles", [...VaInputWrapper.styles || [], ...VaTextarea.styles || [], ...VaIcon.styles || []]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/index.js
var VaInput = withConfigTransport(_VaInput);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-input/VaColorInput.js
var _style_037 = ".va-color-input {\n  display: flex;\n  align-items: center !important;\n}\n.va-color-input .form-group {\n  margin-bottom: 0;\n}\n.va-color-input__input {\n  margin-bottom: 0;\n  margin-left: 0.25rem;\n  min-width: 5.6rem;\n}\n.va-color-input__input__pointer {\n  cursor: pointer;\n}\n.va-color-input__hidden-input {\n  visibility: hidden;\n  width: 0;\n  height: 0;\n  overflow: hidden;\n  position: absolute;\n  pointer-events: none;\n}";
var _sfc_main41 = defineComponent({
  name: "VaColorInput",
  components: {
    VaInput,
    VaColorIndicator
  },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  },
  setup: (props, { emit }) => {
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const callPickerDialog = () => {
      var _a;
      return !props.disabled && ((_a = colorPicker.value) == null ? void 0 : _a.click());
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    return {
      ...useTranslation(),
      valueComputed,
      callPickerDialog,
      colorPicker,
      tabIndexComputed
    };
  }
});
var _hoisted_122 = { class: "va-color-input" };
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  const _component_va_input = resolveComponent("va-input");
  return openBlock(), createElementBlock("div", _hoisted_122, [
    createVNode(_component_va_input, {
      class: "va-color-input__input",
      placeholder: "input color",
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      tabindex: _ctx.tabIndexComputed,
      disabled: _ctx.$props.disabled
    }, {
      appendInner: withCtx(() => [
        createVNode(_component_va_color_indicator, {
          class: "va-color-input__dot",
          role: "button",
          "aria-label": _ctx.t("openColorPicker"),
          "aria-disabled": _ctx.$props.disabled,
          tabindex: _ctx.tabIndexComputed,
          color: _ctx.valueComputed,
          indicator: _ctx.$props.indicator,
          onClick: _ctx.callPickerDialog,
          onKeydown: [
            withKeys(_ctx.callPickerDialog, ["space"]),
            withKeys(_ctx.callPickerDialog, ["enter"])
          ]
        }, null, 8, ["aria-label", "aria-disabled", "tabindex", "color", "indicator", "onClick", "onKeydown"])
      ]),
      _: 1
    }, 8, ["modelValue", "tabindex", "disabled"]),
    withDirectives(createBaseVNode("input", {
      ref: "colorPicker",
      type: "color",
      class: "va-color-input__hidden-input",
      "aria-hidden": "true",
      tabindex: "-1",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
    }, null, 512), [
      [vModelText, _ctx.valueComputed]
    ])
  ]);
}
var _VaColorInput = _export_sfc(_sfc_main41, [["render", _sfc_render39], ["styles", [...VaInput.styles || [], ...VaColorIndicator.styles || [], _style_037]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-input/index.js
var VaColorInput = withConfigTransport(_VaColorInput);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-palette/VaColorPalette.js
var _style_038 = ".va-color-palette {\n  display: flex;\n  padding-left: 0;\n  margin: 0;\n}\n.va-color-palette > * {\n  margin-right: 0.25rem;\n}\n.va-color-palette > *:last-child {\n  margin-right: 0;\n}";
var _sfc_main42 = defineComponent({
  name: "VaColorPalette",
  components: { VaColorIndicator },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    return {
      ...useTranslation(),
      valueComputed,
      isSelected: (color) => valueComputed.value === color
    };
  }
});
var _hoisted_123 = ["aria-label"];
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  return openBlock(), createElementBlock("ul", {
    class: "va-color-palette",
    role: "listbox",
    "aria-label": _ctx.t("colorSelection")
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palette, (color, index) => {
      return openBlock(), createBlock(_component_va_color_indicator, {
        key: index,
        role: "option",
        "aria-label": _ctx.t("color", { color }),
        "aria-selected": _ctx.isSelected(color),
        tabindex: "0",
        modelValue: _ctx.isSelected(color),
        color,
        square: _ctx.indicator === "square",
        "onUpdate:modelValue": ($event) => _ctx.valueComputed = color
      }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
    }), 128))
  ], 8, _hoisted_123);
}
var _VaColorPalette = _export_sfc(_sfc_main42, [["render", _sfc_render40], ["styles", [...VaColorIndicator.styles || [], _style_038]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-palette/index.js
var VaColorPalette = withConfigTransport(_VaColorPalette);

// node_modules/vuestic-ui/dist/web-components/src/components/va-content/VaContent.js
var _sfc_main43 = {
  name: "VaContent"
};
var _hoisted_124 = { class: "va-typography-block" };
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_124, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaContent = _export_sfc(_sfc_main43, [["render", _sfc_render41]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-content/index.js
var VaContent = withConfigTransport(_VaContent);

// node_modules/vuestic-ui/dist/web-components/src/utils/css.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/hooks/useCounterPropsValidation.js
function useCounterPropsValidation(props) {
  const validateCounterProps = () => {
    const val = Number(props.modelValue);
    if (Number.isNaN(val)) {
      warn("The value is not a number or cannot be reduced to a number.");
      return;
    }
    if (props.min && props.max && props.min > props.max) {
      warn(`The maximum value (${props.max}) can not be less than the minimum value (${props.min}).`);
    }
    if (props.min && val < props.min) {
      warn(`The value of the counter (${val}) can not be less than the minimum value (${props.min}).`);
    }
    if (props.max && val > props.max) {
      warn(`The value of the counter (${val}) can not be greater than the maximum value (${props.max}).`);
    }
    if (props.min && props.max && props.step > props.max - props.min) {
      warn(`The value of the step (${props.step}) can not be greater than the difference (${props.max - props.min}) between maximum value (${props.max}) and minimum value (${props.min}).`);
    }
  };
  watch(
    [
      () => props.step,
      () => props.min,
      () => props.max
    ],
    validateCounterProps,
    { immediate: true }
  );
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/VaCounter.js
var _style_039 = ":root,\n:host {\n  --va-counter-button-inner-padding: 6px;\n  --va-counter-button-outer-padding: 8px;\n}\n.va-counter {\n  --va-input-wrapper-min-width: none;\n}\n.va-counter.va-counter--input-square .va-input__container {\n  border-radius: 0;\n  border-left: none;\n  border-right: none;\n}\n.va-counter.va-counter--input-square .va-counter__prepend-wrapper .va-counter__button-decrease {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.va-counter.va-counter--input-square .va-counter__prepend-wrapper .va-counter__button-decrease:not(.va-button--square) {\n  width: unset;\n}\n.va-counter.va-counter--input-square .va-counter__prepend-wrapper .va-counter__button-decrease:not(.va-button--square) .va-button__content {\n  padding-right: var(--va-counter-button-inner-padding);\n  padding-left: var(--va-counter-button-outer-padding);\n}\n.va-counter.va-counter--input-square .va-counter__append-wrapper .va-counter__button-increase {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.va-counter.va-counter--input-square .va-counter__append-wrapper .va-counter__button-increase:not(.va-button--square) {\n  width: unset;\n}\n.va-counter.va-counter--input-square .va-counter__append-wrapper .va-counter__button-increase:not(.va-button--square) .va-button__content {\n  padding-left: var(--va-counter-button-inner-padding);\n  padding-right: var(--va-counter-button-outer-padding);\n}\n.va-counter:not(.va-counter--input-square) .va-counter__prepend-wrapper .va-counter__button-decrease .va-button__content,\n.va-counter:not(.va-counter--input-square) .va-counter__prepend-wrapper .va-counter__button-increase .va-button__content,\n.va-counter:not(.va-counter--input-square) .va-counter__append-wrapper .va-counter__button-decrease .va-button__content,\n.va-counter:not(.va-counter--input-square) .va-counter__append-wrapper .va-counter__button-increase .va-button__content {\n  padding: unset;\n}\n.va-counter .va-counter__content-wrapper {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n}\n.va-counter .va-input__content__input {\n  text-align: center;\n}\n.va-counter .va-input__content__input::-webkit-outer-spin-button, .va-counter .va-input__content__input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.va-counter .va-input__content__input[type=number] {\n  -moz-appearance: textfield;\n}\n.va-counter .va-input-wrapper__field {\n  align-items: stretch;\n  padding: 0;\n}\n.va-counter .va-input-wrapper__field .va-input-wrapper__text,\n.va-counter .va-input-wrapper__field .va-input__container {\n  padding-right: 0;\n}\n.va-counter__prepend-inner, .va-counter__append-inner {\n  display: flex;\n  align-items: stretch;\n  height: 100%;\n}";
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(
  ["change"]
);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var _sfc_main44 = defineComponent({
  name: "VaCounter",
  components: { VaInputWrapper, VaButton },
  props: {
    ...useFormProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false },
    min: { type: Number, default: void 0 },
    max: { type: Number, default: void 0 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    messages: { type: [Array, String], default: () => [] },
    width: { type: [String, Number], default: "160px" },
    color: { type: String, default: "primary" },
    outline: { type: Boolean },
    bordered: { type: Boolean },
    increaseIcon: { type: String, default: "add" },
    decreaseIcon: { type: String, default: "remove" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    textColor: { type: String, default: void 0 }
  },
  emits: [
    "update:modelValue",
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs }) {
    const input = shallowRef();
    const { min, max, step } = toRefs(props);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit);
    const { valueComputed } = useStateful(props, emit);
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (typeof min.value === "undefined" || !step.value) {
        return value;
      }
      return min.value + step.value * Math.floor((value - min.value) / step.value);
    };
    const calculateCounterValue = (counterValue) => {
      if (typeof min.value !== "undefined" && counterValue < min.value) {
        valueComputed.value = min.value;
        return;
      }
      if (max.value && counterValue > max.value) {
        valueComputed.value = typeof min.value !== "undefined" && step.value ? getRoundDownWithStep(max.value) : max.value;
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (typeof min.value === "undefined") {
        return false;
      }
      return Number(valueComputed.value) <= min.value;
    });
    const isMaxReached = computed(() => {
      if (!max.value) {
        return false;
      }
      return step.value ? Number(valueComputed.value) > max.value - step.value : Number(valueComputed.value) >= max.value;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props.readonly || props.disabled);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props.readonly || props.disabled);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - step.value);
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + step.value);
    };
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const decreaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.decreaseIcon,
      plain: true,
      disabled: isDecreaseActionDisabled.value,
      tabindex: -1,
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.increaseIcon,
      plain: true,
      disabled: isIncreaseActionDisabled.value,
      tabindex: -1,
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const isSquareCorners = computed(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonProps = computed(() => ({
      ...pick_1(props, ["rounded", "color", "textColor"]),
      flat: props.flat && !props.outline,
      outline: props.flat && props.outline
    }));
    const decreaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value
    }));
    const increaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value
    }));
    const { t } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      tabindex: tabIndexComputed.value,
      "aria-label": props.label || t("counterValue"),
      "aria-valuemin": min.value,
      "aria-valuemax": max.value,
      ...omit_1(attrs, ["class", "style"]),
      ...pick_1(props, ["disabled", "min", "max", "step"]),
      readonly: props.readonly || !props.manualInput
    }));
    const inputWrapperPropsComputed = computed(() => ({
      ...pick_1(props, ["color", "readonly", "disabled", "messages", "label", "bordered", "outline"])
    }));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value }
    ]);
    const styleComputed = computed(() => ({
      width: safeCSSLength(props.width),
      ...attrs.style || {}
    }));
    const marginComputed = computed(() => safeCSSLength(props.margins));
    useCounterPropsValidation(props);
    return {
      ...useTranslation(),
      input,
      valueComputed,
      isFocused,
      fieldListeners: createFieldListeners2(emit),
      inputListeners: createInputListeners2(emit),
      inputAttributesComputed,
      inputWrapperPropsComputed,
      setCountInput,
      setCountChange,
      decreaseCount,
      increaseCount,
      decreaseIconProps,
      increaseIconProps,
      decreaseButtonProps,
      increaseButtonProps,
      colorComputed,
      classComputed,
      styleComputed,
      marginComputed,
      focus,
      blur
    };
  }
});
var _hoisted_125 = {
  ref: "input",
  tabindex: "0",
  class: "va-counter__content-wrapper"
};
var _hoisted_212 = ["value"];
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps({ class: "va-counter" }, { ..._ctx.fieldListeners, ..._ctx.inputWrapperPropsComputed }, {
    class: _ctx.classComputed,
    style: _ctx.styleComputed,
    focused: _ctx.isFocused,
    onKeydown: [
      withKeys(withModifiers(_ctx.increaseCount, ["prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.decreaseCount, ["prevent"]), ["down"])
    ]
  }), createSlots({
    default: withCtx(() => [
      !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 0,
        ref: "input",
        class: "va-input__content__input",
        type: "number",
        inputmode: "decimal"
      }, { ..._ctx.inputAttributesComputed, ..._ctx.inputListeners }, {
        value: _ctx.valueComputed,
        onInput: _cache[4] || (_cache[4] = (...args) => _ctx.setCountInput && _ctx.setCountInput(...args)),
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.setCountChange && _ctx.setCountChange(...args))
      }), null, 16, _hoisted_212)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    _ctx.$props.buttons ? {
      name: "prepend",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__prepend-wrapper",
          style: normalizeStyle({ marginRight: _ctx.marginComputed }),
          onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount: _ctx.decreaseCount })), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-decrease",
              "aria-label": _ctx.t("decreaseCounter")
            }, _ctx.decreaseButtonProps, { onClick: _ctx.decreaseCount }), null, 16, ["aria-label", "onClick"])
          ])
        ], 36)
      ])
    } : {
      name: "prependInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"])),
          class: "va-counter__prepend-inner"
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount: _ctx.decreaseCount })), () => [
            createVNode(_component_va_button, normalizeProps(guardReactiveProps(_ctx.decreaseIconProps)), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$props.buttons ? {
      name: "append",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__append-wrapper",
          style: normalizeStyle({ marginLeft: _ctx.marginComputed }),
          onMousedown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount: _ctx.increaseCount })), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-increase",
              "aria-label": _ctx.t("increaseCounter")
            }, _ctx.increaseButtonProps, { onClick: _ctx.increaseCount }), null, 16, ["aria-label", "onClick"])
          ])
        ], 36)
      ])
    } : {
      name: "appendInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"])),
          class: "va-counter__append-inner"
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount: _ctx.increaseCount })), () => [
            createVNode(_component_va_button, normalizeProps(guardReactiveProps(_ctx.increaseIconProps)), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$slots.content ? {
      name: "default",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", _hoisted_125, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ ...slotScope, value: Number(_ctx.valueComputed) })))
        ], 512)
      ])
    } : void 0
  ]), 1040, ["class", "style", "focused", "onKeydown"]);
}
var _VaCounter = _export_sfc(_sfc_main44, [["render", _sfc_render42], ["styles", [...VaInputWrapper.styles || [], ...VaButton.styles || [], _style_039]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/index.js
var VaCounter = withConfigTransport(_VaCounter);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useCommonProps.js
var useCurrentPageProp = { currentPage: { type: Number } };
var useItemsProp = { items: { type: Array, default: () => [] } };
var useSelectableProp = { selectable: { type: Boolean, default: false } };
var useItemsTrackByProp = { itemsTrackBy: { type: [String, Function], default: "" } };

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useColumns.js
var sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
var useColumnsProps = {
  ...useItemsProp,
  columns: { type: Array, default: () => [] },
  sortingOptions: {
    type: Array,
    default: () => ["asc", "desc", null],
    validator: sortingOptionsValidator
  }
};
var buildTableColumn = (source, initialIndex, props) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase_1(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase_1(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (props) => {
  return Object.keys(merge_1({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));
};
var buildNormalizedColumns = (props) => {
  return props.columns.map((item, index) => buildTableColumn(item, index, props));
};
var useColumns = (props) => {
  const columnsComputed = computed(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props);
    } else {
      return buildNormalizedColumns(props);
    }
  });
  return {
    columnsComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useThrottle.js
var useThrottleProps = {
  delay: {
    type: Number,
    default: 0,
    validator: (value) => value >= 0
  }
};
function useThrottleFunction(fn, props) {
  var _a;
  const delay = (_a = toRef(props, "delay")) != null ? _a : 0;
  const isThrottled = ref(true);
  let lastCallResult = void 0;
  return function(...args) {
    const invoke = () => fn.apply(this, args);
    if (!unref(delay)) {
      return invoke();
    }
    if (isThrottled.value) {
      isThrottled.value = false;
      setTimeout(() => isThrottled.value = true, unref(delay));
      lastCallResult = invoke();
    }
    return lastCallResult;
  };
}
function useThrottleValue(value, props) {
  var _a;
  const delay = (_a = toRef(props, "delay")) != null ? _a : 0;
  if (!unref(delay)) {
    return value;
  }
  const isThrottled = ref(true);
  const previousCallValue = ref();
  const previousReturnedValue = ref();
  const currentCallValue = ref();
  watch(value, () => {
    previousCallValue.value = value.value;
    const lastCallValue = setTimeout(() => {
      currentCallValue.value = previousCallValue.value;
    }, unref(delay));
    if (isThrottled.value) {
      isThrottled.value = false;
      currentCallValue.value = value.value;
      previousReturnedValue.value = value.value;
      clearTimeout(lastCallValue);
      setTimeout(() => isThrottled.value = true, unref(delay));
    } else {
      currentCallValue.value = previousReturnedValue.value;
    }
  }, { immediate: true });
  return currentCallValue;
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/usePaginatedRows.js
var usePaginatedRowsProps = {
  ...useThrottleProps,
  ...useCurrentPageProp,
  perPage: { type: Number }
};
var usePaginatedRows = (sortedRows, props) => {
  const paginatedRows = computed(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  const paginatedRowsThrottled = useThrottleValue(paginatedRows, props);
  return {
    paginatedRows: paginatedRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/web-components/src/utils/value-by-key.js
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject_1(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (!option || typeof option !== "object" || Array.isArray(option)) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useRows.js
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var useRowsProps = {
  ...useItemsProp,
  ...useItemsTrackByProp
};
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a = source == null ? void 0 : source.toString) == null ? void 0 : _a.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column))
  };
};
var useRows = (columns, props) => {
  const rowsComputed = computed(() => props.items.map((rawItem, index) => buildTableRow(rawItem, index, props.itemsTrackBy, columns.value)));
  return {
    rowsComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useSelectableRow.js
var useSelectableProps2 = {
  ...useSelectableProp,
  ...useItemsTrackByProp,
  modelValue: { type: Array },
  selectMode: { type: String, default: "multiple" }
};
var useSelectableRow = (paginatedRows, props, emit) => {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useStylable.js
var prefix = "--va-data-table";
var isFunction2 = (val) => typeof val === "function";
var useStylableProps = {
  ...useSelectableProp,
  selectedColor: { type: String, default: "primary" },
  allowFooterSorting: { type: Boolean, default: false },
  stickyHeader: { type: Boolean, default: false },
  stickyFooter: { type: Boolean, default: false },
  height: { type: [String, Number] }
};
var getClass = (classes) => isFunction2(classes) ? classes() : classes;
var getStyle = (styles) => isFunction2(styles) ? styles() : styles;
var useStylable = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2 } = useColors();
  const color = computed(() => getColor(props.selectedColor));
  const CSSVariables = computed(() => ({
    hoverColor: getHoverColor2(color.value),
    selectedColor: props.selectable ? getFocusColor2(color.value) : void 0,
    tableHeight: props.height ? safeCSSLength(props.height) : "var(--va-data-table-height)",
    theadBg: props.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
    tfootBg: props.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    CSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useBinding.js
var isFunction3 = (val) => typeof val === "function";
var isObject3 = (val) => val !== null && typeof val === "object";
var useBindingProps = {
  rowBind: { type: null },
  cellBind: { type: null }
};
var useBinding = (props) => {
  const getRowBind = (row) => isFunction3(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject3(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction3(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject3(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useAnimationName.js
var useAnimationNameProps = {
  ...useCurrentPageProp,
  animated: { type: Boolean, default: true }
};
var useAnimationName = (props, rows) => {
  const animationType = ref("shuffle");
  const animationName = computed(() => props.animated ? `table-transition-${animationType.value}` : "");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows, oldRows) => {
    const hasRows = !!(newRows.length && oldRows.length);
    animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationType.value = "shuffle";
    }
  });
  return animationName;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useFilterable.js
var useFilterableProps = {
  ...useThrottleProps,
  filter: { type: String, default: "" },
  filterMethod: { type: Function }
};
var useFilterable = (rawRows, props, emit) => {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter((row) => row.cells.some((cell) => {
      return typeof props.filterMethod === "function" ? props.filterMethod(cell.source) : cell.value.toLowerCase().includes(props.filter.toLowerCase());
    }));
  });
  const filteredRowsThrottled = useThrottleValue(filteredRows, props);
  watch(filteredRowsThrottled, () => {
    emit("filtered", {
      items: filteredRowsThrottled.value.map((row) => row.source),
      itemsIndexes: filteredRowsThrottled.value.map((row) => row.initialIndex)
    });
  });
  return {
    filteredRows: filteredRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useSortable.js
var useSortableProps = {
  ...useThrottleProps,
  sortBy: { type: String },
  sortingOrder: { type: String }
};
var useSortable = (columns, filteredRows, props, emit) => {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.findIndex(
      ({ name, sortable }) => sortBySync.value === name && sortable
    );
    const column = columns.value[columnIndex];
    if (!column) {
      return filteredRows.value;
    }
    const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
    return [...filteredRows.value].sort((a, b) => {
      if (sortingOrderSync.value === null) {
        return a.initialIndex - b.initialIndex;
      } else {
        const firstValue = a.cells[columnIndex].value;
        const secondValue = b.cells[columnIndex].value;
        const firstSource = a.cells[columnIndex].source;
        const secondSource = b.cells[columnIndex].source;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    if (column.name === sortBySync.value) {
      sortingOrderSync.value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      sortingOrderSync.value = column.sortingOptions[0];
    }
  }
  const toggleSortingThrottled = useThrottleFunction(toggleSorting, props);
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "va-arrow-up" : sortingOrderSync.value === "desc" ? "va-arrow-down" : "unfold_more";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting: toggleSortingThrottled,
    sortedRows,
    sortingOrderIconName
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementRef.js
var unrefElement = (el) => {
  var _a;
  const e = unref(el);
  return (_a = e == null ? void 0 : e.$el) != null ? _a : e;
};
var useElementRef = () => {
  const el = shallowRef();
  return computed({
    get() {
      return unrefElement(el);
    },
    set(node) {
      el.value = node;
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useTableScroll.js
var useTableScrollProps = {
  scrollTopMargin: { type: Number, default: 0 },
  scrollBottomMargin: { type: Number, default: 0 }
};
var useTableScrollEmits = ["scroll:top", "scroll:bottom"];
var useTableScroll = (props, emit) => {
  var _a;
  const vNodeProps = (_a = getCurrentInstance()) == null ? void 0 : _a.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const isObservable = computed(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
      }
    });
  };
  const targets = computed(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed(() => {
    var _a2, _b;
    return {
      root: scrollContainer.value,
      rootMargin: `${(_a2 = props.scrollTopMargin) != null ? _a2 : 0}px 0px ${(_b = props.scrollBottomMargin) != null ? _b : 0}px 0px`
    };
  });
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/components/VaDataTableThRow.js
var _style_040 = '.va-data-table {\n  --va-data-table-cell-padding: 0.625rem;\n  --va-data-table-thead-line-height: 1.6;\n  --va-data-table-thead-font-size: 0.625rem;\n  --va-data-table-thead-font-weight: 700;\n  --va-data-table-thead-text-transform: uppercase;\n  --va-data-table-thead-letter-spacing: 0.6px;\n  --va-data-table-thead-border: 1px solid var(--va-background-border);\n  --va-data-table-thead-border-top-shadow: inset 0 1px 0 0 var(--va-background-border);\n  --va-data-table-thead-border-bottom-shadow: inset 0 -1px 0 0 var(--va-background-border);\n  --va-data-table-height: unset;\n  --va-data-table-max-height: unset;\n  --va-data-table-thead-color: currentColor;\n  --va-data-table-tfoot-color: currentColor;\n  --va-data-table-header-background: var(--va-background-primary);\n  /* Hover */\n  --va-data-table-hover-th-opacity: 0.3;\n  /* Striped */\n  --va-data-table-striped-tr-background-color: var(--va-background-element);\n  --va-data-table-striped-tr-opacity: 1;\n  /* Selectable */\n  --va-data-table-selectable-tr-cursor: pointer;\n  --va-data-table-selectable-cell-width: 55px;\n  --va-data-table-selectable-cell-vertical-align: middle;\n  --va-data-table-selectable-cell-text-align: center;\n  /* No-data */\n  --va-data-table-no-data-text-align: center;\n  --va-data-table-no-data-vertical-align: middle;\n  /* Animated */\n  --va-data-table-transition: var(--va-transition);\n  /* Grid */\n  --va-data-table-grid-tbody-gap: 0.5rem;\n  --va-data-table-grid-tbody-margin-top: 1rem;\n  --va-data-table-grid-tr-padding: 1rem;\n  --va-data-table-grid-tr-border-radius: 0.5rem;\n  --va-data-table-grid-tr-border: 1px solid var(--va-background-border);\n  --va-data-table-grid-tr-header-font-weight: 600;\n  --va-data-table-grid-tr-header-color: var(--va-text-primary);\n}\n.va-data-table__table-th {\n  padding: var(--va-data-table-cell-padding);\n  width: var(--va-data-table-width);\n  min-width: var(--va-data-table-width);\n  text-align: var(--va-data-table-align);\n  vertical-align: var(--va-data-table-vertical-align);\n  font-size: var(--va-data-table-thead-font-size);\n  line-height: var(--va-data-table-thead-line-height);\n  font-weight: var(--va-data-table-thead-font-weight);\n  text-transform: var(--va-data-table-thead-text-transform);\n  letter-spacing: var(--va-data-table-thead-letter-spacing);\n  cursor: var(--va-data-table-cursor);\n}\n.va-data-table__table-th .va-data-table__table-th-wrapper {\n  display: flex;\n  align-items: center;\n}\n.va-data-table__table-th .va-data-table__table-th-wrapper:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: 2px;\n}\n.va-data-table__table-th .va-data-table__table-th-sorting-icon {\n  opacity: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}\n.va-data-table__table-th .va-data-table__table-th-sorting-icon.active {\n  opacity: 1;\n  pointer-events: initial;\n}\n.va-data-table__table-th .va-data-table__table-th-sorting-icon:focus-visible {\n  opacity: 1;\n}\n.va-data-table__table-th span {\n  flex-grow: 1;\n}\n.va-data-table__table-th:hover .va-data-table__table-th-sorting-icon:not(.active, :focus-visible) {\n  opacity: var(--va-data-table-hover-th-opacity);\n}';
var _sfc_main45 = defineComponent({
  name: "VaDataTableThRow",
  components: { VaIcon: VaIcon2, VaCheckbox },
  props: {
    ...useStylableProps,
    selectMode: { type: String, default: "multiple" },
    allRowsSelected: { type: Boolean, default: false },
    severalRowsSelected: { type: Boolean, default: false },
    columns: { type: Array, required: true },
    isFooter: { type: Boolean, default: false },
    sortBySync: { type: String, required: true },
    sortingOrderIconName: { type: String, required: true },
    sortingOrderSync: { type: String, default: null }
  },
  emits: [
    "toggleBulkSelection",
    "toggleSorting"
  ],
  setup(props, { emit }) {
    const { t } = useTranslation();
    const {
      getFooterCSSVariables,
      getHeaderCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const getAriaAttributes = (column) => {
      const ariaSort = props.sortingOrderSync && props.sortBySync === column.name ? props.sortingOrderSync === "asc" ? "ascending" : "descending" : "none";
      const ariaLabel = column.sortable ? t("sortColumnBy", { name: column.label }) : void 0;
      return {
        "aria-sort": ariaSort,
        "aria-label": ariaLabel
      };
    };
    const sortByColumn = (column) => {
      if (props.isFooter && !props.allowFooterSorting || !column.sortable) {
        return;
      }
      emit("toggleSorting", column);
    };
    const toggleBulkSelection = () => emit("toggleBulkSelection");
    const getColumnStyles = (column) => {
      return [props.isFooter ? getFooterCSSVariables(column) : getHeaderCSSVariables(column), getStyle2(column.thStyle)];
    };
    const slotNameComputed = computed(() => props.isFooter ? "footer" : "header");
    const multiplySelectAvailable = computed(() => props.selectMode === "multiple");
    return {
      t,
      getClass: getClass2,
      sortByColumn,
      getColumnStyles,
      slotNameComputed,
      getAriaAttributes,
      toggleBulkSelection,
      multiplySelectAvailable
    };
  }
});
var _hoisted_126 = { class: "va-data-table__table-tr" };
var _hoisted_213 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_37 = ["title", "onClick", "onKeydown"];
var _hoisted_47 = { class: "va-data-table__table-th-wrapper" };
var _hoisted_56 = { key: 0 };
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("tr", _hoisted_126, [
    _ctx.$props.selectable ? (openBlock(), createElementBlock("th", _hoisted_213, [
      _ctx.multiplySelectAvailable ? (openBlock(), createBlock(_component_va_checkbox, {
        key: 0,
        class: "va-data-table__table-cell-checkbox",
        "model-value": _ctx.$props.severalRowsSelected ? "idl" : _ctx.$props.allRowsSelected,
        "aria-label": _ctx.t("selectAllRows"),
        "true-value": true,
        "false-value": false,
        color: _ctx.$props.selectedColor,
        "indeterminate-value": "idl",
        indeterminate: "",
        "onUpdate:modelValue": _ctx.toggleBulkSelection
      }, null, 8, ["model-value", "aria-label", "color", "onUpdate:modelValue"])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column) => {
      return openBlock(), createElementBlock("th", mergeProps({
        key: column.name,
        scope: "col",
        class: ["va-data-table__table-th", _ctx.getClass(column.thClass)],
        title: column.thTitle,
        style: _ctx.getColumnStyles(column)
      }, _ctx.getAriaAttributes(column), {
        onClick: withModifiers(($event) => _ctx.sortByColumn(column), ["exact"]),
        onKeydown: withKeys(withModifiers(($event) => _ctx.sortByColumn(column), ["stop"]), ["enter"])
      }), [
        createBaseVNode("div", _hoisted_47, [
          `${_ctx.slotNameComputed}(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_56, [
            renderSlot(_ctx.$slots, `${_ctx.slotNameComputed}(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
          ])) : renderSlot(_ctx.$slots, _ctx.slotNameComputed, normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
            createBaseVNode("span", null, toDisplayString(column.label), 1)
          ]),
          column.sortable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }]),
            size: "small",
            role: column.sortable ? "button" : void 0,
            tabindex: column.sortable ? 0 : -1,
            name: _ctx.sortingOrderIconName,
            onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["prevent"]))
          }, null, 8, ["class", "role", "tabindex", "name"])) : createCommentVNode("", true)
        ])
      ], 16, _hoisted_37);
    }), 128))
  ]);
}
var _VaDataTableThRow = _export_sfc(_sfc_main45, [["render", _sfc_render43], ["styles", [...VaIcon2.styles || [], ...VaCheckbox.styles || [], _style_040]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/components/index.js
var VaDataTableThRow = withConfigTransport(_VaDataTableThRow);

// node_modules/vuestic-ui/dist/web-components/src/composables/useTrackBy.js
var useTrackByProps = {
  trackBy: {
    type: [String, Number, Function],
    default: ""
  }
};
var useTrackBy = (props) => {
  const getKey = (item, index, defaultValue) => {
    if (props.trackBy && item && typeof item === "object" && !isFunction_1(props.trackBy)) {
      const isArrayItem = Array.isArray(item);
      let key;
      if (isArrayItem && !isNaN(+props.trackBy)) {
        key = item[+props.trackBy];
      }
      if (!isArrayItem) {
        key = item[props.trackBy];
      }
      if (key || key === 0) {
        return key;
      }
      warn(`${isArrayItem ? "Index" : "Key"} '${props.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
    }
    if (isFunction_1(props.trackBy)) {
      return props.trackBy(item);
    }
    return defaultValue;
  };
  return { getKey };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/useVirtualScrollerSizes.js
var { isParsablePositiveMeasure, parseSizeValue: parseSizeValue2 } = useParsableMeasure();
var validateSizeProp = (v, propName) => {
  const isProperValue = isParsablePositiveMeasure(v);
  !isProperValue && warn(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v}.`);
  return isProperValue;
};
var useVirtualScrollerSizesProps = {
  horizontal: { type: Boolean, default: false },
  itemSize: {
    type: [Number, String],
    default: 0,
    validator: (v) => {
      return validateSizeProp(v, "itemSize");
    }
  },
  wrapperSize: {
    type: [Number, String],
    default: 100,
    validator: (v) => {
      return v === "auto" || validateSizeProp(v, "wrapperSize");
    }
  }
};
var useVirtualScrollerSizes = (props, scrollPosition) => {
  const list = shallowRef();
  const wrapper = shallowRef();
  const clientSizeMeasure = computed(() => props.horizontal ? "clientWidth" : "clientHeight");
  const wrapperSize = computed(() => {
    var _a;
    if (props.wrapperSize === "auto") {
      return ((_a = wrapper.value) == null ? void 0 : _a[clientSizeMeasure.value]) || 0;
    }
    return parseSizeValue2(props.wrapperSize, pageFontSize);
  });
  const pageFontSize = ref(16);
  const handleWindowResize = () => {
    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    calcAverageItemsSize();
  };
  useEvent("resize", handleWindowResize, true);
  const itemSizeCalculated = ref(0);
  const calcAverageItemsSize = () => {
    if (!list.value) {
      return;
    }
    const sizes = [];
    const itemsList = list.value.children;
    const itemsAmount = itemsList.length;
    for (let i = 0; i < itemsAmount; i++) {
      const currentChild = list.value.children.item(i);
      currentChild && sizes.push(currentChild[clientSizeMeasure.value]);
    }
    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;
  };
  const instance = getCurrentInstance();
  onMounted(() => {
    var _a, _b;
    if (!list.value) {
      list.value = (_b = (_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.refs) == null ? void 0 : _b.list;
    }
    calcAverageItemsSize();
  });
  watch(scrollPosition, calcAverageItemsSize);
  watch(wrapperSize, calcAverageItemsSize);
  let oldItemSize = 0;
  const itemSize = computed(() => {
    const sizeParsed = parseSizeValue2(props.itemSize, pageFontSize);
    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
    const diff = Math.abs(oldItemSize / result * 100 - 100);
    if (diff > 5 || oldItemSize === 0) {
      oldItemSize = result;
      return result;
    }
    return oldItemSize;
  });
  return { list, wrapper, itemSize, wrapperSize };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/VaVirtualScroller.js
var _style_041 = ".va-virtual-scroller {\n  overflow: auto;\n  width: 100%;\n  height: 100%;\n}\n.va-virtual-scroller__container {\n  position: relative;\n  overflow: hidden;\n  min-width: 100%;\n  min-height: 100%;\n}\n.va-virtual-scroller__list {\n  display: flex;\n  flex-direction: column;\n}\n.va-virtual-scroller--horizontal .va-virtual-scroller__list {\n  flex-direction: row;\n}";
var _sfc_main46 = defineComponent({
  name: "VaVirtualScroller",
  props: {
    ...useTrackByProps,
    ...useVirtualScrollerSizesProps,
    items: { type: Array, default: () => [] },
    bench: { type: Number, default: 10, validator: (v) => v >= 0 },
    disabled: { type: Boolean, default: false },
    table: { type: Boolean, default: false }
  },
  emits: ["scroll:bottom"],
  setup: (props, { emit }) => {
    const listScrollPosition = ref(0);
    const scrollDirection = computed(() => props.horizontal ? "scrollLeft" : "scrollTop");
    const handleScroll = () => {
      if (!wrapper.value) {
        return;
      }
      listScrollPosition.value = wrapper.value[scrollDirection.value];
    };
    if (!props.disabled) {
      useEvent("scroll", handleScroll, true);
    }
    const { list, wrapper, itemSize, wrapperSize } = useVirtualScrollerSizes(props, listScrollPosition);
    const { getKey } = useTrackBy(props);
    const uniqueKey = (item, index, defaultValue) => getKey(item, index, defaultValue);
    watch(listScrollPosition, (newValue) => {
      if (newValue + wrapperSize.value === containerSize.value) {
        emit("scroll:bottom");
      }
    });
    const renderStartIndex = computed(() => {
      return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - props.bench);
    });
    const renderItemsAmount = computed(() => {
      var _a;
      if (!((_a = props.items) == null ? void 0 : _a.length)) {
        return 0;
      }
      return props.disabled ? props.items.length : Math.min(props.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + props.bench * 2);
    });
    const renderEndIndex = computed(() => renderStartIndex.value + renderItemsAmount.value);
    const renderBuffer = computed(() => {
      var _a;
      if (!((_a = props.items) == null ? void 0 : _a.length)) {
        return [];
      }
      return props.items.slice(renderStartIndex.value, renderEndIndex.value);
    });
    const sizeAttribute = computed(() => props.horizontal ? "width" : "height");
    const isDisabledVirtualTable = computed(() => props.table && props.disabled);
    const wrapperStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value || !wrapperSize.value ? void 0 : `${wrapperSize.value}px`
    }));
    const wrapperClassComputed = useBem("va-virtual-scroller", () => ({
      ...pick_1(props, ["horizontal"])
    }));
    const containerSize = computed(() => {
      var _a, _b;
      return ((_b = (_a = props.items) == null ? void 0 : _a.length) != null ? _b : 0) * itemSize.value;
    });
    const containerStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
    }));
    const currentListOffset = computed(() => renderStartIndex.value * itemSize.value);
    const listStyleComputed = computed(() => ({
      transform: `translate${props.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
    }));
    const scrollToAttribute = computed(() => props.horizontal ? "left" : "top");
    const virtualScrollTo = (index) => {
      var _a;
      if (!index && index !== 0) {
        return;
      }
      (_a = wrapper.value) == null ? void 0 : _a.scrollTo({ [scrollToAttribute.value]: index * itemSize.value });
    };
    return {
      containerStyleComputed,
      wrapperStyleComputed,
      wrapperClassComputed,
      listStyleComputed,
      currentListOffset,
      renderStartIndex,
      virtualScrollTo,
      renderBuffer,
      uniqueKey,
      wrapper,
      list
    };
  }
});
function _sfc_render44(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(["va-virtual-scroller", _ctx.wrapperClassComputed]),
    style: normalizeStyle(_ctx.wrapperStyleComputed)
  }, [
    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ containerStyleComputed: _ctx.containerStyleComputed, listStyleComputed: _ctx.listStyleComputed, renderBuffer: _ctx.renderBuffer, uniqueKey: _ctx.uniqueKey, currentListOffset: _ctx.currentListOffset })), () => [
      createBaseVNode("div", {
        class: "va-virtual-scroller__container",
        style: normalizeStyle(_ctx.containerStyleComputed)
      }, [
        createBaseVNode("div", {
          ref: "list",
          role: "list",
          class: "va-virtual-scroller__list",
          style: normalizeStyle(_ctx.listStyleComputed)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderBuffer, (item, index) => {
            return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
              key: _ctx.uniqueKey(item, index)
            }, { item, index: _ctx.renderStartIndex + index })));
          }), 128))
        ], 4)
      ], 4)
    ])
  ], 6);
}
var _VaVirtualScroller = _export_sfc(_sfc_main46, [["render", _sfc_render44], ["styles", [_style_041]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/index.js
var VaVirtualScroller = withConfigTransport(_VaVirtualScroller);

// node_modules/vuestic-ui/dist/web-components/src/components/va-inner-loading/VaInnerLoading.js
var _style_042 = ':root,\n:host {\n  --va-inner-loading-position: relative;\n  --va-inner-loading-min-width: fit-content;\n  --va-inner-loading-width: 100%;\n  --va-inner-loading-overlay-display: flex;\n  --va-inner-loading-overlay-align-items: center;\n  --va-inner-loading-overlay-justify-content: center;\n  --va-inner-loading-overlay-position: absolute;\n  --va-inner-loading-overlay-top: 0;\n  --va-inner-loading-overlay-bottom: 0;\n  --va-inner-loading-overlay-width: 100%;\n  --va-inner-loading-overlay-background: var(--va-background-primary);\n}\n.inner-loading {\n  position: var(--va-inner-loading-position);\n  min-width: var(--va-inner-loading-min-width);\n  width: var(--va-inner-loading-width);\n  font-family: var(--va-font-family);\n}\n.inner-loading__overlay {\n  display: var(--va-inner-loading-overlay-display);\n  align-items: var(--va-inner-loading-overlay-align-items);\n  justify-content: var(--va-inner-loading-overlay-justify-content);\n  position: var(--va-inner-loading-overlay-position);\n  top: var(--va-inner-loading-overlay-top);\n  bottom: var(--va-inner-loading-overlay-bottom);\n  width: var(--va-inner-loading-overlay-width);\n  z-index: 0;\n}\n.inner-loading__overlay::after {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  background: var(--va-inner-loading-overlay-background);\n  opacity: 0.3;\n  z-index: -1;\n}';
var _sfc_main47 = defineComponent({
  name: "VaInnerLoading",
  components: { VaIcon: VaIcon2 },
  props: {
    ...useLoadingProps,
    ...useComponentPresetProp,
    color: { type: String },
    icon: { type: String, default: "autorenew" },
    size: { type: Number, default: 30 }
  },
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return { colorComputed };
  }
});
var _hoisted_127 = { class: "inner-loading" };
var _hoisted_214 = {
  key: 0,
  class: "inner-loading__overlay",
  "aria-hidden": "true"
};
function _sfc_render45(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", _hoisted_127, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_214, [
      createVNode(_component_va_icon, {
        class: "inner-loading__spinner",
        spin: "",
        color: _ctx.colorComputed,
        size: _ctx.$props.size,
        name: _ctx.$props.icon
      }, null, 8, ["color", "size", "name"])
    ])) : createCommentVNode("", true)
  ]);
}
var _VaInnerLoading = _export_sfc(_sfc_main47, [["render", _sfc_render45], ["styles", [...VaIcon2.styles || [], _style_042]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-inner-loading/index.js
var VaInnerLoading = withConfigTransport(_VaInnerLoading);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/VaDataTable.js
var _style_043 = '.va-data-table {\n  --va-data-table-cell-padding: 0.625rem;\n  --va-data-table-thead-line-height: 1.6;\n  --va-data-table-thead-font-size: 0.625rem;\n  --va-data-table-thead-font-weight: 700;\n  --va-data-table-thead-text-transform: uppercase;\n  --va-data-table-thead-letter-spacing: 0.6px;\n  --va-data-table-thead-border: 1px solid var(--va-background-border);\n  --va-data-table-thead-border-top-shadow: inset 0 1px 0 0 var(--va-background-border);\n  --va-data-table-thead-border-bottom-shadow: inset 0 -1px 0 0 var(--va-background-border);\n  --va-data-table-height: unset;\n  --va-data-table-max-height: unset;\n  --va-data-table-thead-color: currentColor;\n  --va-data-table-tfoot-color: currentColor;\n  --va-data-table-header-background: var(--va-background-primary);\n  /* Hover */\n  --va-data-table-hover-th-opacity: 0.3;\n  /* Striped */\n  --va-data-table-striped-tr-background-color: var(--va-background-element);\n  --va-data-table-striped-tr-opacity: 1;\n  /* Selectable */\n  --va-data-table-selectable-tr-cursor: pointer;\n  --va-data-table-selectable-cell-width: 55px;\n  --va-data-table-selectable-cell-vertical-align: middle;\n  --va-data-table-selectable-cell-text-align: center;\n  /* No-data */\n  --va-data-table-no-data-text-align: center;\n  --va-data-table-no-data-vertical-align: middle;\n  /* Animated */\n  --va-data-table-transition: var(--va-transition);\n  /* Grid */\n  --va-data-table-grid-tbody-gap: 0.5rem;\n  --va-data-table-grid-tbody-margin-top: 1rem;\n  --va-data-table-grid-tr-padding: 1rem;\n  --va-data-table-grid-tr-border-radius: 0.5rem;\n  --va-data-table-grid-tr-border: 1px solid var(--va-background-border);\n  --va-data-table-grid-tr-header-font-weight: 600;\n  --va-data-table-grid-tr-header-color: var(--va-text-primary);\n}\n.va-data-table {\n  --va-data-table-selected-color: var(--1f3a67be);\n  --va-data-table-hover-color: var(--88c618e4);\n  --va-data-table-height--computed: var(--1e63e124);\n  --va-data-table-thead-background--computed: var(--b38615dc);\n  --va-data-table-tfoot-background--computed: var(--b9326fc0);\n  --va-data-table-grid-tbody-columns: 4;\n  min-width: unset;\n  font-family: var(--va-font-family);\n}\n@media (max-width: 1199.98px) {\n.va-data-table {\n    --va-data-table-grid-tbody-columns: 3;\n}\n}\n@media (max-width: 991.98px) {\n.va-data-table {\n    --va-data-table-grid-tbody-columns: 2;\n}\n}\n@media (max-width: 767.98px) {\n.va-data-table {\n    --va-data-table-grid-tbody-columns: 1;\n}\n}\n.va-data-table:not(.va-data-table--virtual-scroller) {\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.va-data-table--sticky:not(.va-data-table--virtual-scroller), .va-data-table--scroll {\n  overflow-y: auto;\n  height: var(--va-data-table-height--computed);\n  max-height: var(--va-data-table-max-height);\n}\n.va-data-table .va-data-table__table {\n  width: 100%;\n  cursor: default;\n  white-space: nowrap;\n}\n.va-data-table .va-data-table__table .va-data-table__table-thead {\n  color: var(--va-data-table-thead-color);\n  border-bottom: var(--va-data-table-thead-border);\n}\n.va-data-table .va-data-table__table .va-data-table__table-thead th {\n  border-bottom: none;\n  box-shadow: var(--va-data-table-thead-border-bottom-shadow);\n}\n.va-data-table .va-data-table__table .va-data-table__table-thead--sticky {\n  position: sticky;\n  top: 0;\n  z-index: 1;\n  background: var(--va-data-table-thead-background--computed);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tbody .no-data {\n  text-align: var(--va-data-table-no-data-text-align);\n  vertical-align: var(--va-data-table-no-data-vertical-align);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tfoot {\n  color: var(--va-data-table-tfoot-color);\n  border-top: var(--va-data-table-thead-border);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tfoot th {\n  border-bottom: none;\n  box-shadow: var(--va-data-table-thead-border-top-shadow);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tfoot--sticky {\n  position: sticky;\n  bottom: 0;\n  z-index: 1;\n  background: var(--va-data-table-tfoot-background--computed);\n}\n.va-data-table .va-data-table__table .va-data-table__table-td {\n  padding: var(--va-data-table-cell-padding);\n  text-align: var(--va-data-table-align);\n  vertical-align: var(--va-data-table-vertical-align);\n}\n.va-data-table .va-data-table__table .va-data-table__table-th.va-data-table__table-cell-select,\n.va-data-table .va-data-table__table .va-data-table__table-td.va-data-table__table-cell-select {\n  width: var(--va-data-table-selectable-cell-width);\n  min-width: var(--va-data-table-selectable-cell-width);\n  text-align: var(--va-data-table-selectable-cell-text-align);\n  vertical-align: var(--va-data-table-selectable-cell-vertical-align);\n  cursor: var(--va-data-table-selectable-tr-cursor);\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-cell-checkbox,\n.va-data-table .va-data-table__table .va-data-table__table-td .va-data-table__table-cell-checkbox {\n  display: block;\n}\n.va-data-table .va-data-table__table .va-data-table__table-tr.selected {\n  background-color: var(--va-data-table-selected-color);\n}\n.va-data-table .va-data-table__table.clickable .va-data-table__table-tr {\n  cursor: pointer;\n}\n.va-data-table .va-data-table__table.striped .va-data-table__table-tr {\n  position: relative;\n  z-index: 0;\n}\n.va-data-table .va-data-table__table.striped .va-data-table__table-tr:nth-child(2n):not(.selected) {\n  z-index: 0;\n}\n.va-data-table .va-data-table__table.striped .va-data-table__table-tr:nth-child(2n):not(.selected)::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-data-table-striped-tr-background-color);\n  opacity: var(--va-data-table-striped-tr-opacity);\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-data-table .va-data-table__table.selectable :not(thead, tfoot) .va-data-table__table-tr:hover, .va-data-table .va-data-table__table.hoverable :not(thead, tfoot) .va-data-table__table-tr:hover {\n  background-color: var(--va-data-table-hover-color);\n}\n.va-data-table .va-data-table__table.selectable :not(thead, tfoot) .va-data-table__table-tr:nth-child(2n):hover, .va-data-table .va-data-table__table.hoverable :not(thead, tfoot) .va-data-table__table-tr:nth-child(2n):hover {\n  background-color: var(--va-data-table-hover-color);\n}\n.va-data-table .va-data-table__table.selectable :not(thead, tfoot) .va-data-table__table-tr:nth-child(2n):hover::after, .va-data-table .va-data-table__table.hoverable :not(thead, tfoot) .va-data-table__table-tr:nth-child(2n):hover::after {\n  background: transparent;\n  opacity: 1;\n}\n.va-data-table .va-data-table__table .table-transition-fade-leave-active {\n  transition: opacity var(--va-data-table-transition);\n}\n.va-data-table .va-data-table__table .table-transition-fade-enter-active {\n  transition: opacity var(--va-data-table-transition) 0.2s;\n}\n.va-data-table .va-data-table__table .table-transition-fade-enter-from,\n.va-data-table .va-data-table__table .table-transition-shuffle-enter-from,\n.va-data-table .va-data-table__table .table-transition-fade-leave-to,\n.va-data-table .va-data-table__table .table-transition-shuffle-leave-to {\n  opacity: 0;\n}\n.va-data-table .va-data-table__table .table-transition-shuffle-move {\n  transition: transform var(--va-data-table-transition);\n}\n.va-data-table .va-data-table__table .table-transition-shuffle-leave-active {\n  transition: none;\n}\n.va-data-table .va-data-table__table .table-transition-shuffle-enter-active {\n  transition: opacity var(--va-data-table-transition);\n}\n.va-data-table__scroll-trigger {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-data-table--grid .va-data-table__table-thead .va-data-table__table-tr {\n  display: flex;\n  justify-content: space-between;\n}\n.va-data-table--grid .va-data-table__table-thead .va-data-table__table-tr .va-data-table__table-th {\n  box-shadow: none;\n}\n@media (max-width: 767.98px) {\n.va-data-table--grid .va-data-table__table-thead .va-data-table__table-tr {\n    flex-direction: column;\n}\n}\n.va-data-table--grid .va-data-table__table-tbody {\n  margin-top: var(--va-data-table-grid-tbody-margin-top);\n  display: grid;\n  grid-template-columns: repeat(var(--081f84ea), minmax(0, 1fr));\n  gap: var(--va-data-table-grid-tbody-gap);\n}\n.va-data-table--grid .va-data-table__table-tbody .va-data-table__table-tr {\n  grid-column: span 1/span 1;\n  padding: var(--va-data-table-grid-tr-padding);\n  display: flex;\n  flex-direction: column;\n  border: var(--va-data-table-grid-tr-border);\n  border-radius: var(--va-data-table-grid-tr-border-radius);\n}\n.va-data-table--grid .va-data-table__table-tbody .va-data-table__table-td {\n  overflow: hidden;\n}\n.va-data-table--grid .selectable .va-data-table__table-tr {\n  cursor: pointer;\n}\n.va-data-table--grid .va-data-table__table-td {\n  display: flex;\n  flex-direction: column;\n}\n.va-data-table--grid .va-data-table__grid-column-header {\n  font-weight: var(--va-data-table-grid-tr-header-font-weight);\n  color: var(--va-data-table-grid-tr-header-color);\n}';
var VaVirtualScrollerProps = extractComponentProps(VaVirtualScroller, ["items", "trackBy", "horizontal", "disabled", "table"]);
var VaDataTableThRowProps = extractComponentProps(VaDataTableThRow);
var __default__8 = defineComponent({
  name: "VaDataTable",
  components: {
    VaDataTableThRow,
    VaVirtualScroller,
    VaInnerLoading,
    VaCheckbox
  },
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    ...VaVirtualScrollerProps,
    ...useAnimationNameProps,
    ...useBindingProps,
    ...useTableScrollProps,
    ...useSortableProps,
    ...useStylableProps,
    ...useColumnsProps,
    ...useFilterableProps,
    ...usePaginatedRowsProps,
    ...useRowsProps,
    ...useSelectableProps2,
    ...useThrottleProps,
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    virtualScroller: { type: Boolean, default: false },
    virtualTrackBy: { type: [String, Number], default: "initialIndex" },
    grid: { type: Boolean, default: false },
    gridColumns: { type: Number, default: 0 }
  },
  emits: [
    "update:modelValue",
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu",
    ...useTableScrollEmits
  ],
  setup(props, { attrs, emit }) {
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props, emit);
    const { paginatedRows } = usePaginatedRows(sortedRows, props);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      toggleRowSelection
    } = useSelectableRow(paginatedRows, props, emit);
    const {
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = useAnimationName(props, paginatedRows);
    const showNoDataHtml = computed(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      if (props.clickable) {
        emit(name, {
          event,
          item: row.source,
          itemIndex: row.initialIndex
        });
      }
      if (props.selectable && props.grid) {
        toggleRowSelection(row);
      }
    };
    const computedTableAttributes = computed(() => ({
      ...omit_1(attrs, ["class", "style"]),
      class: pick_1(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const virtualScrollerPropsComputed = computed(() => ({
      ...pick_1(props, ["wrapperSize", "itemSize", "bench"]),
      items: paginatedRows.value,
      trackBy: props.virtualTrackBy,
      disabled: !props.virtualScroller,
      table: true
    }));
    const computedAttributes = computed(() => ({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        { "va-data-table--virtual-scroller": isVirtualScroll.value },
        { "va-data-table--grid": props.grid },
        attrs.class
      ],
      style: [attrs.style],
      ...virtualScrollerPropsComputed.value
    }));
    const thAttributesComputed = computed(() => ({
      ...filterComponentProps(VaDataTableThRowProps).value,
      columns: columnsComputed.value,
      sortingOrderIconName: sortingOrderIconName.value,
      severalRowsSelected: severalRowsSelected.value,
      sortingOrderSync: sortingOrderSync.value,
      allRowsSelected: allRowsSelected.value,
      sortBySync: sortBySync.value
    }));
    const {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      doRenderTopTrigger,
      doRenderBottomTrigger
    } = useTableScroll(props, emit);
    const isVirtualScroll = computed(() => props.virtualScroller && !props.grid);
    const gridColumnsCount = computed(() => props.gridColumns || "var(--va-data-table-grid-tbody-columns)");
    return {
      ...useTranslation(),
      scrollContainer,
      topTrigger,
      bottomTrigger,
      columnsComputed,
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      toggleSorting,
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2,
      thAttributesComputed,
      showNoDataHtml,
      showNoDataFilteredHtml,
      onRowClickHandler,
      computedAttributes,
      computedTableAttributes,
      animationName,
      getRowBind,
      getCellBind,
      doRenderTopTrigger,
      doRenderBottomTrigger,
      isVirtualScroll,
      gridColumnsCount
    };
  }
});
var __injectCSSVars__8 = () => {
  useCssVars((_ctx) => ({
    "1f3a67be": _ctx.CSSVariables.selectedColor,
    "88c618e4": _ctx.CSSVariables.hoverColor,
    "1e63e124": _ctx.CSSVariables.tableHeight,
    "b38615dc": _ctx.CSSVariables.theadBg,
    "b9326fc0": _ctx.CSSVariables.tfootBg,
    "081f84ea": _ctx.gridColumnsCount
  }));
};
var __setup__8 = __default__8.setup;
__default__8.setup = __setup__8 ? (props, ctx) => {
  __injectCSSVars__8();
  return __setup__8(props, ctx);
} : __injectCSSVars__8;
var _sfc_main48 = __default__8;
var _hoisted_128 = {
  key: 0,
  ref: "topTrigger",
  class: "va-data-table__scroll-trigger"
};
var _hoisted_215 = { key: 0 };
var _hoisted_38 = {
  ref: "list",
  class: "va-data-table__table-tbody"
};
var _hoisted_48 = { key: "showNoDataHtml" };
var _hoisted_57 = ["colspan", "innerHTML"];
var _hoisted_65 = { key: "showNoDataFilteredHtml" };
var _hoisted_73 = ["colspan", "innerHTML"];
var _hoisted_82 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_92 = {
  key: 0,
  class: "va-data-table__grid-column-header"
};
var _hoisted_10 = {
  key: 1,
  ref: "bottomTrigger",
  class: "va-data-table__scroll-trigger"
};
function _sfc_render46(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_data_table_th_row = resolveComponent("va-data-table-th-row");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_inner_loading = resolveComponent("va-inner-loading");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createBlock(_component_va_virtual_scroller, mergeProps({ class: "va-data-table" }, _ctx.computedAttributes, { ref: "scrollContainer" }), {
    content: withCtx(({
      uniqueKey,
      renderBuffer,
      currentListOffset,
      listStyleComputed,
      containerStyleComputed
    }) => [
      createVNode(_component_va_inner_loading, {
        "aria-live": "polite",
        style: normalizeStyle(containerStyleComputed),
        loading: _ctx.loading,
        color: _ctx.loadingColor
      }, {
        default: withCtx(() => [
          _ctx.doRenderTopTrigger ? (openBlock(), createElementBlock("div", _hoisted_128, null, 512)) : createCommentVNode("", true),
          createBaseVNode("table", mergeProps({
            class: "va-data-table__table",
            style: listStyleComputed
          }, _ctx.computedTableAttributes), [
            "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_215, [
              renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(_ctx.columnsComputed)))
            ])) : createCommentVNode("", true),
            createBaseVNode("thead", {
              class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }]),
              style: normalizeStyle({ top: _ctx.isVirtualScroll && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0 })
            }, [
              renderSlot(_ctx.$slots, "headerPrepend"),
              !_ctx.hideDefaultHeader ? (openBlock(), createBlock(_component_va_data_table_th_row, mergeProps({ key: 0 }, _ctx.thAttributesComputed, {
                onToggleBulkSelection: _ctx.toggleBulkSelection,
                onToggleSorting: _ctx.toggleSorting
              }), createSlots({ _: 2 }, [
                renderList(_ctx.$slots, (_, slot) => {
                  return {
                    name: slot,
                    fn: withCtx((scope) => [
                      renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(scope)))
                    ])
                  };
                })
              ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "headerAppend")
            ], 6),
            createBaseVNode("tbody", _hoisted_38, [
              renderSlot(_ctx.$slots, "bodyPrepend"),
              createVNode(TransitionGroup, {
                name: _ctx.isVirtualScroll ? "" : _ctx.animationName,
                css: !_ctx.$props.virtualScroller,
                appear: !_ctx.$props.virtualScroller
              }, {
                default: withCtx(() => [
                  _ctx.showNoDataHtml ? (openBlock(), createElementBlock("tr", _hoisted_48, [
                    createBaseVNode("td", {
                      class: "no-data",
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataHtml
                    }, null, 8, _hoisted_57)
                  ])) : _ctx.showNoDataFilteredHtml ? (openBlock(), createElementBlock("tr", _hoisted_65, [
                    createBaseVNode("td", {
                      class: "no-data",
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataFilteredHtml
                    }, null, 8, _hoisted_73)
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer, (row, index) => {
                    return openBlock(), createElementBlock("tr", mergeProps({
                      key: `table-row_${uniqueKey(row, index)}`,
                      class: ["va-data-table__table-tr", [{ selected: _ctx.isRowSelected(row) }]]
                    }, _ctx.getRowBind(row), {
                      onClick: ($event) => _ctx.onRowClickHandler("row:click", $event, row),
                      onDblclick: ($event) => _ctx.onRowClickHandler("row:dblclick", $event, row),
                      onContextmenu: ($event) => _ctx.onRowClickHandler("row:contextmenu", $event, row)
                    }), [
                      _ctx.selectable && !_ctx.$props.grid ? (openBlock(), createElementBlock("td", {
                        class: "va-data-table__table-td va-data-table__table-cell-select",
                        key: `selectable_${uniqueKey(row, index)}`,
                        onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                        }, ["prevent"]))
                      }, [
                        createVNode(_component_va_checkbox, {
                          class: "va-data-table__table-cell-checkbox",
                          "model-value": _ctx.isRowSelected(row),
                          color: _ctx.selectedColor,
                          "aria-label": _ctx.t(`selectRowByIndex`, { index: row.initialIndex }),
                          onClick: [
                            withModifiers(($event) => _ctx.shiftSelectRows(row), ["shift", "exact", "stop"]),
                            withModifiers(($event) => _ctx.ctrlSelectRow(row), ["ctrl", "exact", "stop"]),
                            withModifiers(($event) => _ctx.ctrlSelectRow(row), ["exact", "stop"])
                          ]
                        }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                      ], 32)) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell, cellIndex) => {
                        return openBlock(), createElementBlock("td", mergeProps({
                          key: `table-cell_${cell.column.name + cell.rowIndex}`,
                          class: ["va-data-table__table-td", _ctx.getClass(cell.column.tdClass)],
                          style: [_ctx.getCellCSSVariables(cell), _ctx.getStyle(cell.column.tdStyle)]
                        }, _ctx.getCellBind(cell, row)), [
                          `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, cell))) : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, cell)), () => [
                            _ctx.$props.grid ? (openBlock(), createElementBlock("span", _hoisted_92, toDisplayString(_ctx.columnsComputed[cellIndex].label), 1)) : createCommentVNode("", true),
                            createTextVNode(" " + toDisplayString(cell.value), 1)
                          ])
                        ], 16);
                      }), 128))
                    ], 16, _hoisted_82);
                  }), 128))
                ]),
                _: 2
              }, 1032, ["name", "css", "appear"]),
              renderSlot(_ctx.$slots, "bodyAppend")
            ], 512),
            _ctx.footerClone && !_ctx.$props.grid ? (openBlock(), createElementBlock("tfoot", {
              key: 1,
              class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }]),
              style: normalizeStyle({ bottom: _ctx.isVirtualScroll && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0 })
            }, [
              renderSlot(_ctx.$slots, "footerPrepend"),
              !_ctx.hideDefaultHeader ? (openBlock(), createBlock(_component_va_data_table_th_row, mergeProps({ key: 0 }, _ctx.thAttributesComputed, {
                "is-footer": "",
                onToggleBulkSelection: _ctx.toggleBulkSelection,
                onToggleSorting: _ctx.toggleSorting
              }), createSlots({ _: 2 }, [
                renderList(_ctx.$slots, (_, slot) => {
                  return {
                    name: slot,
                    fn: withCtx((scope) => [
                      renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(scope)))
                    ])
                  };
                })
              ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "footerAppend")
            ], 6)) : createCommentVNode("", true)
          ], 16),
          _ctx.doRenderBottomTrigger ? (openBlock(), createElementBlock("div", _hoisted_10, null, 512)) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1032, ["style", "loading", "color"])
    ]),
    _: 3
  }, 16);
}
var _VaDataTable = _export_sfc(_sfc_main48, [["render", _sfc_render46], ["styles", [...VaDataTableThRow.styles || [], ...VaVirtualScroller.styles || [], ...VaInnerLoading.styles || [], ...VaCheckbox.styles || [], _style_043]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/index.js
var VaDataTable = withConfigTransport(_VaDataTable);

// node_modules/vuestic-ui/dist/web-components/src/composables/useParsable.js
var useParsable = (parsable, parse2, format) => {
  const text = computed({
    get() {
      const value2 = parsable.value;
      if (typeof value2 === "string") {
        return value2;
      }
      return format(value2);
    },
    set(v) {
      if (typeof parsable.value === "string") {
        parsable.value = v;
      } else {
        parsable.value = parse2(v);
      }
    }
  });
  const value = computed({
    get() {
      if (typeof parsable.value === "string") {
        return parse2(parsable.value);
      }
      return parsable.value;
    },
    set(v) {
      if (typeof parsable.value === "string") {
        parsable.value = format(v);
      } else {
        parsable.value = v;
      }
    }
  });
  return {
    text,
    value
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/sync-prop.js
function useSyncProp2(propRef, propName, emit, defaultValue) {
  if (defaultValue === void 0) {
    return {
      syncProp: computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return propRef.value;
        }
      })
    };
  }
  const statefulValue = ref(defaultValue);
  return {
    syncProp: computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return (propRef == null ? void 0 : propRef.value) === void 0 ? statefulValue.value : propRef.value;
      }
    })
  };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/input-text-parser.js
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d) => isDate_1(d) && !isNaN(d.getTime());
var useDateParser = (props) => {
  const isMultipleDates = (text) => text.includes(props.delimiter);
  const isRange3 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props.parseDate || defaultParseDateFunction)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange3(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/model-value-parser.js
var isRange = (date) => {
  return typeof date === "object" && ("start" in date || "end" in date);
};
var parseSingleDate = (date) => typeof date === "string" ? defaultParseDateFunction(date) : new Date(date);
var parseModelValue = (date) => {
  if (Array.isArray(date)) {
    return date.map(parseSingleDate);
  }
  if (isRange(date)) {
    return {
      start: isNil_1(date.start) ? date.start : parseSingleDate(date.start),
      end: isNil_1(date.end) ? date.end : parseSingleDate(date.end)
    };
  }
  return parseSingleDate(date);
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/range-model-value-guard.js
var useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {
  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange(bufferValue.value)) {
      bufferValue.value = modelValue.value && parseValue(modelValue.value);
    }
  };
  return {
    valueComputed,
    reset
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/utils/date-utils.js
var isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = new Date();
  date.setFullYear(year);
  return date;
};
var isRange2 = (value) => {
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate = (value) => isDate_1(value);
var isDates = (value) => Array.isArray(value);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/view.js
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
  } else {
    return { ...view, month: view.month + 1 };
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
  } else {
    return { ...view, month: view.month - 1 };
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate_1(modelValue)) {
    return modelValue;
  }
  if (isDate_1(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate_1(modelValue[0])) {
    return modelValue[0];
  }
  return new Date();
};
var useView = (props, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = {
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth(),
    ...defaultOverride
  };
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return { ...statefulView.value, ...props.view };
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
    }
  };
  return {
    syncView,
    next,
    prev
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/grid-keyboard-navigation.js
function isUndefined(t) {
  return t === void 0;
}
var useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked = false;
  const onMousedown = () => {
    previouslyClicked = true;
  };
  const onFocus = () => {
    if (previouslyClicked) {
      return;
    }
    previouslyClicked = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e.key)) {
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === "Enter" || e.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/model-value-helper.js
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate(modelValue)) {
    return "single";
  } else if (isRange2(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange2(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props.modelValue.filter((d) => !dateEqual(d, date)));
      } else {
        emit("update:modelValue", [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/use-picker.js
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(
    props,
    emit,
    datesEqual
  );
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d) => datesEqual(d, date));
    } else if (isRange2(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange2(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDayPicker/va-date-picker-calendar-hook.js
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k) => k + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a;
    if (options && ((_a = options.firstWeekday) == null ? void 0 : _a.value) === "Monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d) => new Date(view.value.year, view.value.month - 1, d));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d) => new Date(view.value.year, view.value.month, d));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d) => new Date(view.value.year, view.value.month + 1, d))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDatePickerCell.js
var _style_044 = '.va-date-picker-cell {\n  position: relative;\n  color: var(--va-date-picker-text-color);\n  line-height: var(--va-date-picker-cell-size);\n  min-height: var(--va-date-picker-cell-size);\n  min-width: var(--va-date-picker-cell-size);\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  border-radius: var(--va-date-picker-cell-radius);\n  box-sizing: border-box;\n  text-align: center;\n  z-index: 1;\n}\n.va-date-picker-cell::after, .va-date-picker-cell::before {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  z-index: -1;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  box-sizing: border-box;\n  border-radius: var(--va-date-picker-cell-radius);\n}\n.va-date-picker-cell_clear {\n  cursor: default;\n  opacity: 0;\n}\n.va-date-picker-cell_highlighted-weekend {\n  color: var(--va-date-picker-weekends-color);\n}\n.va-date-picker-cell_in-range {\n  color: var(--va-date-picker-color);\n}\n.va-date-picker-cell_in-range::after {\n  background-color: var(--va-date-picker-selected-background);\n  opacity: var(--va-date-picker-cell-background-opacity-hover);\n}\n.va-date-picker-cell_today {\n  color: var(--va-date-picker-color);\n  font-weight: bold;\n}\n.va-date-picker-cell_today::before {\n  border: 2px solid var(--va-date-picker-color);\n}\n.va-date-picker-cell_selected {\n  background-color: var(--4287396d);\n  color: var(--6cf74d8a);\n}\n.va-date-picker-cell_other-month {\n  opacity: var(--va-date-picker-cell-opacity);\n}\n.va-date-picker-cell:hover:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month), .va-date-picker-cell_focused:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month), .va-date-picker-cell_focused:hover:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month) {\n  color: var(--va-date-picker-color);\n}\n.va-date-picker-cell:hover:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month)::after, .va-date-picker-cell_focused:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month)::after, .va-date-picker-cell_focused:hover:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month)::after {\n  background-color: var(--va-date-picker-selected-background);\n  opacity: var(--va-date-picker-cell-background-opacity-hover);\n}\n.va-date-picker-cell_disabled {\n  cursor: not-allowed;\n  opacity: var(--va-date-picker-cell-opacity);\n}\n.va-date-picker-cell_disabled:not(.va-date-picker-cell_today) {\n  opacity: 0.5;\n}\n.va-date-picker-cell_disabled::after {\n  opacity: var(--va-date-picker-cell-opacity);\n  border: none;\n  height: 2px;\n  width: 50%;\n  background: currentColor;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.va-date-picker-cell_readonly {\n  cursor: default;\n}\n.va-date-picker-cell_readonly::before {\n  display: none;\n}';
var __default__9 = defineComponent({
  name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const onClick = () => {
      if (!props.disabled) {
        emit("click");
      }
    };
    const { getColor } = useColors();
    const bg = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(bg);
    return {
      bg,
      onClick,
      textColorComputed
    };
  }
});
var __injectCSSVars__9 = () => {
  useCssVars((_ctx) => ({
    "4287396d": _ctx.bg,
    "6cf74d8a": _ctx.textColorComputed
  }));
};
var __setup__9 = __default__9.setup;
__default__9.setup = __setup__9 ? (props, ctx) => {
  __injectCSSVars__9();
  return __setup__9(props, ctx);
} : __injectCSSVars__9;
var _sfc_main49 = __default__9;
var _hoisted_129 = {
  key: 0,
  class: "va-date-picker-cell va-date-picker-cell_clear"
};
function _sfc_render47(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.hidden ? (openBlock(), createElementBlock("div", _hoisted_129)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["va-date-picker-cell", {
      "va-date-picker-cell_other-month": _ctx.otherMonth,
      "va-date-picker-cell_today": _ctx.highlightToday && _ctx.today,
      "va-date-picker-cell_in-range": _ctx.inRange,
      "va-date-picker-cell_disabled": _ctx.disabled,
      "va-date-picker-cell_highlighted-weekend": _ctx.highlightWeekend && _ctx.weekend,
      "va-date-picker-cell_selected": _ctx.selected,
      "va-date-picker-cell_focused": _ctx.focused,
      "va-date-picker-cell_readonly": _ctx.readonly
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
    onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["prevent", "stop"]), ["space", "enter"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34));
}
var VaDatePickerCell = _export_sfc(_sfc_main49, [["render", _sfc_render47], ["styles", [_style_044]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
var _style_045 = ".va-day-picker {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  grid-gap: var(--va-date-picker-cell-gap);\n}\n.va-day-picker__weekday {\n  height: var(--va-date-picker-cell-size);\n  color: var(--va-secondary);\n  text-align: center;\n  font-size: var(--va-date-picker-weekday-font-size);\n  font-weight: bold;\n  line-height: var(--va-date-picker-cell-size);\n}";
var _sfc_main50 = defineComponent({
  name: "VaDayPicker",
  components: { VaDatePickerCell },
  props: {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(props, { emit }) {
    const { firstWeekday, weekdayNames, view } = toRefs(props);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value === "Sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props, emit);
    const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return {
      hoveredIndex,
      calendarDates,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isOtherMonth,
      isDateDisabled,
      isDateWeekend,
      containerAttributes,
      weekdayNamesComputed,
      focusedCellIndex
    };
  }
});
var _hoisted_130 = ["onMouseenter"];
var _hoisted_216 = { class: "va-date-picker-cell__day" };
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, _ctx.containerAttributes), [
    !_ctx.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.weekdayNamesComputed, (weekday) => {
      return openBlock(), createElementBlock("div", {
        key: weekday,
        class: "va-day-picker__weekday"
      }, [
        renderSlot(_ctx.$slots, "weekday", {}, () => [
          createTextVNode(toDisplayString(weekday), 1)
        ])
      ]);
    }), 128)) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.calendarDates, (date, index) => {
      return openBlock(), createElementBlock("div", {
        class: "va-day-picker__calendar__day-wrapper",
        key: index,
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          hidden: _ctx.isOtherMonth(date) && !_ctx.showOtherMonths,
          today: _ctx.isToday(date),
          selected: _ctx.isSelected(date),
          "in-range": _ctx.isInRange(date),
          "other-month": _ctx.isOtherMonth(date),
          weekend: _ctx.isDateWeekend(date),
          disabled: _ctx.isDateDisabled(date),
          focused: _ctx.hoveredIndex === index,
          "highlight-today": _ctx.highlightToday,
          "highlight-weekend": _ctx.highlightWeekend,
          readonly: _ctx.$props.readonly,
          color: _ctx.color,
          onClick: ($event) => {
            _ctx.onClick(date);
            _ctx.focusedCellIndex = index;
          }
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_216, [
              renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                createTextVNode(toDisplayString(date.getDate()), 1)
              ])
            ])
          ]),
          _: 2
        }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "color", "onClick"])
      ], 40, _hoisted_130);
    }), 128))
  ], 16);
}
var VaDayPicker = _export_sfc(_sfc_main50, [["render", _sfc_render48], ["styles", [...VaDatePickerCell.styles || [], _style_045]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.js
var _style_046 = ".va-date-picker__header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.va-date-picker__header__text {\n  color: currentColor;\n}\n.va-date-picker__header__month {\n  margin-left: 0.25rem;\n}";
var _sfc_main51 = defineComponent({
  name: "VaDatePickerHeader",
  components: { VaButton: VaButton2 },
  emits: ["update:view"],
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String },
    textColor: { type: String },
    disabled: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { syncView, prev, next } = useView(props, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = { ...syncView.value, type: "month" };
      } else if (syncView.value.type === "month") {
        syncView.value = { ...syncView.value, type: "year" };
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    return {
      ...useTranslation(),
      prev,
      next,
      changeView,
      switchView,
      syncView
    };
  }
});
var _hoisted_131 = { class: "va-date-picker__header__text" };
var _hoisted_217 = { class: "va-date-picker__header__month" };
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.syncView.type !== "year" ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-date-picker-header va-date-picker__header",
    style: normalizeStyle({ color: _ctx.textColor })
  }, [
    renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: _ctx.prev })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "va-arrow-left",
        preset: "plain",
        size: "small",
        color: _ctx.color,
        textColor: _ctx.textColor,
        "aria-label": _ctx.t("nextPeriod"),
        round: "",
        onClick: _ctx.prev
      }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
    ]),
    createBaseVNode("div", _hoisted_131, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year, month: _ctx.syncView.month, monthNames: _ctx.monthNames, view: _ctx.syncView, changeView: _ctx.changeView, switchView: _ctx.switchView })), () => [
        createVNode(_component_va_button, {
          disabled: _ctx.$props.disabled,
          preset: "plain",
          size: "small",
          color: _ctx.color,
          textColor: _ctx.textColor,
          "aria-label": _ctx.t("switchView"),
          onClick: _ctx.switchView
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year })), () => [
              createTextVNode(toDisplayString(_ctx.syncView.year), 1)
            ]),
            _ctx.syncView.type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: _ctx.syncView.month })), () => [
              createBaseVNode("span", _hoisted_217, toDisplayString(_ctx.monthNames[_ctx.syncView.month]), 1)
            ]) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
      ])
    ]),
    renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: _ctx.next })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "va-arrow-right",
        preset: "plain",
        size: "small",
        color: _ctx.color,
        textColor: _ctx.textColor,
        "aria-label": _ctx.t("previousPeriod"),
        onClick: _ctx.next,
        round: ""
      }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
    ])
  ], 4)) : createCommentVNode("", true);
}
var VaDatePickerHeader = _export_sfc(_sfc_main51, [["render", _sfc_render49], ["styles", [...VaButton2.styles || [], _style_046]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.js
var _style_047 = ".va-month-picker {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: var(--va-date-picker-cell-gap);\n  min-width: calc(var(--va-date-picker-cell-size) * 7 + var(--va-date-picker-cell-gap) * 6);\n  width: 100%;\n}\n.va-month-picker__month-wrapper {\n  border-radius: var(--va-date-picker-cell-radius);\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  overflow: hidden;\n}";
var _sfc_main52 = defineComponent({
  name: "VaMonthPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(props, { emit }) {
    const { view } = toRefs(props);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props, emit);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      months,
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isDisabled,
      containerAttributes,
      focusedCellIndex
    };
  }
});
var _hoisted_132 = ["onMouseenter"];
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, _ctx.containerAttributes), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.months, (month, monthIndex) => {
      return openBlock(), createElementBlock("div", {
        key: monthIndex,
        class: "va-month-picker__month-wrapper",
        onMouseenter: ($event) => _ctx.hoveredIndex = monthIndex,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          "in-range": !!_ctx.isInRange(month),
          selected: !!_ctx.isSelected(month),
          disabled: !!_ctx.isDisabled(month),
          today: !!_ctx.isToday(month),
          focused: _ctx.hoveredIndex === monthIndex,
          "highlight-today": _ctx.highlightToday,
          readonly: _ctx.$props.readonly,
          color: _ctx.color,
          onClick: ($event) => {
            _ctx.onClick(month);
            _ctx.focusedCellIndex = monthIndex;
          }
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: _ctx.monthNames[monthIndex] })), () => [
              createTextVNode(toDisplayString(_ctx.monthNames[monthIndex]), 1)
            ])
          ]),
          _: 2
        }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick"])
      ], 40, _hoisted_132);
    }), 128))
  ], 16);
}
var VaMonthPicker = _export_sfc(_sfc_main52, [["render", _sfc_render50], ["styles", [...VaDatePickerCell.styles || [], _style_047]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.js
var _style_048 = ".va-year-picker {\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  grid-gap: var(--va-date-picker-cell-gap);\n  max-height: 100%;\n  position: relative;\n}";
var _sfc_main53 = defineComponent({
  name: "VaYearPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: Number, default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: Number, default: () => new Date().getFullYear() + 50 },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(props, { emit }) {
    const rootNode = shallowRef();
    const { view } = toRefs(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i) => createYearDate(start + i));
    };
    const years = computed(() => generateYearsArray(props.startYear, props.endYear));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props, emit);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      hoveredIndex,
      years,
      rootNode,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isYearDisabled,
      focusedCellIndex,
      containerAttributes
    };
  }
});
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "rootNode",
    class: "va-year-picker"
  }, _ctx.containerAttributes, {
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
    }, ["prevent"]), ["space"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
      return openBlock(), createBlock(_component_va_date_picker_cell, {
        key: year.toString(),
        "in-range": _ctx.isInRange(year),
        selected: _ctx.isSelected(year),
        disabled: _ctx.isYearDisabled(year),
        today: _ctx.isToday(year),
        focused: _ctx.focusedCellIndex === index,
        "highlight-today": _ctx.highlightToday,
        readonly: _ctx.$props.readonly,
        color: _ctx.color,
        onClick: ($event) => {
          _ctx.onClick(year);
          _ctx.focusedCellIndex = index;
        },
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(year.getFullYear()), 1)
        ]),
        _: 2
      }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick", "onMouseenter"]);
    }), 128))
  ], 16);
}
var VaYearPicker = _export_sfc(_sfc_main53, [["render", _sfc_render51], ["styles", [...VaDatePickerCell.styles || [], _style_048]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/VaDatePicker.js
var _style_049 = ':root,\n:host {\n  /* Font */\n  --va-date-picker-font-style: normal;\n  --va-date-picker-font-weight: 600;\n  --va-date-picker-font-size: 12px;\n  --va-date-picker-line-height: 1.25;\n  --va-date-picker-weekday-font-size: 9px;\n  /* Colors */\n  --va-date-picker-color: var(--va-primary);\n  --va-date-picker-text-color: inherit;\n  /* Sizes */\n  --va-date-picker-cell-size: 32px;\n  --va-date-picker-cell-gap: 2px;\n  --va-date-picker-cell-radius: 4px;\n  /* Selected cell */\n  --va-date-picker-selected-text: var(--va-text-inverted);\n  --va-date-picker-selected-background: var(--va-date-picker-color);\n  /* Today cell */\n  --va-date-picker-today-background: var(--va-date-picker-color);\n  --va-date-picker-today-background-opacity: 0.8;\n  /* Weekend */\n  --va-date-picker-weekends-color: var(--va-danger);\n  /* Focused */\n  --va-date-picker-focused-border-color: var(--va-date-picker-color);\n  /* Opacity */\n  --va-date-picker-cell-opacity: 0.5;\n  --va-date-picker-cell-background-opacity-hover: 0.1;\n  --va-date-picker-cell-selected-background-opacity-hover: 0.8;\n}\n.va-date-picker {\n  --va-date-picker-content-height: calc(var(--va-date-picker-cell-size) * 7 + var(--va-date-picker-cell-gap) * 6);\n  width: calc(var(--va-date-picker-cell-size) * 7 + var(--va-date-picker-cell-gap) * 6);\n  font-family: var(--va-font-family);\n  font-style: var(--va-date-picker-font-style);\n  font-weight: var(--va-date-picker-font-weight);\n  font-size: var(--va-date-picker-font-size);\n  line-height: var(--va-date-picker-line-height);\n}\n.va-date-picker__picker-wrapper {\n  height: var(--va-date-picker-content-height);\n}\n.va-date-picker_without-week-days {\n  --va-date-picker-content-height: calc(var(--va-date-picker-cell-size) * 6 + var(--va-date-picker-cell-gap) * 6);\n}\n.va-date-picker_mobile .va-day-picker,\n.va-date-picker_mobile .va-month-picker,\n.va-date-picker_mobile .va-year-picker {\n  height: 100%;\n}\n.va-date-picker_disabled {\n  opacity: 0.4;\n  position: relative;\n}\n.va-date-picker_disabled::before {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 100;\n}\n.va-date-picker-header {\n  padding-bottom: 0.25rem;\n}';
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var _sfc_main54 = defineComponent({
  name: "VaDatePicker",
  components: { VaDayPicker, VaDatePickerHeader, VaMonthPicker, VaYearPicker },
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...extractComponentProps(VaDatePickerHeader),
    ...extractComponentProps(VaDayPicker),
    ...extractComponentProps(VaMonthPicker),
    ...extractComponentProps(VaYearPicker),
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  },
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(VaDatePickerHeader),
    ...extractComponentEmits(VaYearPicker),
    ...extractComponentEmits(VaDayPicker),
    ...extractComponentEmits(VaMonthPicker)
  ],
  setup(props, { emit }) {
    const currentPicker = ref();
    const { valueComputed } = useStateful(props, emit);
    const { syncView } = useView(props, emit, { type: props.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const { background } = useElementBackground();
    const { textColorComputed } = useTextColor(background);
    const styleComputed = computed(() => ({
      color: textColorComputed.value,
      ...colorsToCSSVariable({
        color: props.color,
        "weekends-color": props.weekendsColor
      }, "va-date-picker")
    }));
    const focusCurrentPicker = () => {
      var _a;
      return (_a = currentPicker.value) == null ? void 0 : _a.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    return {
      dayPickerProps: filterComponentProps(extractComponentProps(VaDayPicker)),
      headerProps: filterComponentProps(extractComponentProps(VaDatePickerHeader)),
      monthPickerProps: filterComponentProps(extractComponentProps(VaMonthPicker)),
      yearPickerProps: filterComponentProps(extractComponentProps(VaYearPicker)),
      syncView,
      classComputed,
      valueComputed,
      onDayModelValueUpdate,
      onMonthClick,
      onMonthModelValueUpdate,
      onYearClick,
      onYearModelValueUpdate,
      styleComputed,
      currentPicker,
      textColorComputed,
      focusCurrentPicker,
      isPickerReadonly
    };
  }
});
var _hoisted_133 = { class: "va-date-picker__picker-wrapper" };
function _sfc_render52(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_header = resolveComponent("va-date-picker-header");
  const _component_va_day_picker = resolveComponent("va-day-picker");
  const _component_va_month_picker = resolveComponent("va-month-picker");
  const _component_va_year_picker = resolveComponent("va-year-picker");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-date-picker", _ctx.classComputed]),
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    createVNode(_component_va_date_picker_header, mergeProps(_ctx.headerProps, {
      view: _ctx.syncView,
      "onUpdate:view": _cache[0] || (_cache[0] = ($event) => _ctx.syncView = $event),
      textColor: _ctx.textColorComputed
    }), createSlots({ _: 2 }, [
      renderList(_ctx.$slots, (_, name) => {
        return {
          name,
          fn: withCtx((bind) => [
            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
          ])
        };
      })
    ]), 1040, ["view", "textColor"]),
    createBaseVNode("div", _hoisted_133, [
      _ctx.syncView.type === "day" ? (openBlock(), createBlock(_component_va_day_picker, mergeProps({
        key: 0,
        ref: "currentPicker"
      }, _ctx.dayPickerProps, {
        "model-value": _ctx.valueComputed,
        view: _ctx.syncView,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("day"),
        "onUpdate:modelValue": _ctx.onDayModelValueUpdate,
        "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
        "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["model-value", "view", "readonly", "onUpdate:modelValue"])) : createCommentVNode("", true),
      _ctx.syncView.type === "month" ? (openBlock(), createBlock(_component_va_month_picker, mergeProps({
        key: 1,
        ref: "currentPicker"
      }, _ctx.monthPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("month"),
        "onUpdate:modelValue": _ctx.onMonthModelValueUpdate,
        "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
        "onClick:month": _ctx.onMonthClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:month"])) : createCommentVNode("", true),
      _ctx.syncView.type === "year" ? (openBlock(), createBlock(_component_va_year_picker, mergeProps({
        key: 2,
        ref: "currentPicker"
      }, _ctx.yearPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("year"),
        "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
        "onUpdate:modelValue": _ctx.onYearModelValueUpdate,
        "onClick:year": _ctx.onYearClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:year"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var _VaDatePicker = _export_sfc(_sfc_main54, [["render", _sfc_render52], ["styles", [...VaDayPicker.styles || [], ...VaDatePickerHeader.styles || [], ...VaMonthPicker.styles || [], ...VaYearPicker.styles || [], _style_049]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/VaDateInput.js
var _style_050 = ".va-date-input {\n  --va-date-picker-cell-size: 28px;\n  min-width: var(--va-date-input-min-width);\n  font-family: var(--va-font-family);\n}\n.va-date-input__anchor {\n  flex: 1;\n}\n.va-date-input__input:-moz-read-only {\n  cursor: pointer;\n}\n.va-date-input__input:read-only {\n  cursor: pointer;\n}\n.va-date-input__dropdown-content {\n  display: flex;\n  justify-content: center;\n}";
var VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue", "disabled"]);
var VaDatePickerProps = extractComponentProps(_VaDatePicker);
var VaDropdownProps2 = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "offset", "keyboardNavigation", "closeOnContentClick", "modelValue"]
);
var _sfc_main55 = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon: VaIcon2
  },
  props: {
    ...VaDropdownProps2,
    ...useClearableProps,
    ...VaInputWrapperProps,
    ...VaDatePickerProps,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" }
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp2(isOpen, "is-open", emit, false);
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange2(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      ariaHidden: false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const computedInputWrapperProps = computed(() => ({
      ...filterComponentProps(VaInputWrapperProps).value,
      focused: isFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { t } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || t("selectedDate"),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit_1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps2).value,
      offset: [2, 0],
      stateful: false,
      keyboardNavigation: true,
      closeOnContentClick: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      t,
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      isFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(VaDatePickerProps),
      dropdownPropsComputed,
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      cursorStyleComputed,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.isOpenSync = $event),
    class: ["va-date-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed, {
    onOpen: _ctx.focusDatePicker,
    onClose: _ctx.focus
  }), {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputAttributes: _ctx.inputAttributesComputed, inputWrapperProps: _ctx.inputWrapperProps, inputListeners: _ctx.inputListeners })), () => [
        createVNode(_component_va_input_wrapper, mergeProps({
          class: "va-date-input__anchor",
          style: _ctx.cursorStyleComputed
        }, _ctx.inputWrapperProps, {
          onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
        }), createSlots({
          default: withCtx(() => [
            createBaseVNode("input", mergeProps({
              ref: "input",
              class: "va-date-input__input"
            }, _ctx.inputAttributesComputed, toHandlers(_ctx.inputListeners), {
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
            }), null, 16)
          ]),
          icon: withCtx(() => [
            _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.t("resetDate")
            }, { ..._ctx.iconProps, ..._ctx.clearIconProps }, {
              onClick: withModifiers(_ctx.reset, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 1,
              "aria-label": _ctx.t("toggleDropdown")
            }, _ctx.iconProps, {
              onClick: withModifiers(_ctx.showDropdown, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.filterSlots, (name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          }),
          _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
            name: "prependInner",
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
              _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                "aria-label": _ctx.t("toggleDropdown")
              }, _ctx.iconProps, {
                onClick: withModifiers(_ctx.showDropdown, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
            ])
          } : void 0
        ]), 1040, ["style", "onClick"])
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, { class: "va-date-input__dropdown-content" }, {
        default: withCtx(() => [
          createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
            modelValue: _ctx.valueWithoutText,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueWithoutText = $event),
            "onClick:day": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:day", $event)),
            "onClick:month": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:month", $event)),
            "onClick:year": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:year", $event)),
            "onHover:day": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:day", $event)),
            "onHover:month": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:month", $event)),
            "onHover:year": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("hover:year", $event)),
            "onUpdate:view": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:view", $event))
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["modelValue"])
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style", "onOpen", "onClose"]);
}
var _VaDateInput = _export_sfc(_sfc_main55, [["render", _sfc_render53], ["styles", [...VaDropdown.styles || [], ...VaDropdownContent.styles || [], ..._VaDatePicker.styles || [], ...VaInputWrapper.styles || [], ...VaIcon2.styles || [], _style_050]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/index.js
var VaDateInput = withConfigTransport(_VaDateInput);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/index.js
var VaDatePicker = withConfigTransport(_VaDatePicker);

// node_modules/vuestic-ui/dist/web-components/src/components/va-divider/VaDivider.js
var _style_051 = ':root,\n:host {\n  --va-divider-display: flex;\n  --va-divider-color: var(--va-background-border);\n  /* Margin around divider, not the same as CSS margin. Should be one value. */\n  --va-divider-margin: 0.5rem;\n  --va-divider-line-width: 1px;\n  --va-divider-border-top-style: solid;\n  --va-divider-border-top-color: var(--va-divider-color);\n  --va-divider-text-font-size: 0.875rem;\n  --va-divider-text-line-height: 0;\n  --va-divider-text-height: 0;\n  --va-divider-text-vertical-align: middle;\n  --va-divider-text-transform: translateY(-50%);\n  /* This one adds offsets at the right and left for the given text orientation only for horizontal divider */\n  --va-divider-text-horizontal-offset: 1.25rem;\n  /* Vertical */\n  --va-divider-vertical-border-top: 0;\n  --va-divider-vertical-border-right-width: 1px;\n  --va-divider-vertical-border-right-style: solid;\n  --va-divider-vertical-border-right-color: var(--va-divider-color);\n  --va-divider-vertical-display: inline-flex;\n  /* Inset */\n  --va-divider-inset-horizontal-margin: 1rem;\n  --va-divider-inset-margin: 0.5rem var(--va-divider-inset-horizontal-margin);\n  /* Dashed */\n  --va-divider-dashed-border-top-style: dashed;\n}\n.va-divider {\n  display: var(--va-divider-display);\n  margin: var(--va-divider-margin) 0;\n  font-family: var(--va-font-family);\n}\n.va-divider--vertical {\n  margin: 0 var(--va-divider-margin);\n  border-top: var(--va-divider-vertical-border-top);\n  border-right-width: var(--va-divider-vertical-border-right-width);\n  border-right-style: var(--va-divider-vertical-border-right-style);\n  border-right-color: var(--va-divider-vertical-border-right-color);\n  display: var(--va-divider-vertical-display);\n  vertical-align: top;\n}\n.va-divider--vertical.va-divider--dashed {\n  border-right-style: dashed;\n}\n.va-divider--inset {\n  margin: var(--va-divider-inset-margin);\n}\n.va-divider--inset.va-divider--vertical {\n  margin: var(--va-divider-inset-horizontal-margin) var(--va-divider-margin);\n}\n.va-divider::before, .va-divider::after {\n  content: "";\n  flex: 1;\n  border-top-width: var(--va-divider-line-width);\n  border-top-style: var(--va-divider-border-top-style);\n  border-top-color: var(--va-divider-border-top-color);\n}\n.va-divider--dashed::before, .va-divider--dashed::after {\n  border-top-style: var(--va-divider-dashed-border-top-style);\n}\n.va-divider--left::before {\n  flex: 0 var(--va-divider-text-horizontal-offset);\n}\n.va-divider--right::after {\n  flex: 0 var(--va-divider-text-horizontal-offset);\n}\n.va-divider__text {\n  font-size: var(--va-divider-text-font-size);\n  line-height: var(--va-divider-text-line-height);\n  height: var(--va-divider-text-height);\n  vertical-align: var(--va-divider-text-vertical-align);\n  transform: var(--va-divider-text-transform);\n}';
var prefixClass = "va-divider";
var _sfc_main56 = defineComponent({
  name: "VaDivider",
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    }
  },
  setup: (props, { slots }) => ({
    hasSlot: computed(() => !!slots.default),
    classComputed: computed(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }))
  })
});
var _hoisted_134 = ["aria-orientation"];
var _hoisted_218 = {
  key: 0,
  class: "va-divider__text"
};
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "separator",
    class: normalizeClass(["va-divider", _ctx.classComputed]),
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal"
  }, [
    _ctx.hasSlot && !_ctx.vertical ? (openBlock(), createElementBlock("div", _hoisted_218, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true)
  ], 10, _hoisted_134);
}
var _VaDivider = _export_sfc(_sfc_main56, [["render", _sfc_render54], ["styles", [_style_051]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-divider/index.js
var VaDivider = withConfigTransport(_VaDivider);

// node_modules/vuestic-ui/dist/web-components/src/components/va-form/VaForm.js
var _style_052 = ".va-form {\n  font-family: var(--va-font-family);\n}";
var isVaForm = (value) => !!value.focusInvalid;
var _sfc_main57 = defineComponent({
  name: "VaForm",
  emits: ["validation"],
  props: {
    ...useComponentPresetProp,
    autofocus: { type: Boolean, default: false },
    tag: { type: String, default: "div" }
  },
  setup(props, { emit }) {
    const nestedFormElements = ref([]);
    const parentFormProvider = () => inject(FormServiceKey, void 0);
    provide(FormServiceKey, {
      onChildMounted: (child) => childMountedHandler(child),
      onChildUnmounted: (removableChild) => childUnmountedHandler(removableChild)
    });
    const childMountedHandler = (child) => {
      nestedFormElements.value.push(child);
    };
    const childUnmountedHandler = (removableChild) => {
      nestedFormElements.value = nestedFormElements.value.filter((child) => child !== removableChild);
    };
    const reset = () => {
      nestedFormElements.value.filter(({ reset: reset2 }) => reset2).forEach((item) => {
        item.reset();
      });
    };
    const resetValidation = () => {
      nestedFormElements.value.filter(({ resetValidation: resetValidation2 }) => resetValidation2).forEach((item) => {
        item.resetValidation();
      });
    };
    const focus = () => {
      var _a;
      (_a = nestedFormElements.value.find(({ focus: focus2 }) => focus2)) == null ? void 0 : _a.focus();
    };
    const focusInvalid = () => {
      const invalidComponent = nestedFormElements.value.find((item) => !isVaForm(item) && item.hasError());
      if (invalidComponent) {
        invalidComponent.focus();
      } else {
        nestedFormElements.value.forEach((item) => isVaForm(item) && item.focusInvalid());
      }
    };
    const validate = () => {
      const formValid = nestedFormElements.value.filter(({ validate: validate2 }) => validate2).map((child) => child.validate()).every((isValid) => isValid);
      emit("validation", formValid);
      return formValid;
    };
    const publicMethods = {
      reset,
      resetValidation,
      focus,
      focusInvalid,
      validate
    };
    onMounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildMounted) == null ? void 0 : _b.call(_a, publicMethods);
      if (props.autofocus) {
        nextTick(focus);
      }
    });
    onUnmounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildUnmounted) == null ? void 0 : _b.call(_a, publicMethods);
    });
    return publicMethods;
  }
});
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), { class: "va-form" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
var _VaForm = _export_sfc(_sfc_main57, [["render", _sfc_render55], ["styles", [_style_052]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-form/index.js
var VaForm = withConfigTransport(_VaForm);

// node_modules/vuestic-ui/dist/web-components/src/utils/sleep.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/hooks/useScroll.js
var useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a;
    (_a = element.value) == null ? void 0 : _a.addEventListener(
      "scroll",
      handler.value,
      { passive: true }
    );
  };
  const removeScrollListener = () => {
    var _a;
    (_a = element.value) == null ? void 0 : _a.removeEventListener(
      "scroll",
      handler.value
    );
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/VaInfiniteScroll.js
var _style_053 = ":root,\n:host {\n  --va-infinite-scroll-display: flex;\n  --va-infinite-scroll-flex-direction: column;\n  --va-infinite-scroll-spinner-default-width: 100%;\n  --va-infinite-scroll-spinner-default-min-height: 70px;\n  /* Reversed */\n  --va-infinite-scroll-reversed-flex-direction: column-reverse;\n}\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n}\n.va-infinite-scroll--reversed {\n  flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n}\n.va-infinite-scroll__spinner {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-infinite-scroll__spinner__default {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: var(--va-infinite-scroll-spinner-default-width);\n  min-height: var(--va-infinite-scroll-spinner-default-min-height);\n}\n.va-infinite-scroll__spinner--invisible {\n  visibility: hidden !important;\n}";
var _sfc_main58 = defineComponent({
  name: "VaInfiniteScroll",
  components: { VaProgressCircle },
  props: {
    ...useComponentPresetProp,
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: void 0 },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(props, { emit }) {
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a;
      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props.debounce, (value) => {
      debouncedLoad.value = debounce_1(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return {
      element,
      spinnerSlotContainer,
      spinnerColor,
      fetching
    };
  }
});
var _hoisted_135 = { class: "va-infinite-scroll__spinner__default" };
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !_ctx.fetching }])
      }, [
        !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
          createBaseVNode("div", _hoisted_135, [
            createVNode(_component_va_progress_circle, {
              size: "small",
              thickness: 0.15,
              color: _ctx.spinnerColor,
              indeterminate: ""
            }, null, 8, ["thickness", "color"])
          ])
        ]) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["class", "aria-busy"]);
}
var _VaInfiniteScroll = _export_sfc(_sfc_main58, [["render", _sfc_render56], ["styles", [...VaProgressCircle.styles || [], _style_053]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/index.js
var VaInfiniteScroll = withConfigTransport(_VaInfiniteScroll);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaList.js
var _style_054 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list {\n  width: var(--va-list-width);\n  font-family: var(--va-font-family);\n}\n.va-list--fit {\n  width: -moz-fit-content;\n  width: fit-content;\n}";
var _sfc_main59 = defineComponent({
  name: "VaList",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list--fit": props.fit }))
  })
});
function _sfc_render57(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list", _ctx.computedClass]),
    role: "list"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaList = _export_sfc(_sfc_main59, [["render", _sfc_render57], ["styles", [_style_054]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItem.js
var _style_055 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-item {\n  display: block;\n  font-family: var(--va-font-family);\n}\n.va-list-item--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-list-item:not(.va-list-item--disabled):focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n  outline-offset: -2px;\n}\n.va-list-item__inner {\n  display: var(--va-list-item-display);\n  align-items: var(--va-list-item-align-items);\n  width: var(--va-list-item-width);\n  height: var(--va-list-item-height);\n}";
var _sfc_main60 = defineComponent({
  name: "VaListItem",
  emits: ["focus", "click"],
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  },
  setup(props) {
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-list-item", () => ({
      ...pick_1(props, ["disabled"])
    }));
    return {
      ...useRouterLink(props),
      tabIndexComputed,
      computedClass
    };
  }
});
function _sfc_render58(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-list-item", _ctx.computedClass]),
    role: "listitem",
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    tabindex: _ctx.tabIndexComputed
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-list-item__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 32)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
}
var _VaListItem = _export_sfc(_sfc_main60, [["render", _sfc_render58], ["styles", [_style_055]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListLabel.js
var _style_056 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-label {\n  font-family: var(--va-font-family);\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n  text-align: var(--va-list-label-text-align);\n  padding: var(--va-list-label-padding);\n}";
var _sfc_main61 = defineComponent({
  name: "VaListLabel",
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" }
  },
  setup: (props) => {
    const { getColor } = useColors();
    return {
      computedStyle: computed(() => ({
        color: getColor(props.color)
      }))
    };
  }
});
function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-list-label",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaListLabel = _export_sfc(_sfc_main61, [["render", _sfc_render59], ["styles", [_style_056]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItemLabel.js
var _style_057 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-item-label {\n  font-family: var(--va-font-family);\n  color: var(--va-list-item-label-color);\n  display: var(--va-list-item-label-display);\n  -webkit-box-orient: var(--va-list-item-label-box-orient);\n  overflow: var(--va-list-item-label-overflow);\n  line-height: var(--va-list-item-label-line-height);\n}\n.va-list-item-label--caption {\n  font-size: var(--va-list-item-label-caption-font-size);\n  color: var(--va-list-item-label-caption-color);\n}";
var _sfc_main62 = defineComponent({
  name: "VaListItemLabel",
  props: {
    ...useComponentPresetProp,
    caption: { type: Boolean, default: false },
    lines: { type: Number, default: 1 }
  },
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list-item-label--caption": props.caption })),
    computedStyle: computed(() => ({ "-webkit-line-clamp": props.lines }))
  })
});
function _sfc_render60(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-label", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _VaListItemLabel = _export_sfc(_sfc_main62, [["render", _sfc_render60], ["styles", [_style_057]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItemSection.js
var _style_058 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-item-section {\n  display: flex;\n  font-family: var(--va-font-family);\n}\n.va-list-item-section--main {\n  min-width: 0;\n  flex-direction: column;\n  flex: 1 0;\n}\n.va-list-item-section--icon {\n  min-width: var(--va-list-item-section-icon-min-width);\n  align-items: var(--va-list-item-section-icon-align-items);\n  justify-content: var(--va-list-item-section-icon-justify-content);\n  margin: var(--va-list-item-section-icon-margin);\n}\n.va-list-item-section--icon .va-icon {\n  font-size: var(--va-list-item-section-icon-font-size);\n}\n.va-list-item-section--avatar {\n  min-width: var(--va-list-item-section-avatar-min-width);\n}\n.va-list-item-section + .va-list-item-section {\n  margin-left: 0.5rem;\n}\n.va-list-item-section + .va-list-item-section--icon:last-child {\n  margin-left: 1rem;\n}";
var _sfc_main63 = defineComponent({
  name: "VaListItemSection",
  props: {
    ...useComponentPresetProp,
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }))
  })
});
function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-section", _ctx.computedClass])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaListItemSection = _export_sfc(_sfc_main63, [["render", _sfc_render61], ["styles", [_style_058]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListSeparator.js
var _style_059 = ".va-list-separator {\n  height: 1px;\n  background-color: #e6e9ec;\n}\n.va-list-separator--offset {\n  margin-left: 1.5rem;\n}\n.va-list-separator--spaced {\n  margin: 1.5rem 0;\n}";
var _sfc_main64 = defineComponent({
  name: "VaListSeparator",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }))
  })
});
function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    "aria-hidden": "true",
    class: normalizeClass(["va-list-separator", _ctx.computedClass])
  }, null, 2);
}
var _VaListSeparator = _export_sfc(_sfc_main64, [["render", _sfc_render62], ["styles", [_style_059]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/index.js
var VaListItem = withConfigTransport(_VaListItem);
var VaListLabel = withConfigTransport(_VaListLabel);
var VaListItemLabel = withConfigTransport(_VaListItemLabel);
var VaListItemSection = withConfigTransport(_VaListItemSection);
var VaListSeparator = withConfigTransport(_VaListSeparator);
var VaList = withConfigTransport(_VaList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/VaNavbar.js
var _style_060 = '.va-navbar {\n  --va-navbar-mobile-height: 6.5rem;\n  --va-navbar-height: 4.0625rem;\n  --va-navbar-padding-x: 1rem;\n  --va-navbar-padding-y: 1.2rem;\n  --va-navbar-transition: transform 0.5s ease;\n  --va-navbar-position: relative;\n  --va-nav-z-index: calc(var(--va-z-index-teleport-overlay) - 100);\n  --va-navbar-sm-padding: 1.1875rem 1rem 1rem;\n  --va-navbar-shape-width: 33%;\n  --va-navbar-shape-max-width: 467px;\n  --va-navbar-shape-bg: rgba(0, 0, 0, 0.5);\n  --va-navbar-shape-border-left: 3.1875rem solid transparent;\n  --va-navbar-shape-border-right: 3.1875rem solid transparent;\n  --va-navbar-shape-transition: border-top-color 0.3s ease;\n  --va-navbar-item-margin: 0.75rem;\n  --va-navbar-item-margin-side: calc(2 * var(--va-navbar-item-margin));\n}\n.va-navbar {\n  display: grid;\n  grid-template: "left center right"/1fr auto 1fr;\n  align-items: center;\n  transition: var(--va-navbar-transition);\n  position: var(--va-navbar-position);\n  padding: var(--va-navbar-padding-y) var(--va-navbar-padding-x);\n  background-color: var(--va-primary);\n  font-family: var(--va-font-family);\n  top: 0;\n  left: 0;\n  width: 100%;\n  min-width: 100%;\n  z-index: var(--va-navbar-z-index);\n}\n.va-navbar__left {\n  display: flex;\n  grid-area: left;\n}\n.va-navbar__left > .va-navbar__item {\n  margin-right: var(--va-navbar-item-margin-side);\n}\n.va-navbar__left > .va-navbar__item:last-child {\n  margin-right: 0;\n}\n@media (max-width: 767.98px) {\n.va-navbar__left {\n    justify-content: center;\n    align-items: center;\n}\n}\n.va-navbar__center {\n  display: flex;\n  justify-content: center;\n  grid-area: center;\n}\n.va-navbar__center > .va-navbar__item {\n  margin: 0 var(--va-navbar-item-margin);\n}\n.va-navbar__center > .va-navbar__item:last-child {\n  margin-right: 0;\n}\n.va-navbar__center > .va-navbar__item:first-child {\n  margin-left: 0;\n}\n.va-navbar__right {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  grid-area: right;\n}\n.va-navbar__right > .va-navbar__item {\n  margin-right: var(--va-navbar-item-margin-side);\n}\n.va-navbar__right > .va-navbar__item:last-child {\n  margin-right: 0;\n}\n@media (max-width: 767.98px) {\n.va-navbar__right {\n    justify-content: center;\n    align-items: center;\n}\n}\n.va-navbar__background-shape {\n  transition: var(--va-navbar-shape-transition);\n  width: var(--va-navbar-shape-width);\n  max-width: var(--va-navbar-shape-max-width);\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  margin: auto;\n  border-top: var(--va-navbar-height) solid var(--va-navbar-shape-bg);\n  border-left: var(--va-navbar-shape-border-left);\n  border-right: var(--va-navbar-shape-border-right);\n  height: 0;\n}\n@media (max-width: 767.98px) {\n.va-navbar {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    height: var(--va-navbar-mobile-height);\n    padding: var(--va-navbar-sm-padding);\n}\n.va-navbar > * {\n    width: 100%;\n}\n.va-navbar__background-shape {\n    display: none;\n}\n}';
var _sfc_main65 = defineComponent({
  name: "VaNavbar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    color: { type: String, default: "background-secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false }
  },
  setup(props) {
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const color = computed(() => getColor(props.color));
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    return {
      scrollRoot,
      computedStyle,
      shapeStyleComputed
    };
  }
});
var _hoisted_136 = { class: "va-navbar__left" };
var _hoisted_219 = { class: "va-navbar__center" };
var _hoisted_39 = { class: "va-navbar__right" };
function _sfc_render63(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    class: "va-navbar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    createBaseVNode("div", _hoisted_136, [
      renderSlot(_ctx.$slots, "left")
    ]),
    createBaseVNode("div", _hoisted_219, [
      renderSlot(_ctx.$slots, "default")
    ]),
    createBaseVNode("div", _hoisted_39, [
      renderSlot(_ctx.$slots, "right")
    ]),
    _ctx.shape ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "va-navbar__background-shape",
      style: normalizeStyle(_ctx.shapeStyleComputed)
    }, null, 4)) : createCommentVNode("", true)
  ], 4);
}
var _VaNavbar = _export_sfc(_sfc_main65, [["render", _sfc_render63], ["styles", [_style_060]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/VaNavbarItem/VaNavbarItem.js
var _style_061 = ".va-navbar__item {\n  display: flex;\n  align-items: center;\n  font-family: var(--va-font-family);\n}";
var _sfc_main66 = defineComponent({
  name: "VaNavbarItem",
  props: {}
});
var _hoisted_137 = { class: "va-navbar__item" };
function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_137, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaNavbarItem = _export_sfc(_sfc_main66, [["render", _sfc_render64], ["styles", [_style_061]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/index.js
var VaNavbar = withConfigTransport(_VaNavbar);
var VaNavbarItem = withConfigTransport(_VaNavbarItem);

// node_modules/vuestic-ui/dist/web-components/src/composables/useArrayRefs.js
var useArrayRefs = () => {
  const itemRefs = shallowRef([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const isStringOrNumber = (option) => {
    const typeOfOption = typeof option;
    return typeOfOption === "string" || typeOfOption === "number";
  };
  const getOptionProperty = (option, selector) => {
    return !selector || isStringOrNumber(option) ? option : getValueByKey(option, selector);
  };
  const getValue2 = (option) => getOptionProperty(option, props.valueBy);
  const getOptionByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.options.find((option) => value === getValue2(option)) || value;
  };
  const getText = (option) => String(getOptionProperty(option, props.textBy));
  const getDisabled = (option) => isStringOrNumber(option) ? false : getOptionProperty(option, props.disabledBy);
  const getTrackBy = (option) => {
    if (props.trackBy) {
      return getOptionProperty(option, props.trackBy);
    }
    return getValue2(option);
  };
  const getGroupBy = (option) => getOptionProperty(option, props.groupBy);
  return {
    getValue: getValue2,
    getOptionByValue,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-radio/VaRadio.js
var _style_062 = ':root,\n:host {\n  --va-radio-display: inline-flex;\n  --va-radio-cursor: pointer;\n  --va-radio-position: relative;\n  --va-radio-margin-top: 0;\n  --va-radio-margin-right: 0.5rem;\n  --va-radio-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-disabled-cursor: default;\n  --va-radio-border-color: var(--va-background-border);\n  /* Icon */\n  --va-radio-icon-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-icon-width: 1.4rem;\n  --va-radio-icon-height: 1.4rem;\n  --va-radio-icon-border-radius: 100%;\n  --va-radio-icon-border: var(--va-background-border) solid 0.125rem;\n  /* Dot */\n  --va-radio-dot-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-dot-top: 50%;\n  --va-radio-dot-left: 50%;\n  --va-radio-dot-right: 50%;\n  --va-radio-dot-bottom: 50%;\n  --va-radio-dot-border-radius: 100%;\n  --va-radio-dot-background-color: inherit;\n  --va-radio-dot-opacity: 0;\n  /* Background */\n  --va-radio-background-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-background-top: -0.35rem;\n  --va-radio-background-left: -0.35rem;\n  --va-radio-background-right: -0.35rem;\n  --va-radio-background-bottom: -0.35rem;\n  --va-radio-background-background-color: var(--va-background-element);\n  --va-radio-background-border-radius: 100%;\n  --va-radio-background-z-index: 0;\n  --va-radio-background-opacity: 0;\n  /* Text */\n  --va-radio-text-display: inline-flex;\n  --va-radio-text-margin-left: 0.5rem;\n  --va-radio-text-margin-right: 0;\n}\n.va-radio {\n  display: var(--va-radio-display);\n  align-items: center;\n  cursor: var(--va-radio-cursor);\n  position: var(--va-radio-position);\n  margin-top: var(--va-radio-margin-top);\n  margin-right: var(--va-radio-margin-right);\n  transition: var(--va-radio-transition, var(--va-swing-transition));\n  font-family: var(--va-font-family);\n}\n.va-radio + .va-radio {\n  margin-top: 0.5rem;\n}\n.va-radio--disabled {\n  cursor: var(--va-radio-disabled-cursor);\n}\n.va-radio--readonly {\n  cursor: default;\n  pointer-events: none;\n}\n.va-radio--readonly .va-radio--left-label,\n.va-radio--readonly .va-radio__text {\n  cursor: initial;\n  pointer-events: auto;\n}\n.va-radio--left-label {\n  flex-direction: row-reverse;\n  display: inline-flex;\n}\n.va-radio__input {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n  white-space: nowrap;\n  -webkit-clip-path: inset(100%);\n          clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}\n.va-radio__icon {\n  transition: var(--va-radio-icon-transition);\n  display: flex;\n  align-items: center;\n  width: var(--va-radio-icon-width);\n  height: var(--va-radio-icon-height);\n  border-radius: var(--va-radio-icon-border-radius);\n  position: relative;\n  border: var(--va-radio-icon-border);\n  box-sizing: border-box;\n}\n.va-radio__input:disabled + .va-radio__icon {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-radio__input:focus-visible + .va-radio__icon {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-radio__icon__dot {\n  transition: var(--va-radio-dot-transition, var(--va-swing-transition));\n  position: absolute;\n  top: var(--va-radio-dot-top);\n  left: var(--va-radio-dot-left);\n  right: var(--va-radio-dot-right);\n  bottom: var(--va-radio-dot-bottom);\n  border-radius: var(--va-radio-dot-border-radius);\n  background-color: var(--va-radio-dot-background-color);\n  opacity: var(--va-radio-dot-opacity);\n}\n.va-radio__input:checked + .va-radio__icon .va-radio__icon__dot {\n  opacity: 1;\n  top: 0.25rem;\n  left: 0.25rem;\n  right: 0.25rem;\n  bottom: 0.25rem;\n}\n.va-radio__icon__background {\n  transition: var(--va-radio-background-transition, var(--va-swing-transition));\n  position: absolute;\n  top: var(--va-radio-background-top);\n  left: var(--va-radio-background-left);\n  right: var(--va-radio-background-right);\n  bottom: var(--va-radio-background-bottom);\n  background-color: var(--va-radio-background-background-color);\n  border-radius: var(--va-radio-background-border-radius);\n  z-index: var(--va-radio-background-z-index);\n  opacity: var(--va-radio-background-opacity);\n}\n.va-radio:hover .va-radio__icon__background {\n  opacity: 0.2;\n}\n.va-radio--disabled:hover .va-radio__icon__background {\n  opacity: 0;\n}\n.va-radio__text {\n  display: var(--va-radio-text-display);\n  margin-left: var(--va-radio-text-margin-left);\n  margin-right: var(--va-radio-text-margin-right);\n}\n.va-radio--disabled .va-radio__text {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-radio--left-label .va-radio__text {\n  margin-left: 0;\n  margin-right: 0.5rem;\n}';
var _sfc_main67 = defineComponent({
  name: "VaRadio",
  emits: ["update:modelValue", "focus"],
  props: {
    ...useFormProps,
    ...useComponentPresetProp,
    modelValue: { type: [Boolean, Array, String, Object, Number], default: null },
    option: { type: [String, Boolean, Object, Number], default: null },
    name: { type: String, default: "" },
    label: { type: String, default: "" },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    tabindex: { type: Number, default: 0 }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const isActive = computed(() => props.modelValue === props.option);
    const { computedClasses } = useForm("va-radio", props);
    const computedClass = computed(() => ({
      "va-radio--left-label": props.leftLabel,
      ...computedClasses
    }));
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return {
        borderColor: getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return { borderColor: getColor(props.color) };
    });
    const computedLabel = computed(() => props.label || props.option);
    const onClick = (e) => {
      if (props.readonly || props.disabled) {
        return;
      }
      emit("update:modelValue", props.option, e);
    };
    const onFocus = (e) => emit("focus", e);
    return {
      computedClass,
      isActive,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      computedLabel,
      onClick,
      onFocus,
      computedName: computed(() => props.name || generateUniqueId()),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_138 = ["checked", "disabled", "readonly", "name", "value", "aria-checked", "tabindex"];
var _hoisted_220 = { class: "va-radio__text" };
function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["va-radio", _ctx.computedClass])
  }, [
    createBaseVNode("input", {
      class: "va-radio__input",
      type: "radio",
      checked: _ctx.isActive,
      disabled: _ctx.$props.disabled,
      readonly: _ctx.$props.readonly,
      name: _ctx.computedName,
      value: _ctx.computedLabel,
      "aria-checked": _ctx.isActive,
      tabindex: _ctx.tabIndexComputed,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args))
    }, null, 40, _hoisted_138),
    createBaseVNode("span", {
      "aria-hidden": "true",
      class: "va-radio__icon",
      style: normalizeStyle(_ctx.iconComputedStyles)
    }, [
      createBaseVNode("span", {
        class: "va-radio__icon__background",
        style: normalizeStyle(_ctx.iconBackgroundComputedStyles)
      }, null, 4),
      createBaseVNode("span", {
        class: "va-radio__icon__dot",
        style: normalizeStyle(_ctx.iconDotComputedStyles)
      }, null, 4)
    ], 4),
    createBaseVNode("span", _hoisted_220, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.computedLabel), 1)
      ])
    ])
  ], 2);
}
var _VaRadio = _export_sfc(_sfc_main67, [["render", _sfc_render65], ["styles", [_style_062]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-radio/index.js
var VaRadio = withConfigTransport(_VaRadio);

// node_modules/vuestic-ui/dist/web-components/src/components/va-switch/VaSwitch.js
var _style_063 = ':root,\n:host {\n  --va-switch-display: inline-block;\n  /* Checker */\n  --va-switch-checker-margin: auto 0.3rem;\n  --va-switch-checker-transform: translateX(0);\n  --va-switch-checker-height: 1.5rem;\n  --va-switch-checker-width: 1.5rem;\n  --va-switch-checker-active-background-color: #ffffff;\n  --va-switch-checker-background-color: var(--va-secondary);\n  --va-switch-checker-border-radius: 50%;\n  --va-switch-checker-box-shadow: 0 0 0 var(--va-background-border);\n  --va-switch-checker-transition: all 0.2s ease;\n  /* Checker Wrapper */\n  --va-switch-checker-wrapper-transform: translateX(0);\n  --va-switch-checker-wrapper-top: 0;\n  --va-switch-checker-wrapper-left: 0;\n  --va-switch-checker-wrapper-bottom: 0;\n  --va-switch-checker-wrapper-right: 0;\n  --va-switch-checker-wrapper-width: 100%;\n  --va-switch-checker-wrapper-height: 100%;\n  --va-switch-checker-wrapper-transition: all 0.2s ease;\n  --va-switch-checker-wrapper-pointer-events: none;\n  /* Label */\n  --va-switch-label-left-padding: 0.3rem;\n  --va-switch-label-right-padding: 0.3rem;\n  /* Track */\n  --va-switch-track-border-radius: 1rem;\n  --va-switch-track-height: 100%;\n  --va-switch-track-width: 100%;\n  --va-switch-track-background: var(--va-background-element);\n  --va-switch-track-box-shadow: inset 0 0 0 var(--va-shadow);\n  --va-switch-track-transition: background-color 0.2s ease;\n  /* Inner */\n  --va-switch-inner-cursor: pointer;\n  --va-switch-inner-height: 2rem;\n  --va-switch-inner-width: auto;\n  --va-switch-inner-min-width: 4rem;\n  --va-switch-inner-border-radius: 1rem;\n  /* Small */\n  --va-switch-sm-inner-height: 1.5rem;\n  --va-switch-sm-inner-width: auto;\n  --va-switch-sm-inner-min-width: 3rem;\n  /* Large */\n  --va-switch-lg-inner-height: 2.5rem;\n  --va-switch-lg-inner-width: auto;\n  --va-switch-lg-inner-min-width: 5rem;\n}\n.va-switch {\n  line-height: 0;\n  display: var(--va-switch-display);\n}\n.va-switch__container {\n  display: inline-flex;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n.va-switch:focus {\n  outline: none;\n}\n.va-switch__inner {\n  cursor: var(--va-switch-inner-cursor);\n  display: inline-block;\n  position: relative;\n  height: var(--va-switch-inner-height);\n  width: var(--va-switch-inner-width);\n  min-width: var(--va-switch-inner-min-width);\n  border-radius: var(--va-switch-inner-border-radius);\n  overflow: hidden;\n}\n.va-switch__inner:focus {\n  outline: 0;\n  box-shadow: 0 0 0 0.3rem rgba(52, 144, 220, 0.5);\n}\n.va-switch--small .va-switch__inner {\n  height: var(--va-switch-sm-inner-height);\n  width: var(--va-switch-sm-inner-width);\n  min-width: var(--va-switch-sm-inner-min-width);\n}\n.va-switch--small .va-switch__checker-circle {\n  height: 1.1rem;\n  width: 1.1rem;\n}\n.va-switch--large .va-switch__inner {\n  height: var(--va-switch-lg-inner-height);\n  width: var(--va-switch-lg-inner-width);\n  min-width: var(--va-switch-lg-inner-min-width);\n}\n.va-switch--large .va-switch__checker-circle {\n  height: 1.8rem;\n  width: 1.8rem;\n}\n.va-switch--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-switch--readonly {\n  cursor: default;\n  pointer-events: none;\n}\n.va-switch--readonly .va-switch__label {\n  cursor: initial;\n  pointer-events: auto;\n}\n.va-switch--left-label .va-switch__container {\n  flex-direction: row-reverse;\n}\n.va-switch--left-label .va-switch__label {\n  padding: 0 var(--va-switch-label-left-padding) 0 0;\n}\n.va-switch--indeterminate .va-switch__checker {\n  margin: auto 0;\n  transform: translateX(-50%);\n}\n.va-switch--indeterminate .va-switch__checker-wrapper {\n  transform: translateX(50%);\n}\n.va-switch--checked .va-switch__checker {\n  margin: auto -0.3rem;\n  transform: translateX(-100%);\n}\n.va-switch--checked .va-switch__checker-circle {\n  background-color: var(--va-switch-checker-active-background-color);\n}\n.va-switch--checked .va-switch__checker-wrapper {\n  transform: translateX(100%);\n}\n.va-switch--error .va-switch__track {\n  border: 0.1rem solid;\n}\n.va-switch__label {\n  cursor: pointer;\n  text-align: left;\n  padding: 0 0 0 var(--va-switch-label-right-padding);\n}\n.va-switch .va-switch__track {\n  display: flex;\n  overflow: hidden;\n  border-radius: var(--va-switch-track-border-radius);\n  height: var(--va-switch-track-height);\n  width: var(--va-switch-track-width);\n  background: var(--va-switch-track-background);\n  box-shadow: var(--va-switch-track-box-shadow);\n  transition: var(--va-switch-track-transition);\n}\n.va-switch--keyboard-focus.va-switch .va-switch__track {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-switch--small.va-switch .va-switch__track {\n  border-radius: 0.75rem;\n}\n.va-switch--large.va-switch .va-switch__track {\n  border-radius: 1.25rem;\n}\n.va-switch .va-switch__track-label {\n  color: #ffffff;\n  margin: auto 0.5rem auto 2rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  width: 100%;\n}\n.va-switch--checked.va-switch .va-switch__track-label {\n  margin: auto 2rem auto 0.5rem;\n}\n.va-switch--small.va-switch .va-switch__track-label {\n  margin: auto 0.5rem auto 1.55rem;\n}\n.va-switch--checked.va-switch--small.va-switch .va-switch__track-label {\n  margin: auto 1.55rem auto 0.5rem;\n}\n.va-switch--large.va-switch .va-switch__track-label {\n  margin: auto 0.5rem auto 2.3rem;\n}\n.va-switch--checked.va-switch--large.va-switch .va-switch__track-label {\n  margin: auto 2.3rem auto 0.5rem;\n}\n.va-switch__checker {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  margin: var(--va-switch-checker-margin);\n  transform: var(--va-switch-checker-transform);\n  box-shadow: var(--va-switch-checker-box-shadow);\n  transition: var(--va-switch-checker-transition);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-switch__checker-circle {\n  height: var(--va-switch-checker-height);\n  width: var(--va-switch-checker-width);\n  background-color: var(--va-switch-checker-background-color);\n  border-radius: var(--va-switch-checker-border-radius);\n}\n.va-switch__checker-wrapper {\n  position: absolute;\n  margin: auto;\n  transform: var(--va-switch-checker-wrapper-transform);\n  top: var(--va-switch-checker-wrapper-top);\n  left: var(--va-switch-checker-wrapper-left);\n  bottom: var(--va-switch-checker-wrapper-bottom);\n  right: var(--va-switch-checker-wrapper-right);\n  width: var(--va-switch-checker-wrapper-width);\n  height: var(--va-switch-checker-wrapper-height);\n  transition: var(--va-switch-checker-wrapper-transition);\n  pointer-events: var(--va-switch-checker-wrapper-pointer-events);\n}\n.va-switch__input {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n  white-space: nowrap;\n  -webkit-clip-path: inset(100%);\n          clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}';
var _sfc_main68 = defineComponent({
  name: "VaSwitch",
  components: { VaProgressCircle, VaMessageListWrapper },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    ariaLabel: { type: String, default: "Switch" },
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "background-element" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  setup(props, { emit, slots }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      ...selectable
    } = useSelectable(props, emit, elements);
    const computedBackground = computed(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => ({
      ...pick_1(props, ["readonly", "disabled", "leftLabel"]),
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      keyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size = { small: "15px", medium: "20px", large: "25px" };
      return size[props.size];
    });
    const trackStyle = computed(() => ({
      borderColor: props.error ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: props.error ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value,
      "text-align": isChecked.value ? "left" : "right"
    }));
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const inputAttributesComputed = computed(() => ({
      id: props.id || void 0,
      name: props.name || void 0,
      disabled: props.disabled,
      readonly: props.readonly,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-checked": !!props.modelValue,
      "aria-label": !slots.default ? props.ariaLabel : void 0,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0,
      ...validationAriaAttributes.value
    }));
    return {
      ...selectable,
      computedErrorMessages,
      isChecked,
      computedError,
      isIndeterminate,
      keyboardFocusListeners,
      computedInnerLabel,
      computedLabel,
      computedClass,
      styleComputed,
      progressCircleSize,
      trackStyle,
      labelStyle,
      trackLabelStyle,
      ariaLabelIdComputed,
      inputAttributesComputed
    };
  }
});
var _hoisted_139 = { class: "va-switch__checker-wrapper" };
var _hoisted_221 = { class: "va-switch__checker" };
var _hoisted_310 = { class: "va-switch__checker-circle" };
var _hoisted_49 = ["id"];
function _sfc_render66(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-switch", _ctx.computedClass]),
    style: normalizeStyle(_ctx.styleComputed),
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-switch__container",
        tabindex: "-1",
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-switch__inner",
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-switch__input",
            role: "switch"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]), ["enter"]))
          }), null, 16),
          createBaseVNode("div", {
            class: "va-switch__track",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.trackStyle)
          }, [
            _ctx.computedInnerLabel || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-switch__track-label",
              style: normalizeStyle(_ctx.trackLabelStyle)
            }, [
              renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                createTextVNode(toDisplayString(_ctx.computedInnerLabel), 1)
              ])
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_139, [
              createBaseVNode("span", _hoisted_221, [
                renderSlot(_ctx.$slots, "checker", normalizeProps(guardReactiveProps({ value: _ctx.isChecked })), () => [
                  createBaseVNode("div", _hoisted_310, [
                    _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
                      key: 0,
                      indeterminate: "",
                      size: _ctx.progressCircleSize,
                      color: _ctx.trackStyle.backgroundColor
                    }, null, 8, ["size", "color"])) : createCommentVNode("", true)
                  ])
                ])
              ])
            ])
          ], 4)
        ]),
        _ctx.computedLabel || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "label",
          class: "va-switch__label",
          style: normalizeStyle(_ctx.labelStyle),
          id: _ctx.ariaLabelIdComputed,
          onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["stop"]), ["enter"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.computedLabel), 1)
          ])
        ], 44, _hoisted_49)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaSwitch = _export_sfc(_sfc_main68, [["render", _sfc_render66], ["styles", [...VaProgressCircle.styles || [], ...VaMessageListWrapper.styles || [], _style_063]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-switch/index.js
var VaSwitch = withConfigTransport(_VaSwitch);

// node_modules/vuestic-ui/dist/web-components/src/components/va-option-list/VaOptionList.js
var _style_064 = ":root,\n:host {\n  --va-option-list-line-height: 1.5;\n}\n.va-option-list__list {\n  line-height: var(--va-option-list-line-height);\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  vertical-align: baseline;\n}";
var _sfc_main69 = defineComponent({
  name: "VaOptionList",
  components: {
    VaRadio,
    VaCheckbox,
    VaSwitch,
    VaMessageListWrapper
  },
  emits: [...useStatefulEmits],
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Object, Array] }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: props.defaultValue });
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const getKey = (option) => getTrackBy(option);
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const computedProps = computed(() => pick_1(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (__DEV__ && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    return {
      selectedValue,
      computedError,
      computedErrorMessages,
      getValue: getValue2,
      getText,
      getKey,
      isDisabled,
      reset,
      focus,
      setItemRef,
      computedProps
    };
  }
});
var _hoisted_140 = { class: "va-option-list__list" };
function _sfc_render67(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_radio = resolveComponent("va-radio");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_switch = resolveComponent("va-switch");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("ul", _hoisted_140, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
          return openBlock(), createElementBlock("li", {
            key: _ctx.getKey(option)
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: _ctx.selectedValue, isDisabled: _ctx.isDisabled, getText: _ctx.getText, getValue: _ctx.getValue })), () => [
              _ctx.$props.type === "radio" ? (openBlock(), createBlock(_component_va_radio, mergeProps({
                key: 0,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                option: _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(_component_va_checkbox, mergeProps({
                key: 1,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(_component_va_switch, mergeProps({
                key: 2,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"]))
            ])
          ]);
        }), 128))
      ])
    ]),
    _: 3
  }, 8, ["error", "error-messages", "error-count"]);
}
var _VaOptionList = _export_sfc(_sfc_main69, [["render", _sfc_render67], ["styles", [...VaRadio.styles || [], ...VaCheckbox.styles || [], ...VaSwitch.styles || [], ...VaMessageListWrapper.styles || [], _style_064]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-option-list/index.js
var VaOptionList = withConfigTransport(_VaOptionList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/setPaginationRange.js
var setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages > 10 ? 10 : pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) {
      start = 1;
    } else {
      start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i = 0; i < visiblePages; i++) {
    range.push(start + i);
  }
  if (includeBoundary && visiblePages < 7) {
    pages >= 7 && warn(
      "[va-pagination] To work in a proper way, the `boundaryNumbers` prop needs at least 7 visible pages to be set via the `visiblePages` prop (first, last, 2 boundaries, current, previous, next)."
    );
  } else if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/VaPagination.js
var _style_065 = ':root,\n:host {\n  --va-pagination-gap: 0.5rem;\n  --va-pagination-input-background: var(--va-background-primary);\n  --va-pagination-input-border-style: solid;\n  --va-pagination-input-border-width: 1px 0;\n  --va-pagination-input-text-align: center;\n  --va-pagination-input-font-size: 1rem;\n  --va-pagination-button-content-width: 0.5rem;\n  --va-pagination-button-sm-size: var(--va-button-sm-size);\n  --va-pagination-button-size: var(--va-button-size);\n  --va-pagination-button-lg-size: var(--va-button-lg-ze);\n}\n.va-pagination {\n  display: flex;\n  font-family: var(--va-font-family);\n}\n.va-pagination__input {\n  background: var(--va-pagination-input-background);\n  border-style: var(--va-pagination-input-border-style);\n  border-width: var(--va-pagination-input-border-width);\n  text-align: var(--va-pagination-input-text-align);\n  font-size: var(--va-pagination-input-font-size);\n  font-weight: normal;\n}\n.va-pagination__input--sm {\n  height: var(--va-pagination-button-sm-size);\n}\n.va-pagination__input--md {\n  height: var(--va-pagination-button-size);\n}\n.va-pagination__input--lg {\n  height: var(--va-pagination-button-lg-size);\n}\n.va-pagination__input--auto {\n  height: auto;\n}\n.va-pagination .va-button.va-input {\n  cursor: default;\n}\n.va-pagination .va-button--small {\n  height: var(--va-pagination-button-sm-size);\n  min-width: var(--va-pagination-button-sm-size);\n}\n.va-pagination .va-button--normal {\n  height: var(--va-pagination-button-size);\n  min-width: var(--va-pagination-button-size);\n}\n.va-pagination .va-button--large {\n  height: var(--va-pagination-button-lg-size);\n  min-width: var(--va-pagination-button-lg-size);\n}\n.va-pagination .va-button--ellipsis {\n  cursor: default;\n  opacity: 1;\n}\n.va-pagination .va-button--ellipsis > .va-button__content {\n  opacity: 0.4;\n}\n.va-pagination .va-button:focus-visible {\n  outline-offset: -2px;\n}\n.va-pagination .va-button:focus-visible:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-pagination > :not(:first-child):not(:last-child) {\n  border-radius: 0;\n}\n.va-pagination > :first-child {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.va-pagination > :last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.va-pagination--gapped.va-pagination > .va-button {\n  border-radius: var(--va-button-border-radius);\n  margin-right: var(--va-pagination-gap);\n  border-style: solid;\n}\n.va-pagination--gapped.va-pagination > .va-button:last-child {\n  margin-right: 0;\n}\n.va-pagination--bordered.va-pagination > .va-button {\n  border-style: solid;\n}\n.va-pagination--bordered.va-pagination > .va-button::before {\n  border-radius: unset;\n}\n.va-pagination--rounded.va-pagination > .va-button {\n  border-radius: 50%;\n}\n.va-pagination--rounded.va-pagination > .va-button::before {\n  border-radius: inherit;\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--small.va-button--icon-only {\n  height: var(--va-pagination-button-sm-size);\n  width: var(--va-pagination-button-sm-size);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--small .va-button__content {\n  padding-right: var(--va-button-sm-content-px);\n  padding-left: var(--va-button-sm-content-px);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--normal.va-button--icon-only {\n  height: var(--va-pagination-button-size);\n  width: var(--va-pagination-button-size);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--normal .va-button__content {\n  padding-right: var(--va-button-content-px);\n  padding-left: var(--va-button-content-px);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--large.va-button--icon-only {\n  height: var(--va-pagination-button-lg-size);\n  width: var(--va-pagination-button-lg-size);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--large .va-button__content {\n  padding-right: var(--va-button-lg-content-px);\n  padding-left: var(--va-button-lg-content-px);\n}';
var _sfc_main70 = defineComponent({
  name: "VaPagination",
  components: { VaButton: VaButton2 },
  emits: useStatefulEmits,
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: Number, default: 0 },
    pages: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: Number, default: null },
    pageSize: { type: Number, default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    activePageColor: { type: String, default: "" },
    buttonsPreset: { type: String, default: "primary" }
  },
  setup(props, { emit }) {
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usesTotal = computed(() => !!((props.total || props.total === 0) && props.pageSize));
    const { valueComputed } = useStateful(props, emit);
    const currentValue = computed({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / props.pageSize) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const paginationRange = computed(() => {
      const { visiblePages, total, pageSize, boundaryNumbers, pages } = props;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(total / pageSize) : pages;
      return setPaginationRange(value, visiblePages, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usesTotal.value ? Math.ceil(props.total / props.pageSize) || 1 : +props.pages);
    const isLastPageNotVisible = computed(() => !!props.visiblePages && lastPage.value > props.visiblePages || props.input);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers } = props;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => isLastPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick(() => {
        var _a;
        return (_a = htmlInput.value) == null ? void 0 : _a.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp_1(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * props.pageSize + 1 : limitedPageNum;
      (_a = itemRefs.value[pageNum - 1]) == null ? void 0 : _a.focus();
    };
    const resetInput = () => {
      var _a;
      inputValue.value = "";
      (_a = htmlInput.value) == null ? void 0 : _a.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba: colorToRgba2 } = useColors();
    const inputBorderColorComputed = computed(() => {
      const { color, buttonsPreset } = toRefs(props);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba2(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch([usesTotal, () => props.pages], () => {
      if (__DEV__ && usesTotal.value && props.pages) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed(() => ({
      size: props.size,
      preset: props.buttonsPreset,
      color: props.color,
      borderColor: props.borderColor,
      round: props.rounded
    }));
    const currentPageButtonProps = computed(() => ({
      preset: props.buttonsPreset === "default" ? "primary" : "default",
      color: props.activePageColor || props.color
    }));
    const getPageButtonProps = (n) => {
      if (!isNaN(+n) && n === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const isStandAloneInput = computed(() => props.input && !props.boundaryLinks && !props.directionLinks);
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props.size === "small" && isStandAloneInput.value,
      md: props.size === "medium" && isStandAloneInput.value,
      lg: props.size === "large" && isStandAloneInput.value,
      auto: !isStandAloneInput.value
    }));
    const classComputed = useBem("va-pagination", () => ({
      ...pick_1(props, ["gapped", "rounded", "disabled"]),
      bordered: !!props.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    return {
      ...useTranslation(),
      getPageButtonProps,
      inputClassComputed,
      classComputed,
      currentValue,
      lastPage,
      changeValue,
      inputValue,
      showPagination,
      showBoundaryLinks,
      onUserInput,
      showDirectionLinks,
      paginationRange,
      focusInput,
      inputStyleComputed,
      inputAttributesComputed,
      goNextPage,
      goPrevPage,
      buttonPropsComputed,
      htmlInput,
      setItemRefByIndex
    };
  }
});
var _hoisted_141 = ["aria-label"];
var _hoisted_222 = ["aria-label"];
function _sfc_render68(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.showPagination ? (openBlock(), createElementBlock("nav", {
    key: 0,
    class: normalizeClass(["va-pagination", _ctx.classComputed]),
    "aria-label": _ctx.t("pagination"),
    onKeydown: [
      _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.goPrevPage && _ctx.goPrevPage(...args), ["stop"]), ["left"])),
      _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.goNextPage && _ctx.goNextPage(...args), ["stop"]), ["right"])),
      _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.goPrevPage && _ctx.goPrevPage(...args), ["stop"]), ["up"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.goNextPage && _ctx.goNextPage(...args), ["stop"]), ["down"]))
    ]
  }, [
    _ctx.showBoundaryLinks ? renderSlot(_ctx.$slots, "firstPageLink", normalizeProps(mergeProps({ key: 0 }, { onClick: () => _ctx.onUserInput(1), disabled: _ctx.$props.disabled || _ctx.currentValue === 1 })), () => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goToTheFirstPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.boundaryIconLeft
      }, _ctx.buttonPropsComputed, {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onUserInput(1))
      }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    _ctx.showDirectionLinks ? renderSlot(_ctx.$slots, "prevPageLink", normalizeProps(mergeProps({ key: 1 }, { onClick: _ctx.goPrevPage, disabled: _ctx.$props.disabled || _ctx.currentValue === 1 })), () => [
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goToPreviousPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.directionIconLeft
      }, _ctx.buttonPropsComputed, { onClick: _ctx.goPrevPage }), null, 16, ["aria-label", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginationRange, (n, i) => {
        return openBlock(), createBlock(_component_va_button, mergeProps({
          key: i,
          ref_for: true,
          ref: _ctx.setItemRefByIndex(i),
          class: { "va-button--ellipsis": n === "...", "va-button--current": n === _ctx.currentValue },
          "aria-label": _ctx.t(`goToSpecificPage`, { page: n }),
          "aria-current": n === _ctx.currentValue,
          disabled: _ctx.$props.disabled || n === "..."
        }, _ctx.getPageButtonProps(n), {
          onClick: ($event) => _ctx.onUserInput(n)
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(n), 1)
          ]),
          _: 2
        }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
      }), 128))
    ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
      key: 3,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event),
      ref: "htmlInput",
      class: ["va-pagination__input va-button", _ctx.inputClassComputed],
      "aria-label": _ctx.t("goToSpecificPageInput"),
      style: _ctx.inputStyleComputed
    }, _ctx.inputAttributesComputed, {
      onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.changeValue && _ctx.changeValue(...args), ["enter"])),
      onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.focusInput && _ctx.focusInput(...args)),
      onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.changeValue && _ctx.changeValue(...args))
    }), null, 16, _hoisted_222)), [
      [vModelDynamic, _ctx.inputValue]
    ]),
    _ctx.showDirectionLinks ? renderSlot(_ctx.$slots, "nextPageLink", normalizeProps(mergeProps({ key: 4 }, { onClick: _ctx.goNextPage, disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage })), () => [
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goNextPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.directionIconRight
      }, _ctx.buttonPropsComputed, { onClick: _ctx.goNextPage }), null, 16, ["aria-label", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    _ctx.showBoundaryLinks ? renderSlot(_ctx.$slots, "lastPageLink", normalizeProps(mergeProps({ key: 5 }, { onClick: () => _ctx.onUserInput(_ctx.lastPage), disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage })), () => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goLastPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.boundaryIconRight
      }, _ctx.buttonPropsComputed, {
        onClick: _cache[5] || (_cache[5] = ($event) => _ctx.onUserInput(_ctx.lastPage))
      }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true)
  ], 42, _hoisted_141)) : createCommentVNode("", true);
}
var _VaPagination = _export_sfc(_sfc_main70, [["render", _sfc_render68], ["styles", [...VaButton2.styles || [], _style_065]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/index.js
var VaPagination = withConfigTransport(_VaPagination);

// node_modules/vuestic-ui/dist/web-components/src/composables/useScrollParent.js
var useScrollParent = () => {
  const window3 = useWindow();
  const fakeWindow = new Proxy(window3.value || {}, {
    get: (target, key, rec) => {
      var _a, _b;
      if (key === "scrollTop") {
        return (_a = window3.value) == null ? void 0 : _a.scrollY;
      }
      if (key === "scrollLeft") {
        return (_b = window3.value) == null ? void 0 : _b.scrollX;
      }
      const value = Reflect.get(target, key, rec);
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
  const getScrollableParent = (element) => {
    if (!element) {
      return fakeWindow;
    }
    if (element.scrollHeight > element.clientHeight) {
      return element;
    }
    return getScrollableParent(element.parentElement);
  };
  return { getScrollableParent };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-parallax/VaParallax.js
var _style_066 = ":root,\n:host {\n  --va-parallax-display: block;\n  --va-parallax-width: auto;\n  --va-parallax-z-index: 0;\n  /* Image container */\n  --va-parallax-image-container-contain: strict;\n  --va-parallax-image-container-user-select: none;\n  /* Image */\n  --va-parallax-image-will-change: transform;\n  --va-parallax-image-transition: 0.3s opacity linear;\n}\n.va-parallax {\n  display: var(--va-parallax-display);\n  position: relative;\n  overflow: hidden;\n  width: var(--va-parallax-width);\n  z-index: var(--va-parallax-z-index);\n  font-family: var(--va-font-family);\n}\n.va-parallax__image-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1;\n  contain: var(--va-parallax-image-container-contain);\n  -webkit-user-select: var(--va-parallax-image-container-user-select);\n     -moz-user-select: var(--va-parallax-image-container-user-select);\n          user-select: var(--va-parallax-image-container-user-select);\n}\n.va-parallax__image {\n  position: absolute;\n  bottom: 0;\n  left: 50%;\n  min-width: 100%;\n  max-width: unset;\n  min-height: 100%;\n  display: none;\n  transform: translate(-50%, 0);\n  will-change: var(--va-parallax-image-will-change);\n  transition: var(--va-parallax-image-transition);\n  z-index: 1;\n}\n.va-parallax__item-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 2;\n  contain: strict;\n}";
var _sfc_main71 = defineComponent({
  name: "VaParallax",
  props: {
    ...useComponentPresetProp,
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: Number, default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: Number,
      default: 0.5,
      validator: (value) => value >= 0 && value <= 1
    }
  },
  setup(props) {
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: props.height + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const { getScrollableParent } = useScrollParent();
    const targetElement = computed(() => {
      var _a;
      if (!props.target) {
        return getScrollableParent((_a = rootElement.value) == null ? void 0 : _a.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      warn("VaParallax target prop got wrong selector. Target is null");
      return null;
    });
    const imgHeight = computed(() => {
      var _a;
      return ((_a = img.value) == null ? void 0 : _a.naturalHeight) || 0;
    });
    const calcDimensions = () => {
      var _a, _b;
      const offset = ((_a = rootElement.value) == null ? void 0 : _a.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - props.height;
      elOffsetTop.value = offset.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props.height + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props.speed;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) == null ? void 0 : _a.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) == null ? void 0 : _a.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a, _b;
      if ((_a = img.value) == null ? void 0 : _a.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return {
      img,
      rootElement,
      computedWrapperStyles,
      computedImgStyles
    };
  }
});
var _hoisted_142 = { class: "va-parallax__image-container" };
var _hoisted_223 = ["src", "alt"];
var _hoisted_311 = { class: "va-parallax__item-container" };
function _sfc_render69(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-parallax",
    style: normalizeStyle(_ctx.computedWrapperStyles)
  }, [
    createBaseVNode("div", _hoisted_142, [
      createBaseVNode("img", {
        ref: "img",
        class: "va-parallax__image",
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        style: normalizeStyle(_ctx.computedImgStyles)
      }, null, 12, _hoisted_223)
    ]),
    createBaseVNode("div", _hoisted_311, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 4);
}
var _VaParallax = _export_sfc(_sfc_main71, [["render", _sfc_render69], ["styles", [_style_066]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-parallax/index.js
var VaParallax = withConfigTransport(_VaParallax);

// node_modules/vuestic-ui/dist/web-components/src/components/va-popover/VaPopover.js
var _style_067 = ":root,\n:host {\n  --va-popover-display: inline-block;\n  --va-popover-content-opacity: 1;\n  --va-popover-content-display: flex;\n  --va-popover-content-align-items: center;\n  --va-popover-content-padding: 0.65rem 1rem;\n  --va-popover-content-border-radius: 0.5rem;\n  --va-popover-content-font-size: 1rem;\n  --va-popover-content-box-shadow: 0 2px 3px 0;\n  --va-popover-content-background-color: var(--va-background-primary);\n  --va-popover-title-font-weight: 700;\n  --va-popover-title-margin-bottom: 0.125rem;\n  --va-popover-body-line-height: 1.5;\n}\n.va-popover {\n  display: var(--va-popover-display);\n}\n.va-popover__content {\n  background-color: var(--va-popover-content-background-color);\n  opacity: var(--va-popover-content-opacity);\n  display: var(--va-popover-content-display);\n  align-items: var(--va-popover-content-align-items);\n  padding: var(--va-popover-content-padding);\n  border-radius: var(--va-popover-content-border-radius, var(--va-block-border-radius));\n  font-size: var(--va-popover-content-font-size);\n}\n.va-popover__icon + div {\n  padding-left: 0.75rem;\n  overflow: hidden;\n  width: 100%;\n}\n.va-popover__title {\n  font-weight: var(--va-popover-title-font-weight);\n  margin-bottom: var(--va-popover-title-margin-bottom);\n}\n.va-popover__body {\n  line-height: var(--va-popover-body-line-height);\n}";
var VaDropdownProps3 = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var _sfc_main72 = defineComponent({
  name: "VaPopover",
  components: { VaDropdown, VaIcon: VaIcon2 },
  props: {
    ...VaDropdownProps3,
    ...useComponentPresetProp,
    trigger: { default: "hover" },
    color: { type: String, default: "#1b1a1f" },
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 }
  },
  setup(props, { slots }) {
    const VaDropdownPropValues = filterComponentProps(VaDropdownProps3);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const showIconComputed = computed(() => props.icon || slots.icon);
    const showTitleComputed = computed(() => props.title || slots.title);
    const showBodyComputed = computed(() => props.message || slots.body);
    const showPopoverContentComputed = computed(
      () => showTitleComputed.value || showBodyComputed.value
    );
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return {
      textColorComputed,
      VaDropdownPropValues,
      showBodyComputed,
      showIconComputed,
      showTitleComputed,
      computedPopoverStyle,
      showPopoverContentComputed
    };
  }
});
var _hoisted_143 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_224 = { key: 1 };
var _hoisted_312 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_410 = {
  key: 1,
  class: "va-popover__body"
};
function _sfc_render70(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps(_ctx.VaDropdownPropValues, {
    "model-value": _ctx.modelValue,
    "close-on-click-outside": _ctx.autoHide,
    offset: _ctx.$props.offset,
    class: "va-popover"
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        style: normalizeStyle(_ctx.computedPopoverStyle),
        class: "va-popover__content",
        role: "tooltip"
      }, [
        _ctx.showIconComputed ? (openBlock(), createElementBlock("div", _hoisted_143, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, {
              name: _ctx.$props.icon,
              color: _ctx.textColorComputed
            }, null, 8, ["name", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.showPopoverContentComputed ? (openBlock(), createElementBlock("div", _hoisted_224, [
          _ctx.showTitleComputed ? (openBlock(), createElementBlock("div", _hoisted_312, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.title), 1)
            ])
          ])) : createCommentVNode("", true),
          _ctx.showBodyComputed ? (openBlock(), createElementBlock("div", _hoisted_410, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.message), 1)
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 4)
    ]),
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["model-value", "close-on-click-outside", "offset"]);
}
var _VaPopover = _export_sfc(_sfc_main72, [["render", _sfc_render70], ["styles", [...VaDropdown.styles || [], ...VaIcon2.styles || [], _style_067]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-popover/index.js
var VaPopover = withConfigTransport(_VaPopover);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-bar/VaProgressBar.js
var _style_068 = ":root,\n:host {\n  --va-progress-bar-width: 100%;\n  --va-progress-bar-position: relative;\n  --va-progress-bar-overflow: hidden;\n  --va-progress-bar-height: 0.5rem;\n  --va-progress-bar-border-radius: 9999999px;\n  /* Small */\n  --va-progress-bar-sm-height: 2px;\n  /* Large */\n  --va-progress-bar-lg-height: 16px;\n  /* Info */\n  --va-progress-bar-info-font-weight: 700;\n  --va-progress-bar-info-text-align: center;\n  --va-progress-bar-info-text-transform: uppercase;\n  --va-progress-bar-info-not-empty-margin-bottom: 0.1rem;\n  /* Buffer */\n  --va-progress-bar-buffer-opacity: 0.3;\n  --va-progress-bar-buffer-transition: width ease 2s;\n  /* Overlay */\n  --va-progress-bar-transition: width ease 2s;\n  --va-progress-bar-letter-spacing: 0.6px;\n  --va-progress-bar-line-height: 1;\n  --va-progress-bar-font-size: 0.8em;\n  --va-progress-bar-font-weight: 700;\n}\n.va-progress-bar {\n  width: var(--va-progress-bar-width);\n  position: relative;\n  overflow: hidden;\n  font-family: var(--va-font-family);\n  line-height: var(--va-progress-bar-line-height);\n}\n.va-progress-bar__info {\n  font-weight: var(--va-progress-bar-info-font-weight);\n  text-align: var(--va-progress-bar-info-text-align);\n  text-transform: var(--va-progress-bar-info-text-transform);\n}\n.va-progress-bar__info:not(:empty) {\n  margin-bottom: var(--va-progress-bar-info-not-empty-margin-bottom);\n}\n.va-progress-bar__wrapper {\n  position: relative;\n  overflow: hidden;\n  border-radius: var(--va-progress-bar-border-radius);\n}\n.va-progress-bar--small .va-progress-bar__wrapper {\n  height: var(--va-progress-bar-sm-height);\n}\n.va-progress-bar--medium .va-progress-bar__wrapper {\n  height: var(--va-progress-bar-height);\n}\n.va-progress-bar--large .va-progress-bar__wrapper {\n  height: var(--va-progress-bar-lg-height);\n}\n.va-progress-bar--square .va-progress-bar__wrapper {\n  --va-progress-bar-border-radius: 0;\n}\n.va-progress-bar__buffer {\n  position: absolute;\n  top: 0;\n  height: inherit;\n  border-radius: inherit;\n  transition: var(--va-progress-bar-buffer-transition);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  letter-spacing: var(--va-progress-bar-letter-spacing);\n  font-size: var(--va-progress-bar-font-size);\n  font-weight: var(--va-progress-bar-font-weight);\n  background-color: var(--va-progress-bar-background-color);\n}\n.va-progress-bar__progress {\n  height: inherit;\n  border-radius: inherit;\n  transition: var(--va-progress-bar-transition);\n  background-color: var(--va-progress-bar-color);\n}\n.va-progress-bar__progress--indeterminate-start {\n  background-color: var(--va-progress-bar-color);\n  animation: va-progress-bar-indeterminate-start 2s ease-in infinite;\n  position: absolute;\n  height: inherit;\n}\n.va-progress-bar__progress--indeterminate-end {\n  background-color: var(--va-progress-bar-color);\n  animation: va-progress-bar-indeterminate-end 2s ease-out 1s infinite;\n  position: absolute;\n  height: inherit;\n}\n@keyframes va-progress-bar-indeterminate-start {\n0% {\n    width: 10%;\n    left: -10%;\n}\n50% {\n    width: 100%;\n    left: 100%;\n}\n100% {\n    width: 100%;\n    left: 100%;\n}\n}\n@keyframes va-progress-bar-indeterminate-end {\n0% {\n    width: 100%;\n    left: -100%;\n}\n50% {\n    width: 10%;\n    left: 100%;\n}\n100% {\n    width: 10%;\n    left: 100%;\n}\n}";
var _sfc_main73 = defineComponent({
  name: "VaProgressBar",
  props: {
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: Number, default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false },
    max: { type: Number, default: 100 }
  },
  setup(props) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const isTextSize = computed(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    const { t } = useTranslation();
    const progressBarValue = computed(() => 100 / props.max * props.modelValue);
    return {
      rootClass: computed(() => ({
        "va-progress-bar--square": !props.rounded,
        [`va-progress-bar--${props.size}`]: isTextSize.value
      })),
      rooStyle: computed(() => ({
        "--va-progress-bar-color": colorComputed.value,
        "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
      })),
      wrapperStyle: computed(() => ({
        height: getCSSHeight()
      })),
      bufferStyle: computed(() => ({
        width: `${props.indeterminate ? 100 : clamp_1(props.buffer, 0, 100)}%`,
        color: textColorComputed.value,
        [props.reverse ? "right" : "left"]: 0
      })),
      progressStyle: computed(() => ({
        marginLeft: props.reverse ? "auto" : void 0,
        width: `${clamp_1(progressBarValue.value, 0, 100)}%`
      })),
      intermediateStyle: computed(() => ({
        animationDirection: props.reverse ? "reverse" : "normal"
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        "aria-label": t("progressState"),
        "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
      }))
    };
  }
});
var _hoisted_144 = {
  key: 0,
  class: "va-progress-bar__info"
};
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-bar", _ctx.rootClass],
    style: _ctx.rooStyle
  }, _ctx.ariaAttributesComputed), [
    !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_144, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
        _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: "va-progress-bar__wrapper",
      style: normalizeStyle(_ctx.wrapperStyle)
    }, [
      createBaseVNode("div", {
        class: "va-progress-bar__buffer",
        style: normalizeStyle(_ctx.bufferStyle)
      }, [
        _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
          _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
          ], 64)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 4),
      _ctx.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-start",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4),
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-end",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4)
      ], 64)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-progress-bar__progress",
        style: normalizeStyle(_ctx.progressStyle)
      }, null, 4))
    ], 4)
  ], 16);
}
var _VaProgressBar = _export_sfc(_sfc_main73, [["render", _sfc_render71], ["styles", [_style_068]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-bar/index.js
var VaProgressBar = withConfigTransport(_VaProgressBar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/types.js
var RatingValue = ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/hooks/useRating.js
var getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = {
  ...useStatefulProps,
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
};
var useRating = (props) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp_1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/hooks/useVaRatingColors.js
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor } = useColors();
  const computedColor = computed(() => getColor(props.color));
  const backgroundColor = computed(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getColor(getTextColor(computedColor.value));
    }
    return getColor(getTextColor(backgroundColor.value));
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItem/VaRatingItem.js
var _style_069 = ".va-rating-item {\n  display: inline-block;\n}\n.va-rating-item:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-rating-item__wrapper {\n  font-size: 100%;\n  overflow: visible;\n  text-transform: none;\n  padding: 0;\n  background-color: transparent;\n  border-style: none;\n}";
var _sfc_main74 = defineComponent({
  name: "VaRatingItem",
  components: { VaIcon: VaIcon2 },
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(props, { emit }) {
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(
      props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color
    ));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onEnter = () => {
      modelValue.value = 1;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    return {
      computedColor,
      rootEl,
      onEnter,
      onClick,
      onMouseMove,
      onMouseLeave,
      visibleValue,
      computedIconName: computed(() => {
        if (props.halves && visibleValue.value === RatingValue.HALF) {
          return props.halfIcon;
        }
        if (visibleValue.value === RatingValue.EMPTY) {
          return props.emptyIcon;
        }
        return props.icon;
      }),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_145 = ["tabindex"];
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootEl",
    role: "button",
    class: "va-rating-item",
    tabindex: _ctx.tabIndexComputed,
    onKeyup: [
      _cache[0] || (_cache[0] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["enter"])),
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["space"]))
    ],
    onMousemove: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseMove && _ctx.onMouseMove(...args)),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.visibleValue, onClick: _ctx.onClick })), () => [
      createVNode(_component_va_icon, {
        class: "va-rating-item__wrapper",
        tabindex: "-1",
        tag: "button",
        name: _ctx.computedIconName,
        size: _ctx.$props.size,
        color: _ctx.computedColor
      }, null, 8, ["name", "size", "color"])
    ])
  ], 40, _hoisted_145);
}
var _VaRatingItem = _export_sfc(_sfc_main74, [["render", _sfc_render72], ["styles", [...VaIcon2.styles || [], _style_069]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItemNumberButton.js
var _sfc_main75 = defineComponent({
  name: "VaRatingItemNumberButton",
  props: {
    ...useVaRatingColorsProps,
    ...useSizeProps,
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  },
  setup(props) {
    return {
      ...useVaRatingColors(props),
      ...useSize(props, "VaRating")
    };
  }
});
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "va-rating__number-item",
    tabindex: "-1",
    "aria-hidden": "true",
    style: normalizeStyle({
      background: _ctx.backgroundComputed,
      color: _ctx.textColorComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed,
      fontSize: _ctx.fontSizeComputed,
      borderRadius: `${parseInt(_ctx.fontSizeComputed) * 0.125}rem`
    })
  }, toDisplayString(_ctx.itemNumber), 5);
}
var VaRatingItemNumberButton = _export_sfc(_sfc_main75, [["render", _sfc_render73]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/VaRating.js
var _style_070 = ":root,\n:host {\n  --va-rating-display: flex;\n  /* Number item */\n  --va-rating-number-item-font-size: inherit;\n  --va-rating-number-item-margin: 0.1em;\n  --va-rating-number-item-font-weight: 700;\n  --va-rating-number-item-cursor: pointer;\n  /* Item wrapper */\n  --va-rating-item-wrapper-cursor: pointer;\n}\n.va-rating {\n  display: var(--va-rating-display);\n  font-family: var(--va-font-family);\n}\n.va-rating__number-item {\n  font-size: 100%;\n  overflow: visible;\n  text-transform: none;\n  padding: 0;\n  background-color: transparent;\n  border-style: none;\n  font-size: var(--va-rating-number-item-font-size);\n  margin: var(--va-rating-number-item-margin);\n  font-weight: var(--va-rating-number-item-font-weight);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n}\n.va-rating--disabled .va-rating__number-item {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-rating--readonly .va-rating__number-item {\n  cursor: default;\n}\n.va-rating__item-wrapper {\n  display: flex;\n  cursor: var(--va-rating-item-wrapper-cursor);\n}\n.va-rating--readonly .va-rating__item-wrapper, .va-rating--disabled .va-rating__item-wrapper {\n  cursor: default;\n}\n.va-rating-item {\n  display: flex;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-rating--disabled .va-rating-item {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-rating--disabled .va-rating-item__wrapper {\n  cursor: initial !important;\n}\n.va-rating--readonly .va-rating-item .va-rating-item__wrapper {\n  cursor: initial !important;\n}\n.va-rating__text-wrapper {\n  padding-left: 10px;\n}";
var VaRatingItemProps = extractComponentProps(_VaRatingItem);
var VaRatingItemNumberButtonProps = extractComponentProps(VaRatingItemNumberButton, ["modelValue", "itemNumber"]);
var _sfc_main76 = defineComponent({
  name: "VaRating",
  props: {
    ...useRatingProps,
    ...useVaRatingColorsProps,
    ...useFormProps,
    ...VaRatingItemProps,
    ...VaRatingItemNumberButtonProps,
    ...useComponentPresetProp,
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: Number, default: 5 },
    texts: { type: Array, default: () => [] }
  },
  emits: ["update:modelValue"],
  components: { VaRatingItem: _VaRatingItem, VaRatingItemNumberButton },
  setup(props) {
    const { computedClasses: rootClass } = useForm("va-rating", props);
    const rating = useRating(props);
    const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
    return {
      ...useTranslation(),
      ...useVaRatingColors(props),
      ...rating,
      rootClass,
      VaRatingItemProps: filterComponentProps(VaRatingItemProps),
      VaRatingItemNumberButtonProps: filterComponentProps(VaRatingItemNumberButtonProps),
      isInteractionsEnabled,
      tabIndexComputed: computed(() => isInteractionsEnabled.value ? 0 : void 0),
      onArrowKeyPress: (direction) => {
        const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
        rating.onItemValueUpdate(rating.visibleValue.value, step * direction);
      }
    };
  }
});
var _hoisted_146 = ["aria-label"];
function _sfc_render74(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaRatingItemNumberButton = resolveComponent("VaRatingItemNumberButton");
  const _component_va_rating_item = resolveComponent("va-rating-item");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-rating", _ctx.rootClass]),
    "aria-label": _ctx.t("currentRating", { max: _ctx.$props.max, value: _ctx.$props.modelValue })
  }, [
    createBaseVNode("div", {
      class: "va-rating__item-wrapper",
      onKeyup: [
        _cache[0] || (_cache[0] = withKeys(($event) => _ctx.onArrowKeyPress(-1), ["left"])),
        _cache[1] || (_cache[1] = withKeys(($event) => _ctx.onArrowKeyPress(1), ["right"]))
      ],
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
        return openBlock(), createBlock(_component_va_rating_item, mergeProps({
          key: itemNumber,
          class: "va-rating__item"
        }, _ctx.VaRatingItemProps, {
          "aria-label": _ctx.t("voteRating", { max: _ctx.$props.max, value: _ctx.$props.modelValue }),
          "model-value": _ctx.getItemValue(itemNumber - 1),
          tabindex: _ctx.tabIndexComputed,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onHover: ($event) => _ctx.isInteractionsEnabled && _ctx.onItemHoveredValueUpdate(itemNumber - 1, $event),
          "onUpdate:modelValue": ($event) => _ctx.isInteractionsEnabled && _ctx.onItemValueUpdate(itemNumber - 1, $event)
        }), {
          default: withCtx(({ value, onClick }) => [
            renderSlot(_ctx.$slots, "item", normalizeProps(guardReactiveProps({ value, onClick, index: itemNumber })), () => [
              _ctx.$props.numbers ? (openBlock(), createBlock(_component_VaRatingItemNumberButton, mergeProps({ key: 0 }, _ctx.VaRatingItemNumberButtonProps, {
                "model-value": value,
                "item-number": itemNumber
              }), null, 16, ["model-value", "item-number"])) : createCommentVNode("", true)
            ])
          ]),
          _: 2
        }, 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
      }), 128))
    ], 32),
    _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "va-rating__text-wrapper",
      style: normalizeStyle({ color: _ctx.computedColor })
    }, toDisplayString(_ctx.$props.texts[Math.round(_ctx.visibleValue) - 1]), 5)) : createCommentVNode("", true)
  ], 10, _hoisted_146);
}
var _VaRating = _export_sfc(_sfc_main76, [["render", _sfc_render74], ["styles", [..._VaRatingItem.styles || [], ...VaRatingItemNumberButton.styles || [], _style_070]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/index.js
var VaRating = withConfigTransport(_VaRating);

// node_modules/vuestic-ui/dist/web-components/src/composables/useMaxSelections.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= maxSelections.value;
  };
  const addOption = (optionToAdd) => {
    return [...selections.value, optionToAdd];
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useObjectRefs.js
var useObjectRefs = () => {
  const itemRefs = shallowRef({});
  const setItemRef = (key) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[key] = el;
    return String(key);
  };
  onBeforeUpdate(() => {
    itemRefs.value = {};
  });
  return { itemRefs, setItemRef };
};

// node_modules/vuestic-ui/dist/web-components/src/utils/scroll-to-element.js
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOption/VaSelectOption.js
var _style_071 = ":root,\n:host {\n  --va-select-option-list-option-cursor: pointer;\n  --va-select-option-list-option-display: flex;\n  --va-select-option-list-option-align-items: center;\n  --va-select-option-list-option-padding: 0.375rem 0.75rem;\n  --va-select-option-list-option-min-height: 2.25rem;\n  --va-select-option-list-option-word-break: break-word;\n  /* Empty options list */\n  --va-select-option-list-empty-block-padding: 0.375rem 0.75rem;\n  /* Icon */\n  --va-select-option-list-option-icon-margin-right: 0.5rem;\n  /* Selected Icon */\n  --va-select-option-list-option-selected-icon-margin-left: auto;\n  --va-select-option-list-option-selected-icon-font-size: 0.8rem;\n  /* Disabled Option */\n  --va-select-option-list-option-disabled-opacity: 0.7;\n  /* Highlighted Chars */\n  --va-select-option-list-option-highlighted-color: var(--va-text-inverted);\n  --va-select-option-list-option-highlighted-background-color: var(--va-primary);\n  --va-select-option-list-option-highlighted-border-radius: 0.1rem;\n  --va-select-option-list-option-highlighted-margin: 0 1px;\n  --va-select-option-list-option-highlighted-padding: 0 1px;\n  /* Autocomplete */\n  --va-select-content-autocomplete-gap: 0.25rem;\n  --va-select-content-autocomplete-color: var(--va-text-primary);\n  --va-select-content-autocomplete-line-height: calc(var(--va-input-font-size) + 2px);\n}\n.va-select-option {\n  min-height: var(--va-select-option-list-option-min-height);\n  padding: var(--va-select-option-list-option-padding);\n  display: var(--va-select-option-list-option-display);\n  align-items: var(--va-select-option-list-option-align-items);\n  word-break: var(--va-select-option-list-option-word-break);\n  cursor: var(--va-select-option-list-option-cursor);\n}\n.va-select-option__icon {\n  margin-right: var(--va-select-option-list-option-icon-margin-right);\n}\n.va-select-option__selected-icon {\n  margin-left: var(--va-select-option-list-option-selected-icon-margin-left);\n  font-size: var(--va-select-option-list-option-selected-icon-font-size);\n}\n.va-select-option__highlighted {\n  color: var(--va-select-option-list-option-highlighted-color);\n  background-color: var(--va-select-option-list-option-highlighted-background-color);\n  border-radius: var(--va-select-option-list-option-highlighted-border-radius);\n  margin: var(--va-select-option-list-option-highlighted-margin);\n  padding: var(--va-select-option-list-option-highlighted-padding);\n}";
var _sfc_main77 = defineComponent({
  name: "VaSelectOption",
  components: { VaIcon: VaIcon2 },
  props: {
    ...useColorProps,
    disabled: { type: Boolean, default: false },
    option: { type: [Number, String, Object], default: () => ({}) },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    currentOption: { type: [String, Number, Object], default: null },
    getSelectedState: { type: Function, required: true },
    search: { type: String, default: "" },
    highlightMatchedText: { type: Boolean, default: true },
    inputFocused: { type: Boolean, default: false },
    minSearchChars: { type: Number, default: 0 }
  },
  setup(props) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const optionIcon = computed(() => typeof props.option === "object" ? props.option.icon : void 0);
    const optionIconColor = computed(() => getColor(props.color));
    const optionText = computed(() => props.getText(props.option));
    const optionTextSplitted = computed(() => {
      const defaultSplit = { start: optionText.value, searchedSubString: "", end: "" };
      if (!optionText.value || !props.search || !props.highlightMatchedText || props.search.length < props.minSearchChars) {
        return defaultSplit;
      }
      const substringStartIndex = optionText.value.toLowerCase().indexOf(props.search.toLowerCase());
      if (substringStartIndex < 0) {
        return defaultSplit;
      }
      const start = optionText.value.slice(0, substringStartIndex);
      const searchedSubString = optionText.value.slice(substringStartIndex, substringStartIndex + props.search.length);
      const end = optionText.value.slice(substringStartIndex + props.search.length);
      return { start, searchedSubString, end };
    });
    const isSelected = computed(() => props.getSelectedState(props.option));
    const isFocused = computed(() => {
      if (!props.currentOption && props.currentOption !== 0) {
        return false;
      }
      if (typeof props.option === "string") {
        return props.option === props.currentOption;
      }
      if (!props.getTrackBy) {
        return false;
      }
      return props.getTrackBy(props.currentOption) === props.getTrackBy(props.option);
    });
    const optionClass = useBem("va-select-option", () => ({
      selected: isSelected.value
    }));
    const optionStyle = computed(() => ({
      color: isSelected.value ? getColor(props.color) : "inherit",
      backgroundColor: isFocused.value ? getHoverColor2(getColor(props.color)) : "transparent",
      cursor: props.disabled ? "default" : void 0,
      opacity: props.disabled ? "var(--va-select-option-list-option-disabled-opacity)" : void 0
    }));
    return {
      getColor,
      isFocused,
      optionIcon,
      isSelected,
      optionStyle,
      optionClass,
      optionIconColor,
      optionTextSplitted
    };
  }
});
var _hoisted_147 = ["aria-selected"];
var _hoisted_225 = {
  key: 1,
  class: "va-select-option__highlighted"
};
function _sfc_render75(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    role: "option",
    class: normalizeClass(["va-select-option", _ctx.optionClass]),
    style: normalizeStyle(_ctx.optionStyle),
    "aria-selected": _ctx.isSelected
  }, [
    _ctx.optionIcon ? (openBlock(), createBlock(_component_va_icon, {
      key: 0,
      size: "small",
      class: "va-select-option__icon",
      name: _ctx.optionIcon
    }, null, 8, ["name"])) : createCommentVNode("", true),
    createTextVNode(" " + toDisplayString(_ctx.optionTextSplitted.start) + " ", 1),
    _ctx.optionTextSplitted.searchedSubString ? (openBlock(), createElementBlock("span", _hoisted_225, toDisplayString(_ctx.optionTextSplitted.searchedSubString), 1)) : createCommentVNode("", true),
    createTextVNode(" " + toDisplayString(_ctx.optionTextSplitted.end) + " ", 1),
    withDirectives(createVNode(_component_va_icon, {
      class: "va-select-option__selected-icon",
      size: "small",
      name: "va-check",
      color: _ctx.optionIconColor
    }, null, 8, ["color"]), [
      [vShow, _ctx.isSelected]
    ])
  ], 14, _hoisted_147);
}
var _VaSelectOption = _export_sfc(_sfc_main77, [["render", _sfc_render75], ["styles", [...VaIcon2.styles || [], _style_071]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOption/index.js
var VaSelectOption = withConfigTransport(_VaSelectOption);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.js
var _style_072 = ':root,\n:host {\n  --va-select-option-list-width: 100%;\n  --va-select-option-list-max-height: 12.5rem;\n  /* Group name */\n  --va-select-option-list-group-name-padding: 1rem 0.75rem 0.375rem;\n  --va-select-option-list-group-name-font-size: 0.6rem;\n  --va-select-option-list-group-name-color: var(--va-primary);\n  --va-select-option-list-group-name-font-weight: 700;\n  --va-select-option-list-group-name-text-transform: "uppercase";\n  /* Empty block */\n  --va-select-option-list-empty-padding: 0.5rem;\n}\n.va-select-option-list {\n  overflow: auto;\n  width: var(--va-select-option-list-width);\n  max-height: var(--va-select-option-list-max-height);\n  display: flex;\n  flex-direction: column;\n  font-family: var(--va-font-family);\n  scrollbar-color: var(--va-primary) transparent;\n  scrollbar-width: thin;\n}\n.va-select-option-list--empty {\n  padding: var(--va-select-option-list-empty-block-padding);\n}\n.va-select-option-list::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-select-option-list::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-select-option-list::-webkit-scrollbar-thumb {\n  background: var(--va-primary);\n  opacity: 0.3;\n  border-radius: 2px;\n}\n.va-select-option-list__group-name {\n  padding: var(--va-select-option-list-group-name-padding);\n  font-size: var(--va-select-option-list-group-name-font-size);\n  color: var(--va-select-option-list-group-name-color);\n  font-weight: var(--va-select-option-list-group-name-font-weight);\n  text-transform: var(--va-select-option-list-group-name-text-transform);\n}';
var _sfc_main78 = defineComponent({
  name: "VaSelectOptionList",
  components: { VaVirtualScroller, VaSelectOption },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: { type: [String, Number, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const root2 = shallowRef();
    const focus = () => {
      var _a;
      (_a = root2.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a, _b;
      return (_b = (_a = root2.value) == null ? void 0 : _a.clientHeight) != null ? _b : 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => {
      var _a;
      return (_a = props.hoveredOption) != null ? _a : null;
    });
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const currentSelectedOptionText = computed(() => {
      var _a;
      const selected = (_a = props.options) == null ? void 0 : _a.find((option) => props.getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a;
      return currentSelectedOptionText.value.toLowerCase() === ((_a = props.search) == null ? void 0 : _a.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (!props.search || props.search.length < props.minSearchChars || isSearchedOptionSelected.value) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !getGroupBy(option)) {
        groups._noGroup.push(option);
      } else {
        const groupBy = getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !!value || value === 0;
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option != null ? option : null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option != null ? option : null, "keyboard");
    };
    const selectOption = (option) => !getDisabled(option) && emit("select-option", option);
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick_1(props, ["getSelectedState", "color", "search", "highlightMatchedText", "minSearchChars"]),
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value - 1, true));
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a;
      if (!isValueExists(option)) {
        return;
      }
      const element = itemRefs.value[getTrackBy(option)];
      if (element) {
        scrollToElement(extractHTMLElement(element));
      }
      if (props.virtualScroller) {
        (_a = virtualScrollerRef.value) == null ? void 0 : _a[0].virtualScrollTo(currentOptionIndex.value);
      }
    };
    const publicMethods = {
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    return {
      root: root2,
      virtualScrollerRef,
      rootHeight,
      optionGroups: optionGroupsThrottled,
      filteredOptions,
      selectOptionProps,
      currentOptionComputed,
      onScroll,
      getTrackBy,
      setItemRef,
      getDisabled,
      selectOption,
      updateHoveredOption,
      handleScrollToBottom,
      ...publicMethods
    };
  }
});
var _hoisted_148 = ["tabindex"];
var _hoisted_226 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
var _hoisted_313 = {
  key: 0,
  class: "va-select-option-list--empty"
};
function _sfc_render76(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_select_option = resolveComponent("va-select-option");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_226, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        _ctx.$props.virtualScroller ? (openBlock(), createBlock(_component_va_virtual_scroller, {
          key: 1,
          ref_for: true,
          ref: "virtualScrollerRef",
          items: options,
          "track-by": _ctx.getTrackBy,
          "wrapper-size": _ctx.rootHeight,
          "onScroll:bottom": _ctx.handleScrollToBottom
        }, {
          default: withCtx(({ item: option, index }) => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, index, selectOption: _ctx.selectOption })), () => [
              createVNode(_component_va_select_option, mergeProps({
                option,
                "current-option": _ctx.currentOptionComputed,
                disabled: _ctx.getDisabled(option)
              }, _ctx.selectOptionProps, {
                onClick: withModifiers(($event) => _ctx.selectOption(option), ["stop"]),
                onMousemove: ($event) => _ctx.updateHoveredOption(option)
              }), null, 16, ["option", "current-option", "disabled", "onClick", "onMousemove"])
            ])
          ]),
          _: 2
        }, 1032, ["items", "track-by", "wrapper-size", "onScroll:bottom"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
          return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
            key: _ctx.getTrackBy(option)
          }, { option, index, selectOption: _ctx.selectOption })), () => [
            createVNode(_component_va_select_option, mergeProps({
              ref_for: true,
              ref: _ctx.setItemRef(_ctx.getTrackBy(option)),
              "current-option": _ctx.currentOptionComputed,
              option,
              disabled: _ctx.getDisabled(option)
            }, _ctx.selectOptionProps, {
              onClick: withModifiers(($event) => _ctx.selectOption(option), ["stop"]),
              onMousemove: ($event) => _ctx.updateHoveredOption(option)
            }), null, 16, ["current-option", "option", "disabled", "onClick", "onMousemove"])
          ]);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_313, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_148);
}
var _VaSelectOptionList = _export_sfc(_sfc_main78, [["render", _sfc_render76], ["styles", [...VaVirtualScroller.styles || [], ...VaSelectOption.styles || [], _style_072]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOptionList/index.js
var VaSelectOptionList = withConfigTransport(_VaSelectOptionList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectContent/VaSelectContent.js
var _style_073 = ":root,\n:host {\n  --va-select-cursor: pointer;\n  --va-select-dropdown-border-radius: 4px;\n  --va-select-dropdown-background: var(--va-background-secondary);\n  --va-select-box-shadow: 0 4px 8px rgba(59, 63, 73, 0.15);\n  --va-select-min-width: var(--va-form-element-min-width);\n  --va-select-state-icon-margin-left: 0.25rem;\n}\n.va-select-content__autocomplete {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--va-select-content-autocomplete-gap);\n  color: var(--va-select-content-autocomplete-color);\n  font-size: var(--va-input-font-size);\n  line-height: var(--va-select-content-autocomplete-line-height);\n}\n.va-select-content__autocomplete input {\n  flex: 1 1;\n}\n.va-select-content__placeholder {\n  overflow: hidden !important;\n  flex: 1;\n  line-height: normal;\n  color: var(--va-input-placeholder-text-color);\n  text-overflow: ellipsis !important;\n  white-space: nowrap !important;\n}\n.va-select-content__state-icon {\n  margin-left: var(--va-select-state-icon-margin-left);\n}";
var _sfc_main79 = defineComponent({
  name: "VaSelectContent",
  components: { VaBadge, VaIcon: VaIcon2 },
  props: {
    value: { type: Array, required: true },
    valueString: { type: String },
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hiddenSelectedOptionsAmount: { type: Number, default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(props, { emit }) {
    const autocompleteInput = ref();
    const isPlaceholder = computed(() => props.placeholder && !props.valueString);
    const toggleHiddenOptionsState = () => emit("toggle-hidden");
    const { value, focused } = toRefs(props);
    const autocompleteInputValueComputed = computed({
      get: () => props.autocompleteInputValue,
      set: (v) => emit("autocomplete-input", v)
    });
    watch(focused, (newValue) => {
      var _a, _b;
      if (!props.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a = autocompleteInput.value) == null ? void 0 : _a.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e) => {
      if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit("delete-last-selected");
      }
    };
    return {
      isPlaceholder,
      toggleHiddenOptionsState,
      autocompleteInputValueComputed,
      autocompleteInput,
      handleBackspace
    };
  }
});
var _hoisted_149 = {
  key: 0,
  class: "va-select-content__autocomplete"
};
var _hoisted_227 = ["placeholder", "disabled"];
var _hoisted_314 = {
  key: 1,
  class: "va-select-content__placeholder"
};
function _sfc_render77(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_badge = resolveComponent("va-badge");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.$props.autocomplete ? (openBlock(), createElementBlock("div", _hoisted_149, [
      _ctx.$props.multiple || _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 0 }, {
        value: _ctx.$props.value,
        valueString: _ctx.$props.valueString,
        tabindex: _ctx.$props.tabindex
      })), () => [
        _ctx.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.value, (option, index) => {
          return openBlock(), createElementBlock("span", {
            key: _ctx.$props.getText(option)
          }, toDisplayString(`${_ctx.$props.getText(option)}${index + 1 === _ctx.value.length ? "" : ", "}`), 1);
        }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.$props.valueString), 1)
        ], 64))
      ]) : createCommentVNode("", true),
      withDirectives(createBaseVNode("input", {
        ref: "autocompleteInput",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.autocompleteInputValueComputed = $event),
        placeholder: _ctx.$props.placeholder,
        disabled: _ctx.$props.disabled,
        autocomplete: "off",
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
          _cache[4] || (_cache[4] = (...args) => _ctx.handleBackspace && _ctx.handleBackspace(...args))
        ]
      }, null, 40, _hoisted_227), [
        [vModelText, _ctx.autocompleteInputValueComputed]
      ])
    ])) : _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_314, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 2 }, {
      valueString: _ctx.$props.valueString,
      value: _ctx.$props.value,
      tabindex: _ctx.$props.tabindex
    })), () => [
      createTextVNode(toDisplayString(_ctx.$props.valueString), 1)
    ]),
    renderSlot(_ctx.$slots, "hiddenOptionsBadge", normalizeProps(guardReactiveProps({
      amount: _ctx.$props.hiddenSelectedOptionsAmount,
      isShown: _ctx.$props.isAllOptionsShown,
      toggle: _ctx.toggleHiddenOptionsState
    })), () => [
      _ctx.$props.hiddenSelectedOptionsAmount && !_ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(_component_va_badge, {
        key: 0,
        class: "va-select-content__state-icon",
        color: "info",
        text: `+${_ctx.$props.hiddenSelectedOptionsAmount}`,
        tabindex: _ctx.$props.tabindex,
        onClick: withModifiers(_ctx.toggleHiddenOptionsState, ["stop"])
      }, null, 8, ["text", "tabindex", "onClick"])) : createCommentVNode("", true)
    ]),
    renderSlot(_ctx.$slots, "hideOptionsButton", normalizeProps(guardReactiveProps({
      isShown: _ctx.$props.isAllOptionsShown,
      toggle: _ctx.toggleHiddenOptionsState
    })), () => [
      _ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(_component_va_icon, {
        key: 0,
        role: "button",
        class: "va-select-content__state-icon",
        size: "small",
        name: "reply",
        tabindex: _ctx.$props.tabindex,
        onClick: withModifiers(_ctx.toggleHiddenOptionsState, ["stop"])
      }, null, 8, ["tabindex", "onClick"])) : createCommentVNode("", true)
    ])
  ], 64);
}
var _VaSelectContent = _export_sfc(_sfc_main79, [["render", _sfc_render77], ["styles", [...VaBadge.styles || [], ...VaIcon2.styles || [], _style_073]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectContent/index.js
var VaSelectContent = withConfigTransport(_VaSelectContent);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useMaxVisibleOptions.js
var useMaxVisibleOptionsProps = {
  maxVisibleOptions: { type: Number, default: 0 }
};
var useMaxVisibleOptions = (props) => {
  const modelValue = toRef(props, "modelValue");
  const isAllOptionsShown = ref(false);
  const belowLimitSelectedOptions = ref([]);
  const hiddenSelectedOptions = ref([]);
  const hiddenSelectedOptionsAmount = computed(() => hiddenSelectedOptions.value.length);
  const allSelectedOptions = computed(() => [...belowLimitSelectedOptions.value, ...hiddenSelectedOptions.value]);
  const visibleSelectedOptions = computed(() => {
    if (!props.maxVisibleOptions || isAllOptionsShown.value) {
      return allSelectedOptions.value;
    }
    return belowLimitSelectedOptions.value;
  });
  watch(modelValue, () => {
    if (!Array.isArray(modelValue.value)) {
      belowLimitSelectedOptions.value = [modelValue.value];
      hiddenSelectedOptions.value = [];
    }
    const value = modelValue.value;
    if (props.maxVisibleOptions) {
      belowLimitSelectedOptions.value = value.slice(0, props.maxVisibleOptions);
      hiddenSelectedOptions.value = value.slice(props.maxVisibleOptions);
    } else {
      belowLimitSelectedOptions.value = Array.isArray(value) ? [...value] : [value];
      hiddenSelectedOptions.value = [];
    }
  });
  const toggleHiddenOptionsState = () => isAllOptionsShown.value = !isAllOptionsShown.value;
  return {
    toggleHiddenOptionsState,
    isAllOptionsShown,
    visibleSelectedOptions,
    hiddenSelectedOptionsAmount,
    allSelectedOptions
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useToggleIcon.js
var useToggleIconProps = {
  dropdownIcon: {
    type: [String, Object],
    default: () => ({
      open: "va-arrow-down",
      close: "va-arrow-up"
    }),
    validator: (value) => {
      if (typeof value === "string") {
        return true;
      }
      return Object.entries(value).every(([prop, propValue]) => ["open", "close"].includes(prop) && typeof propValue === "string");
    }
  }
};
var useToggleIcon = (props, showDropdownContent) => {
  const toggleIcon = computed(() => {
    if (!props.dropdownIcon) {
      return "";
    }
    if (typeof props.dropdownIcon === "string") {
      return props.dropdownIcon;
    }
    return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
  });
  const { getHoverColor: getHoverColor2, getColor } = useColors();
  const colorComputed = computed(() => getColor(props.color));
  const toggleIconColor = computed(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
  return { toggleIcon, toggleIconColor };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useStringValue.js
var useStringValueProps = {
  separator: { type: String, default: ", " }
};
var useStringValue = (props, visibleSelectedOptions, getText) => {
  return computed(() => {
    var _a;
    if (!((_a = visibleSelectedOptions.value) == null ? void 0 : _a.length)) {
      return props.clearValue;
    }
    return visibleSelectedOptions.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useAutocomplete.js
var useAutocompleteProps = {
  autocomplete: { type: Boolean, default: false }
};
var useAutocomplete = (props, value, dropdownShown, getText) => {
  const getLastOptionText = (v) => (v == null ? void 0 : v.length) ? getText(v.at(-1)) : "";
  const autocompleteValue = ref("");
  watch(value, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    const newValueStringConverted = getLastOptionText(newValue);
    const oldValueStringConverted = getLastOptionText(oldValue);
    if (newValueStringConverted !== oldValueStringConverted) {
      autocompleteValue.value = props.multiple ? "" : newValueStringConverted;
      if (!props.multiple) {
        dropdownShown.value = false;
      }
    }
  });
  watch(autocompleteValue, (newValue) => {
    if (newValue && newValue !== getLastOptionText(value.value)) {
      dropdownShown.value = true;
    }
  });
  const onDropdownClosed = () => {
    autocompleteValue.value = props.multiple ? "" : getLastOptionText(value.value);
  };
  watch(dropdownShown, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (!newValue || oldValue) {
      onDropdownClosed();
    }
  });
  return autocompleteValue;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/VaSelect.js
var _style_074 = ":root,\n:host {\n  --va-select-cursor: pointer;\n  --va-select-dropdown-border-radius: 4px;\n  --va-select-dropdown-background: var(--va-background-secondary);\n  --va-select-box-shadow: 0 4px 8px rgba(59, 63, 73, 0.15);\n  --va-select-min-width: var(--va-form-element-min-width);\n  --va-select-state-icon-margin-left: 0.25rem;\n}\n.va-select {\n  min-width: var(--va-select-min-width);\n}\n.va-select .va-input-wrapper__text {\n  line-height: normal;\n  flex-wrap: wrap;\n}\n.va-select-anchor__input {\n  cursor: var(--va-select-cursor);\n  flex: 1;\n}\n.va-select-anchor--nowrap .va-input-wrapper__text {\n  flex-wrap: nowrap;\n}\n.va-select-dropdown__content {\n  overflow: hidden;\n  border-bottom-right-radius: var(--va-select-dropdown-border-radius);\n  border-bottom-left-radius: var(--va-select-dropdown-border-radius);\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n  box-shadow: var(--va-select-box-shadow);\n  padding: 0;\n}\n.va-select-dropdown__content-search-input {\n  min-width: auto;\n  width: 100%;\n}\n.va-select-dropdown__options-wrapper {\n  background: var(--va-select-dropdown-background);\n  overflow-y: auto;\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n}";
var VaDropdownProps4 = extractComponentProps(
  VaDropdown,
  ["keyboardNavigation", "offset", "stateful", "keepAnchorWidth", "closeOnContentClick", "innerAnchorSelector", "modelValue"]
);
var _sfc_main80 = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectContent,
    VaSelectOptionList,
    VaIcon: VaIcon2,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: {
    ...VaDropdownProps4,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    requiredMark: { type: Boolean, default: false }
  },
  setup(props, { emit, slots }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getOptionByValue, getValue: getValue2, getText, getTrackBy } = useSelectableList(props);
    const onScrollBottom = () => emit("scroll-bottom");
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props);
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string or a number for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue2));
        } else {
          emit("update:modelValue", getValue2(value));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(getValue2(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue2(option), getValue2(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : { ...option };
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => [searchInput.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchInput.value || autocompleteValue.value);
        searchInput.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value && hoveredOption.value !== 0) {
        return;
      }
      if (!showDropdownContent.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchInput.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const { tp, t } = useTranslation();
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps4).value,
      closeOnContentClick: closeOnContentClick.value,
      stateful: false,
      offset: [1, 0],
      keepAnchorWidth: true,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      "aria-label": props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption")
    }));
    const optionsListPropsComputed = computed(() => ({
      ...pick_1(props, ["textBy", "trackBy", "groupBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "minSearchChars", "delay"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchInput.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText)
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, showDropdownContent);
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const inputWrapperPropsComputed = computed(() => ({
      ...pick_1(props, ["messages", "requiredMark", "bordered", "outline", "label", "color", "success"]),
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      tabindex: tabIndexComputed.value
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick_1(props, ["placeholder", "autocomplete", "multiple", "disabled"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText
    }));
    const autocompleteValue = useAutocomplete(props, visibleSelectedOptions, showDropdownContent, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
      resetValidation();
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete) {
        e == null ? void 0 : e.stopImmediatePropagation();
        isInputFocused.value = true;
        showDropdownContent.value = true;
      }
    };
    const toggleDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    return {
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      toggleDropdown,
      deleteLastSelected,
      focusAutocompleteInput,
      tp,
      t,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueString,
      showClearIcon,
      toggleIcon,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      focusPreviousOption,
      focusNextOption,
      showDropdownContentComputed,
      handleDropdownOpen,
      handleDropdownClose,
      hideAndFocus,
      toggleIconColor,
      onHintedSearch,
      onScrollBottom,
      clearIconProps,
      dropdownPropsComputed,
      visibleSelectedOptions,
      optionsListPropsComputed,
      toggleHiddenOptionsState,
      setAutocompleteValue,
      inputWrapperPropsComputed,
      inputWrapperClassComputed,
      selectContentPropsComputed
    };
  }
});
function _sfc_render78(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_select_content = resolveComponent("va-select-content");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    ref: "dropdown",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    class: "va-select va-select__dropdown va-select-dropdown"
  }, _ctx.dropdownPropsComputed), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({
        ref: "input",
        class: ["va-select__anchor va-select-anchor__input", _ctx.inputWrapperClassComputed],
        "model-value": _ctx.valueString
      }, _ctx.inputWrapperPropsComputed, {
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur,
        onClick: _ctx.focusAutocompleteInput
      }), createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": _ctx.t("reset"),
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
          _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
            key: 1,
            color: _ctx.$props.color,
            size: "small",
            name: "va-loading",
            spin: "counter-clockwise"
          }, null, 8, ["color"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon,
            onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
          }, null, 8, ["color", "name", "onClick"])
        ]),
        default: withCtx(() => [
          createVNode(_component_va_select_content, mergeProps(_ctx.selectContentPropsComputed, {
            onToggleHidden: _ctx.toggleHiddenOptionsState,
            onAutocompleteInput: _ctx.setAutocompleteValue,
            onFocusPrev: _ctx.focusPreviousOption,
            onFocusNext: _ctx.focusNextOption,
            onSelectOption: _ctx.selectOrAddOption,
            onDeleteLastSelected: _ctx.deleteLastSelected
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["onToggleHidden", "onAutocompleteInput", "onFocusPrev", "onFocusNext", "onSelectOption", "onDeleteLastSelected"])
        ]),
        _: 2
      }, [
        renderList(_ctx.$slots, (_, name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "model-value", "onFocus", "onBlur", "onClick"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width })
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            "aria-label": _ctx.t("optionsFilter"),
            tabindex: _ctx.tabIndexComputed,
            placeholder: _ctx.tp(_ctx.$props.searchPlaceholderText),
            bordered: "",
            onKeydown: [
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode("", true),
          createVNode(_component_va_select_option_list, mergeProps({
            ref: "optionList",
            class: "va-select-dropdown__options-wrapper",
            hoveredOption: _ctx.hoveredOption,
            "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
            style: { maxHeight: _ctx.$props.maxHeight }
          }, _ctx.optionsListPropsComputed, {
            onSelectOption: _ctx.selectOption,
            onNoPreviousOptionToHover: _ctx.focusSearchBar,
            onKeydown: [
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
              _ctx.onHintedSearch
            ],
            onScrollBottom: _ctx.onScrollBottom
          }), {
            default: withCtx((slotData) => [
              renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData || {})))
            ]),
            _: 3
          }, 16, ["hoveredOption", "style", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
        ]),
        _: 3
      }, 8, ["style"])
    ]),
    _: 3
  }, 16, ["modelValue"]);
}
var _VaSelect = _export_sfc(_sfc_main80, [["render", _sfc_render78], ["styles", [...VaSelectContent.styles || [], ...VaSelectOptionList.styles || [], ...VaIcon2.styles || [], ...VaDropdown.styles || [], ...VaDropdownContent.styles || [], ...VaInput.styles || [], ...VaInputWrapper.styles || [], _style_074]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/index.js
var VaSelect = withConfigTransport(_VaSelect);

// node_modules/vuestic-ui/dist/web-components/src/components/va-separator/VaSeparator.js
var _style_075 = ":root,\n:host {\n  --va-separator-height: 1px;\n  --va-separator-background-color: var(--va-divider);\n  --va-separator-margin-top: 1rem;\n  --va-separator-margin-bottom: 1rem;\n}\n.va-separator {\n  height: var(--va-separator-height);\n  background-color: var(--va-separator-background-color);\n  margin-top: var(--va-separator-margin-top);\n  margin-bottom: var(--va-separator-margin-bottom);\n}\n.va-tabs + .va-separator {\n  margin-top: 0;\n}\n.va-card :is(.va-card__title, .va-card__content, .va-card__actions, .va-card_actions__vertical) > .va-separator {\n  margin-right: calc(-1 * var(--va-card-padding));\n  margin-left: calc(-1 * var(--va-card-padding));\n}";
var _sfc_main81 = defineComponent({
  name: "VaSeparator"
});
var _hoisted_150 = {
  class: "va-separator",
  "aria-hidden": "true"
};
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_150);
}
var VaSeparator = _export_sfc(_sfc_main81, [["render", _sfc_render79], ["styles", [_style_075]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/VaSkeleton.js
var _style_076 = ':root,\n:host {\n  --va-skeleton-wave-color: rgb(100, 100, 100);\n  --va-skeleton-wave-opacity: 0.2;\n  --va-skeleton-border-radius: unset;\n  --va-skeleton-animation-duration: 2.5s;\n}\n@keyframes pulse {\n0% {\n    filter: brightness(1);\n}\n50% {\n    filter: brightness(1);\n}\n75% {\n    filter: brightness(0.9);\n}\n100% {\n    filter: brightness(1);\n}\n}\n@keyframes wave {\n0% {\n    left: -100%;\n}\n100% {\n    left: 100%;\n}\n}\n.va-skeleton {\n  background: var(--68642958);\n  height: var(--5e0c6c8c);\n  width: var(--301414bb);\n  border-radius: var(--010d0dd4);\n  cursor: wait;\n}\n.va-skeleton--pulse {\n  animation: var(--va-skeleton-animation-duration) ease-in-out 0s infinite normal none running pulse;\n}\n.va-skeleton--wave {\n  -webkit-mask-image: -webkit-radial-gradient(white, black);\n          mask-image: -webkit-radial-gradient(white, black);\n}\n.va-skeleton--wave .va-skeleton__wave {\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  height: 100%;\n  width: 100%;\n}\n.va-skeleton--wave .va-skeleton__wave::after {\n  display: block;\n  position: relative;\n  content: "";\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: var(--va-skeleton-wave-opacity, 0.5);\n  background: linear-gradient(90deg, transparent, var(--va-skeleton-wave-color), transparent);\n  animation: var(--va-skeleton-animation-duration) linear 0s infinite normal none running wave;\n}\n.va-skeleton--hidden {\n  position: absolute;\n  overflow: hidden;\n  clip: rect(0 0 0 0);\n  height: 1px;\n  width: 1px;\n  margin: -1px;\n  padding: 0;\n  border: 0;\n}\n.va-skeleton--lines {\n  background: repeating-linear-gradient(180deg, var(--68642958), var(--68642958) calc(1em - var(--08c1120a) / 2), transparent calc(1em - var(--08c1120a) / 2), transparent 1em);\n}\n.va-skeleton--lines .va-skeleton__wave::after {\n  -webkit-mask-image: repeating-linear-gradient(180deg, black, black calc(1em - var(--08c1120a) / 2), transparent calc(1em - var(--08c1120a) / 2), transparent 1em);\n          mask-image: repeating-linear-gradient(180deg, black, black calc(1em - var(--08c1120a) / 2), transparent calc(1em - var(--08c1120a) / 2), transparent 1em);\n}\n.va-skeleton--text {\n  width: 100%;\n  -webkit-clip-path: polygon(0% 0%, 0% 100%, var(--5c49a604) 100%, var(--5c49a604) calc(100% - 1em), 100% calc(100% - 1em), 100% 100%, 1em 100%, var(--5c49a604) 100%, 100% 100%, 100% 0%);\n          clip-path: polygon(0% 0%, 0% 100%, var(--5c49a604) 100%, var(--5c49a604) calc(100% - 1em), 100% calc(100% - 1em), 100% 100%, 1em 100%, var(--5c49a604) 100%, 100% 100%, 100% 0%);\n}\n.va-skeleton--circle {\n  min-width: var(--301414bb);\n  min-height: var(--5e0c6c8c);\n}';
var __default__10 = defineComponent({
  name: "VaSkeleton",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: Number, default: 100 },
    tag: { type: String, default: "div" },
    animation: { type: String, default: "pulse" },
    lines: { type: Number, default: 1 },
    height: { type: [String], default: "5em" },
    width: { type: [String], default: "100%" },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" },
    variant: { type: String, default: "squared" }
  },
  setup(props, { attrs }) {
    const doShow = ref(false);
    let timeoutId;
    onMounted(() => {
      setTimeout(() => {
        doShow.value = true;
      }, props.delay);
    });
    onBeforeUnmount(() => {
      clearTimeout(timeoutId);
    });
    const heightComputed = computed(() => {
      if (props.variant === "text") {
        return `${props.lines}em`;
      }
      return props.height;
    });
    const widthComputed = computed(() => {
      if (props.variant === "circle") {
        return heightComputed.value;
      }
      return props.width;
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const negativeLineGap = computed(() => `-${props.lineGap}`);
    const bem = useBem("va-skeleton", () => ({
      lines: props.lines > 1,
      text: props.variant === "text",
      circle: props.variant === "circle",
      hidden: !doShow.value,
      pulse: props.animation === "pulse",
      wave: props.animation === "wave"
    }));
    const borderRadius = computed(() => {
      if (props.variant === "circle") {
        return "50%";
      }
      if (props.variant === "rounded") {
        return `var(--va-skeleton-border-radius, calc(${heightComputed.value} / 5))`;
      }
      return "0px";
    });
    return {
      classes: computed(() => [
        ...Object.keys(bem),
        attrs.class
      ]),
      colorComputed,
      negativeLineGap,
      doShow,
      heightComputed,
      widthComputed,
      borderRadius
    };
  }
});
var __injectCSSVars__10 = () => {
  useCssVars((_ctx) => ({
    "68642958": _ctx.colorComputed,
    "5e0c6c8c": _ctx.heightComputed,
    "301414bb": _ctx.widthComputed,
    "010d0dd4": _ctx.borderRadius,
    "08c1120a": _ctx.lineGap,
    "5c49a604": _ctx.lastLineWidth
  }));
};
var __setup__10 = __default__10.setup;
__default__10.setup = __setup__10 ? (props, ctx) => {
  __injectCSSVars__10();
  return __setup__10(props, ctx);
} : __injectCSSVars__10;
var _sfc_main82 = __default__10;
var _hoisted_151 = {
  key: 0,
  class: "va-skeleton__wave"
};
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
    class: normalizeClass(["va-skeleton", _ctx.classes]),
    role: "status",
    "aria-live": "polite",
    "aria-label": "Loading",
    "aria-atomic": "true"
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      _ctx.animation === "wave" ? (openBlock(), createElementBlock("div", _hoisted_151)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["class"]);
}
var _VaSkeleton = _export_sfc(_sfc_main82, [["render", _sfc_render80], ["styles", [_style_076]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/components/VaSkeletonGroup.js
var _style_077 = ".va-skeleton-group[data-v-91b5ab0a] {\n  position: relative;\n  cursor: progress;\n}\n.va-skeleton-group--hidden[data-v-91b5ab0a] {\n  display: none;\n}";
var _sfc_main83 = defineComponent({
  name: "VaSkeletonGroup",
  components: {
    VaConfig
  },
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: Number, default: 100 },
    animation: { type: String, default: "pulse" },
    lines: { type: Number, default: 1 },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" }
  },
  setup(props) {
    const doShow = ref(false);
    let timeoutId;
    onMounted(() => {
      timeoutId = setTimeout(() => {
        doShow.value = true;
      }, props.delay);
    });
    onBeforeMount(() => {
      clearTimeout(timeoutId);
    });
    const bem = useBem("va-skeleton-group", () => ({
      hidden: doShow.value === false
    }));
    return {
      doShow,
      bem,
      config: computed(() => ({ ...props, delay: 0 }))
    };
  }
});
function _sfc_render81(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaConfig = resolveComponent("VaConfig");
  return openBlock(), createBlock(_component_VaConfig, {
    components: { VaSkeleton: _ctx.config }
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        class: ["va-skeleton-group", _ctx.bem]
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 16)
    ]),
    _: 3
  }, 8, ["components"]);
}
var _VaSkeletonGroup = _export_sfc(_sfc_main83, [["render", _sfc_render81], ["styles", [_style_077]], ["__scopeId", "data-v-91b5ab0a"]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/index.js
var VaSkeleton = withConfigTransport(_VaSkeleton);
var VaSkeletonGroup = withConfigTransport(_VaSkeletonGroup);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/hooks/useSidebar.js
var VaSidebarKey = Symbol("VaSidebar");
var useSidebar = (props) => {
  provide(VaSidebarKey, props);
};
var useSidebarItem = () => {
  return inject(VaSidebarKey, {
    color: "background-element"
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebar.js
var _style_078 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: hidden;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar {\n  min-height: var(--va-sidebar-min-height);\n  height: var(--va-sidebar-height);\n  position: var(--va-sidebar-position);\n  top: var(--va-sidebar-top);\n  left: var(--va-sidebar-left);\n  z-index: var(--va-sidebar-z-index);\n  font-family: var(--va-font-family);\n  display: inline-flex;\n}\n.va-sidebar__menu {\n  display: flex;\n  flex-direction: column;\n  max-height: var(--va-sidebar-menu-max-height);\n  margin-bottom: var(--va-sidebar-menu-margin-bottom);\n  list-style: var(--va-sidebar-menu-list-style);\n  padding-left: var(--va-sidebar-menu-padding-left);\n  overflow-y: var(--va-sidebar-menu-overflow-y);\n  overflow-x: var(--va-sidebar-menu-overflow-x);\n  scrollbar-color: var(--va-primary) transparent;\n  scrollbar-width: thin;\n}\n.va-sidebar__menu::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-sidebar__menu::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-sidebar__menu::-webkit-scrollbar-thumb {\n  background: var(--va-primary);\n  opacity: 0.3;\n  border-radius: 2px;\n}\n.va-sidebar--animated {\n  transition: var(--va-sidebar-transition);\n}\n.va-sidebar--animated .va-sidebar__menu {\n  transition: var(--va-sidebar-transition);\n}\n.va-sidebar--minimized {\n  left: 0;\n}\n.va-sidebar--minimized .va-sidebar__title {\n  display: none;\n}\n.va-sidebar--right {\n  left: auto;\n  right: 0;\n}";
var _sfc_main84 = defineComponent({
  name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: Number,
      default: 0.2,
      validator: (v) => v >= 0 && v <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    position: {
      type: String,
      default: "left",
      validator: (v) => ["left", "right"].includes(v)
    },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: Boolean, default: true }
  },
  components: { VaConfig },
  setup(props) {
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const computedWidth = computed(() => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    });
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => {
      const backgroundColor = getColor(props.color);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      right: props.position === "right",
      animated: props.animated
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    return {
      computedWidth,
      computedClass,
      computedStyle,
      updateHoverState,
      vaSidebarItemProps: computed(() => ({
        textColor: props.textColor,
        activeColor: props.activeColor,
        hoverColor: props.hoverColor,
        borderColor: props.borderColor,
        hoverOpacity: props.hoverOpacity
      }))
    };
  }
});
function _sfc_render82(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("aside", {
    class: normalizeClass(["va-sidebar", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.updateHoverState(false))
  }, [
    createBaseVNode("div", {
      class: "va-sidebar__menu",
      style: normalizeStyle(`width: ${_ctx.computedWidth};`)
    }, [
      createVNode(_component_va_config, {
        components: { VaSidebarItem: _ctx.vaSidebarItemProps }
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["components"])
    ], 4)
  ], 38);
}
var _VaSidebar = _export_sfc(_sfc_main84, [["render", _sfc_render82], ["styles", [...VaConfig.styles || [], _style_078]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/index.js
var VaSidebar = withConfigTransport(_VaSidebar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/validateSlider.js
var validateSlider = (value, step, min, max, range) => {
  if (Array.isArray(value) && !range || !Array.isArray(value) && range) {
    warn(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
  }
  if (max < min) {
    warn(`The maximum value (${max}) can not be less than the minimum value (${min}).`);
  }
  if ((max - min) % step !== 0) {
    warn(`Step ${step} is illegal. Slider is non-divisible (Min:Max-${min}:${max}).`);
  }
  const inRange = (v) => {
    if (v < min) {
      warn(`The value of the slider is ${v}, the minimum value is ${min}, the value of this slider can not be less than the minimum value`);
    } else if (v > max) {
      warn(`The value of the slider is ${v}, the maximum value is ${max}, the value of this slider can not be greater than the maximum value`);
    }
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  } else {
    inRange(value);
  }
  return true;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/VaSlider.js
var _style_079 = ":root,\n:host {\n  /* Track */\n  --va-slider-track-border-radius: 0.25rem;\n  --va-slider-track-transition: 0.5s ease-out;\n  --va-slider-track-opacity: 1;\n  /* Pin */\n  --va-slider-pin-transition: background-color 0.3s ease-out 0.1s;\n  /* Handler */\n  --va-slider-handler-width: 1.25rem;\n  --va-slider-handler-height: 1.25rem;\n  --va-slider-handler-background: var(--va-background-primary);\n  --va-slider-handler-border: 0.375rem solid;\n  --va-slider-handler-border-radius: 50%;\n  --va-slider-handler-outline: none !important;\n  --va-slider-handler-left: -0.375rem;\n  --va-slider-handler-transition: 0s;\n  /* Dot */\n  --va-slider-dot-transform: translate(-0.625rem, -0.625rem);\n  --va-slider-dot-display: block;\n  --va-slider-dot-width: 1.75rem;\n  --va-slider-dot-height: 1.75rem;\n  --va-slider-dot-border-radius: 50%;\n  --va-slider-dot-opacity: 0.2;\n  --va-slider-dot-pointer-events: none;\n  /* Dot Value */\n  --va-slider-dot-value-transform: translate(-50%, -100%);\n  --va-slider-dot-value-user-select: none;\n  --va-slider-dot-value-font-size: 0.625rem;\n  --va-slider-dot-value-letter-spacing: 0.6px;\n  --va-slider-dot-value-line-height: 1.2;\n  --va-slider-dot-value-font-weight: 700;\n  --va-slider-dot-value-text-transform: none;\n  --va-slider-dot-value-white-space: nowrap;\n  /* Input Label */\n  --va-slider-input-label-user-select: none;\n  --va-slider-input-label-font-size: 0.625rem;\n  --va-slider-input-label-letter-spacing: 0.6px;\n  --va-slider-input-label-line-height: 1.2;\n  --va-slider-input-label-font-weight: 700;\n  --va-slider-input-label-text-transform: uppercase;\n  --va-slider-input-label-inverse-user-select: none;\n  --va-slider-input-label-inverse-font-size: 0.625rem;\n  --va-slider-input-label-inverse-letter-spacing: 0.6px;\n  --va-slider-input-label-inverse-line-height: 1.2;\n  --va-slider-input-label-inverse-font-weight: 700;\n  --va-slider-input-label-inverse-text-transform: uppercase;\n  /* Horizontal */\n  --va-slider-horizontal-input-wrapper-margin-right: 1rem;\n  /* Horizontal Track */\n  --va-slider-horizontal-track-height: 0.5rem;\n  --va-slider-horizontal-track-width: 100%;\n  /* Horizontal Track */\n  --va-slider-horizontal-handler-transform: translateX(-50%);\n  /* Horizontal Dot */\n  --va-slider-horizontal-dot-value-top: -8px;\n  --va-slider-horizontal-dot-value-left: 50%;\n  /* Vertical */\n  --va-slider-vertical-height: 100%;\n  --va-slider-vertical-padding: 12px 0 12px 0;\n  --va-slider-vertical-flex-direction: column;\n  --va-slider-vertical-align-items: center;\n  /* Vertical Label */\n  --va-slider-vertical-label-margin-bottom: 0.625rem;\n  --va-slider-vertical-label-inverse-left: -0.375rem;\n  --va-slider-vertical-label-inverse-margin-top: 0.625rem;\n  /* Vertical Input Wrapper */\n  --va-slider-vertical-input-wrapper-max-width: 1rem;\n  --va-slider-vertical-input-wrapper-min-width: 2.5rem;\n  /* Vertical Track */\n  --va-slider-vertical-track-height: 100%;\n  --va-slider-vertical-track-width: 0.5rem;\n  --va-slider-vertical-track-bottom: 0;\n  /* Vertical Handler */\n  --va-slider-vertical-handler-transform: translateY(50%);\n  /* Vertical Dot Value */\n  --va-slider-vertical-dot-value-top: 0.625rem;\n  --va-slider-vertical-dot-value-left: 1.25rem;\n}\n.va-slider {\n  display: flex;\n  align-items: center;\n  font-family: var(--va-font-family);\n}\n.va-slider__input-wrapper {\n  position: relative;\n  display: flex;\n}\n.va-slider__container {\n  position: relative;\n  display: flex;\n  align-items: center;\n  cursor: grab;\n}\n.va-slider__track {\n  position: absolute;\n  border-radius: var(--va-slider-track-border-radius);\n  transition: var(--va-slider-track-transition);\n  opacity: var(--va-slider-track-opacity);\n}\n.va-slider__track--active {\n  transition: 0s;\n}\n.va-slider__track--selected {\n  opacity: 1;\n}\n.va-slider__handler {\n  position: absolute;\n  width: var(--va-slider-handler-width);\n  height: var(--va-slider-handler-height);\n  background: var(--va-slider-handler-background);\n  border: var(--va-slider-handler-border);\n  border-radius: var(--va-slider-handler-border-radius);\n  outline: var(--va-slider-handler-outline);\n  left: var(--va-slider-handler-left);\n  transition: var(--va-slider-handler-transition);\n  box-sizing: border-box;\n}\n.va-slider__handler__dot--focus {\n  transform: var(--va-slider-dot-transform);\n  display: block;\n  width: var(--va-slider-dot-width);\n  height: var(--va-slider-dot-height);\n  position: absolute;\n  border-radius: var(--va-slider-dot-border-radius);\n  opacity: var(--va-slider-dot-opacity);\n  pointer-events: var(--va-slider-dot-pointer-events);\n}\n.va-slider__handler__dot--value {\n  transform: var(--va-slider-dot-value-transform);\n  -webkit-user-select: var(--va-slider-dot-value-user-select);\n     -moz-user-select: var(--va-slider-dot-value-user-select);\n          user-select: var(--va-slider-dot-value-user-select);\n  font-size: var(--va-slider-dot-value-font-size);\n  letter-spacing: var(--va-slider-dot-value-letter-spacing);\n  line-height: var(--va-slider-dot-value-line-height);\n  font-weight: var(--va-slider-dot-value-font-weight);\n  text-transform: var(--va-slider-dot-value-text-transform);\n  white-space: var(--va-slider-dot-value-white-space);\n}\n.va-slider .va-input__label {\n  -webkit-user-select: var(--va-slider-input-label-user-select);\n     -moz-user-select: var(--va-slider-input-label-user-select);\n          user-select: var(--va-slider-input-label-user-select);\n  font-size: var(--va-slider-input-label-font-size);\n  letter-spacing: var(--va-slider-input-label-letter-spacing);\n  line-height: var(--va-slider-input-label-line-height);\n  font-weight: var(--va-slider-input-label-font-weight);\n  text-transform: var(--va-slider-input-label-text-transform);\n}\n.va-slider .va-input__label--inverse {\n  -webkit-user-select: var(--va-slider-input-label-inverse-user-select);\n     -moz-user-select: var(--va-slider-input-label-inverse-user-select);\n          user-select: var(--va-slider-input-label-inverse-user-select);\n  font-size: var(--va-slider-input-label-inverse-font-size);\n  letter-spacing: var(--va-slider-input-label-inverse-letter-spacing);\n  line-height: var(--va-slider-input-label-inverse-line-height);\n  font-weight: var(--va-slider-input-label-inverse-font-weight);\n  text-transform: var(--va-slider-input-label-inverse-text-transform);\n}\n.va-slider--grabbing .va-slider__container {\n  cursor: grabbing;\n}\n.va-slider--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-slider--disabled .va-slider__container {\n  cursor: default;\n}\n.va-slider--readonly .va-slider__container {\n  cursor: default;\n}\n.va-slider--horizontal .va-slider__input-wrapper {\n  flex-basis: fit-content;\n  flex-grow: 0;\n  margin-right: var(--va-slider-horizontal-input-wrapper-margin-right);\n}\n.va-slider--horizontal .va-slider__input-wrapper:last-of-type {\n  margin-left: 1rem;\n}\n.va-slider--horizontal .va-slider__container {\n  width: 100%;\n  height: 1.5rem;\n}\n.va-slider--horizontal .va-slider__track {\n  height: var(--va-slider-horizontal-track-height);\n  width: var(--va-slider-horizontal-track-width);\n}\n.va-slider--horizontal .va-slider__mark {\n  position: absolute;\n  width: 0.125rem;\n  height: 0.75rem;\n}\n.va-slider--horizontal .va-slider__handler {\n  transform: var(--va-slider-horizontal-handler-transform);\n}\n.va-slider--horizontal .va-slider__handler--inactive {\n  transition: left 0.5s ease-out;\n}\n.va-slider--horizontal .va-slider__handler__dot--value {\n  position: absolute;\n  top: var(--va-slider-horizontal-dot-value-top);\n  left: var(--va-slider-horizontal-dot-value-left);\n}\n.va-slider--horizontal .va-input__label {\n  margin-right: 1rem;\n}\n.va-slider--horizontal .va-input__label--inverse {\n  margin-left: 1rem;\n}\n.va-slider--vertical {\n  height: var(--va-slider-vertical-height);\n  padding: var(--va-slider-vertical-padding);\n  flex-direction: var(--va-slider-vertical-flex-direction);\n  align-items: var(--va-slider-vertical-align-items);\n}\n.va-slider--vertical .va-input__label {\n  margin-bottom: var(--va-slider-vertical-label-margin-bottom);\n}\n.va-slider--vertical .va-input__label--inverse {\n  left: var(--va-slider-vertical-label-inverse-left);\n  margin-top: var(--va-slider-vertical-label-inverse-margin-top);\n}\n.va-slider--vertical .va-slider__input-wrapper {\n  flex-basis: fit-content;\n  flex-grow: 0;\n  max-width: var(--va-slider-vertical-input-wrapper-max-width);\n  min-width: var(--va-slider-vertical-input-wrapper-min-width);\n  position: relative;\n  display: flex;\n}\n.va-slider--vertical .va-slider__input-wrapper:last-of-type {\n  margin-top: 1rem;\n}\n.va-slider--vertical .va-slider__container {\n  height: 100%;\n  width: 0.5rem;\n}\n.va-slider--vertical .va-slider__track {\n  height: var(--va-slider-vertical-track-height);\n  width: var(--va-slider-vertical-track-width);\n  bottom: var(--va-slider-vertical-track-bottom);\n}\n.va-slider--vertical .va-slider__mark {\n  position: absolute;\n  width: 0.75rem;\n  height: 0.125rem;\n  left: -2px;\n}\n.va-slider--vertical .va-slider__handler {\n  transform: var(--va-slider-vertical-handler-transform);\n}\n.va-slider--vertical .va-slider__handler--inactive {\n  transition: bottom 0.5s ease-out;\n}\n.va-slider--vertical .va-slider__handler__dot--value {\n  position: relative;\n  top: var(--va-slider-vertical-dot-value-top);\n  left: var(--va-slider-vertical-dot-value-left);\n}";
var _sfc_main85 = defineComponent({
  name: "VaSlider",
  components: { VaIcon: VaIcon2 },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  props: {
    ...useComponentPresetProp,
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true }
  },
  setup(props, { emit, slots }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset = ref(0);
    const size = ref(0);
    const currentValue = ref(Array.isArray(props.modelValue) ? [...props.modelValue] : props.modelValue);
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick_1(props, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [trackSizeStyle.value]: `${val2}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val2}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range && index !== void 0 ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => props.modelValue,
      set: (val2) => {
        if (!props.range) {
          val2 = limitValue(val2);
        }
        if (!flag.value) {
          emit("change", val2);
        }
        emit("update:modelValue", val2);
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props.max - props.min) / props.step;
      return size.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props.max - props.min) / props.step - 1);
    const position = computed(() => {
      return Array.isArray(props.modelValue) ? [(props.modelValue[0] - props.min) / props.step * gap.value, (props.modelValue[1] - props.min) / props.step * gap.value] : (props.modelValue - props.min) / props.step * gap.value;
    });
    const limit = computed(() => [0, size.value]);
    const valueLimit = computed(() => [props.min, props.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e, index = currentSliderDotIndex.value) => {
      var _a, _b;
      e.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e ? e.touches[0] : e;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(props.modelValue)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(props.modelValue) ? (_a = dots.value[index]) == null ? void 0 : _a.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e.preventDefault();
      if ("touches" in e) {
        setValueOnPos(getPos(e.touches[0]));
      } else {
        setValueOnPos(getPos(e));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", props.modelValue);
        } else {
          return false;
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const moveWithKeys = (event) => {
      var _a, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (isRange3, where, which) => {
        if (isRange3 && Array.isArray(val.value)) {
          if (!props.pins) {
            return val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = val.value[which] / onePinInterval | 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value[which] !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value.splice(which, 1, nearestPinVal);
          } else {
            val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
        } else {
          if (!props.pins && !Array.isArray(val.value)) {
            val.value += where ? props.step : -props.step;
            return;
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = !Array.isArray(val.value) ? val.value / onePinInterval | 0 : 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value = nearestPinVal;
          } else {
            val.value += where ? props.step : -props.step;
          }
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min):
            (_a = dots.value[0]) == null ? void 0 : _a.focus();
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min):
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max):
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min):
            moveDot(true, 0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max):
            moveDot(true, 1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(false, 1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(false, 1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props.step > val.value[0] && pin * props.step < val.value[1];
      } else {
        return pin * props.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e) => {
      getStaticData();
      return props.vertical ? offset.value - e.clientY : e.clientX - offset.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value) && Array.isArray(currentValue.value) && Array.isArray(props.modelValue)) {
        if (isDiff(currentValue.value[slider], newValue)) {
          currentValue.value.splice(slider, 1, newValue);
          if (slider === 0) {
            val.value = [currentValue.value.splice(slider, 1, newValue)[0], props.modelValue[1]];
            currentValue.value = [...val.value];
          } else {
            val.value = [props.modelValue[0], currentValue.value.splice(slider, 1, newValue)[0]];
            currentValue.value = [...val.value];
          }
        }
      } else {
        if (newValue < props.min || newValue > props.max) {
          return false;
        }
        if (isDiff(currentValue.value, newValue)) {
          currentValue.value = newValue;
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(props.modelValue) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value[1] = val.value[0];
            currentSliderDotIndex.value = 0;
          }
          const v = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v);
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value[0] = val.value[1];
            currentSliderDotIndex.value = 1;
          }
          const v = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v);
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const limitValue = (val2) => {
      const inRange = (v) => {
        if (v < props.min) {
          return props.min;
        } else if (v > props.max) {
          return props.max;
        }
        return v;
      };
      if (Array.isArray(val2)) {
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 0) {
          const v = inRange(val2[1]);
          return [v, v];
        }
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 1) {
          const v = inRange(val2[0]);
          return [v, v];
        }
        return val2.map((v) => inRange(v));
      } else {
        return inRange(val2);
      }
    };
    const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
    const clickOnContainer = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": props.min,
      "aria-valuemax": props.max,
      "aria-label": !slots.label && !props.label ? `current slider value is ${String(props.modelValue)}` : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      "aria-orientation": props.vertical ? "vertical" : "horizontal",
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(props.modelValue) ? props.modelValue : void 0,
      "aria-valuetext": Array.isArray(props.modelValue) ? String(props.modelValue) : void 0
    }));
    onMounted(() => {
      if (validateSlider(props.modelValue, props.step, props.min, props.max, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props.step,
      () => props.min,
      () => props.max,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value, step, min, max, range);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return {
      getColor,
      dot,
      dots,
      setItemRefByIndex,
      orders,
      sliderContainer,
      val,
      getValueByOrder,
      sliderClass,
      dotClass,
      labelStyles,
      processedStyles,
      getPinStyles,
      dottedStyles,
      getDottedStyles,
      clickOnContainer,
      hasMouseDown,
      trackStyles,
      pinsCol,
      checkActivePin,
      isFocused,
      isActiveDot,
      getTrackLabel,
      currentSliderDotIndex,
      ariaLabelIdComputed,
      ariaAttributesComputed
    };
  }
});
var _hoisted_152 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_228 = ["id"];
var _hoisted_315 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_411 = ["tabindex", "onFocus"];
var _hoisted_58 = ["tabindex"];
var _hoisted_66 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_74 = ["id"];
var _hoisted_83 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
function _sfc_render83(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_152, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "append" : "prepend")
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "va-input__label",
      id: _ctx.ariaLabelIdComputed,
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_228)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_315, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args)),
      onMouseup: _cache[4] || (_cache[4] = ($event) => _ctx.hasMouseDown = false),
      onTouchstart: _cache[5] || (_cache[5] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args))
    }, [
      createBaseVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4),
      _ctx.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i) => {
        return openBlock(), createElementBlock("div", {
          key: i,
          class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": _ctx.checkActivePin(pin) }]),
          style: normalizeStyle(_ctx.getPinStyles(pin))
        }, null, 6);
      }), 128)) : createCommentVNode("", true),
      _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", {
          ref: "process",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          "aria-hidden": "true",
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
          return openBlock(), createElementBlock("div", {
            key: "dot" + order,
            ref_for: true,
            ref: _ctx.setItemRefByIndex(order),
            class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
            style: normalizeStyle(_ctx.getDottedStyles(order)),
            tabindex: _ctx.disabled || _ctx.readonly ? void 0 : 0,
            onFocus: ($event) => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
            onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = false)
          }, [
            _ctx.isActiveDot(order) ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
              class: "va-slider__handler__dot--focus"
            }, null, 4)) : createCommentVNode("", true),
            _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle(_ctx.labelStyles),
              class: "va-slider__handler__dot--value"
            }, [
              renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1)
              ])
            ], 4)) : createCommentVNode("", true)
          ], 46, _hoisted_411);
        }), 128))
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createBaseVNode("div", {
          ref: "process",
          "aria-hidden": "true",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        createBaseVNode("div", {
          ref: "dot",
          class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
          style: normalizeStyle(_ctx.dottedStyles),
          tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = false)
        }, [
          _ctx.isActiveDot(0) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-slider__handler__dot--focus",
            style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
          }, null, 4)) : createCommentVNode("", true),
          _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-slider__handler__dot--value",
            style: normalizeStyle(_ctx.labelStyles)
          }, [
            renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
              createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1)
            ])
          ], 4)) : createCommentVNode("", true)
        ], 46, _hoisted_58)
      ], 64))
    ], 544),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_66, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && _ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 4,
      class: "va-input__label va-input__label--inverse",
      style: normalizeStyle(_ctx.labelStyles),
      id: _ctx.ariaLabelIdComputed
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_74)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_83, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "prepend" : "append")
    ])) : createCommentVNode("", true)
  ], 16);
}
var _VaSlider = _export_sfc(_sfc_main85, [["render", _sfc_render83], ["styles", [...VaIcon2.styles || [], _style_079]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/index.js
var VaSlider = withConfigTransport(_VaSlider);

// node_modules/vuestic-ui/dist/web-components/src/components/va-spacer/VaSpacer.js
var _style_080 = ":root,\n:host {\n  --va-spacer-flex-grow: 1 !important;\n}\n.va-spacer {\n  flex-grow: var(--va-spacer-flex-grow);\n}";
var _sfc_main86 = defineComponent({
  name: "VaSpacer"
});
var _hoisted_153 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
function _sfc_render84(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_153);
}
var VaSpacer = _export_sfc(_sfc_main86, [["render", _sfc_render84], ["styles", [_style_080]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/useSplitDragger.js
var useSplitDraggerProps = {
  vertical: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false }
};
var useSplitDragger = (containerSizeComputed, splitterPositionComputed, props) => {
  const isDragging = ref(false);
  const dragStartPosition = ref(0);
  const dragStartSplitterPosition = ref(0);
  const currentSplitterPosition = ref(0);
  const getEventPosition = (e, eventName) => {
    const event = e.type === eventName ? e : e.changedTouches[0];
    return props.vertical ? event.pageY : event.pageX;
  };
  const startDragging = (e) => {
    if (props.disabled || !containerSizeComputed.value) {
      return;
    }
    isDragging.value = true;
    dragStartPosition.value = getEventPosition(e, "mousedown");
    dragStartSplitterPosition.value = splitterPositionComputed.value;
  };
  const processDragging = (e) => {
    if (!isDragging.value) {
      return;
    }
    const currentPosition = getEventPosition(e, "mousemove");
    const distance = currentPosition - dragStartPosition.value;
    currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
  };
  const stopDragging = () => {
    isDragging.value = false;
  };
  useEvent(["mousemove", "touchmove"], processDragging);
  useEvent(["mouseup", "touchcancel"], stopDragging);
  return { isDragging, startDragging, currentSplitterPosition };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/VaSplit.js
var _style_081 = ":root,\n:host {\n  --va-split-panel-overflow: auto;\n  --va-split-dragger-display: flex;\n  --va-split-dragger-justify-content: center;\n  --va-split-dragger-align-items: center;\n  --va-split-dragger-overlay-size: 1rem;\n  --va-split-dragging-cursor: grabbing;\n  --va-split-horizontal-dragger-cursor: col-resize;\n  --va-split-vertical-dragger-cursor: row-resize;\n}\n.va-split {\n  position: relative;\n  display: flex;\n}\n.va-split__dragger {\n  position: relative;\n}\n.va-split__dragger__overlay {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: var(--va-split-dragger-display);\n  z-index: 1;\n}\n.va-split__panel {\n  overflow: var(--va-split-panel-overflow);\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n}\n.va-split__panel::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-split__panel::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-split__panel::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n}\n.va-split--dragging .va-split__panel {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  cursor: var(--va-split-dragging-cursor);\n}\n.va-split__dragger__default {\n  opacity: 0.7;\n}\n.va-split:focus .va-split__dragger__default, .va-split:hover .va-split__dragger__default {\n  opacity: 1;\n}\n.va-split--vertical {\n  flex-direction: column;\n}\n.va-split--vertical > .va-split__dragger {\n  height: 0;\n}\n.va-split--vertical > .va-split__dragger .va-split__dragger__overlay {\n  top: calc(var(--va-split-dragger-overlay-size) / -2);\n  height: var(--va-split-dragger-overlay-size);\n  align-items: var(--va-split-dragger-align-items);\n}\n.va-split--vertical > .va-split__dragger .va-split__dragger__default {\n  width: 100%;\n}\n.va-split--horizontal {\n  flex-direction: row;\n}\n.va-split--horizontal > .va-split__dragger {\n  width: 0;\n}\n.va-split--horizontal > .va-split__dragger .va-split__dragger__overlay {\n  left: calc(var(--va-split-dragger-overlay-size) / -2);\n  width: var(--va-split-dragger-overlay-size);\n  justify-content: var(--va-split-dragger-justify-content);\n}\n.va-split--horizontal > .va-split__dragger .va-split__dragger__default {\n  height: 100%;\n}";
var _sfc_main87 = defineComponent({
  name: "VaSplit",
  components: { VaDivider },
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v) => v <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 }
  },
  emits: useStatefulEmits,
  setup: (props, { emit }) => {
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a;
      const { width, height } = ((_a = splitPanelsContainer.value) == null ? void 0 : _a.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber_1(v)) {
        return v;
      }
      v.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v) => {
      if (v === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString_1(v) || isNumber_1(v)) {
        minPercents = convertToPercents(v, "min");
      }
      if (Array.isArray(v)) {
        minPercents = convertToPercents(v[0], "min");
        maxPercents = convertToPercents(v[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents != null ? minPercents : 0, max: maxPercents != null ? maxPercents : 100 };
    };
    const startPanelMinMax = computed(() => {
      var _a;
      return (_a = getPanelMinMax(props.limits[0])) != null ? _a : { min: 0, max: 100 };
    });
    const endPanelMinMax = computed(() => {
      var _a;
      return (_a = getPanelMinMax(props.limits[1])) != null ? _a : { min: 0, max: 100 };
    });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > props.snappingRange;
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp_1(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v) => {
      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v;
    }, { immediate: true });
    watch(currentSplitterPosition, (v) => {
      splitterPosition.value = v;
    });
    watch(isDragging, (v) => {
      if (!v) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    return {
      ...useTranslation(),
      splitPanelsContainer,
      containerSize,
      startDragging,
      getPanelStyle,
      maximizePanel,
      classComputed,
      draggerStyleComputed
    };
  }
});
var _hoisted_154 = ["aria-label"];
var _hoisted_229 = { class: "va-split__dragger" };
function _sfc_render85(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_divider = resolveComponent("va-divider");
  return openBlock(), createElementBlock("section", {
    ref: "splitPanelsContainer",
    class: normalizeClass(["va-split", _ctx.classComputed]),
    "aria-label": _ctx.t("splitPanels")
  }, [
    createBaseVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("start"))
    }, [
      renderSlot(_ctx.$slots, "start", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4),
    createBaseVNode("div", _hoisted_229, [
      createBaseVNode("div", {
        class: "va-split__dragger__overlay",
        style: normalizeStyle(_ctx.draggerStyleComputed),
        onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onTouchstart: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onDblclick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.maximizePanel && _ctx.maximizePanel(...args), ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "grabber", {}, () => [
          createVNode(_component_va_divider, {
            class: "va-split__dragger__default",
            vertical: !_ctx.$props.vertical
          }, null, 8, ["vertical"])
        ])
      ], 36)
    ]),
    createBaseVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("end"))
    }, [
      renderSlot(_ctx.$slots, "end", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4)
  ], 10, _hoisted_154);
}
var _VaSplit = _export_sfc(_sfc_main87, [["render", _sfc_render85], ["styles", [...VaDivider.styles || [], _style_081]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/index.js
var VaSplit = withConfigTransport(_VaSplit);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepperControls.js
var _style_082 = ":root {\n  --va-stepper-step-button-inactive-color: var(--va-secondary);\n  --va-stepper-step-button-hover-highlight-opacity: 0.1;\n  --va-stepper-step-button-disabled-opacity: 0.5;\n  --va-stepper-step-button-padding: 1rem;\n  --va-stepper-step-button-number-size: 1.2rem;\n  --va-stepper-step-button-icon-size: 2rem;\n  --va-stepper-step-button-gap: 0.5rem;\n  --va-stepper-step-button-icon-border-radius: 100%;\n  --va-stepper-step-border-radius: var(--va-square-border-radius);\n  --va-stepper-divider-color: var(--va-secondary);\n  --va-stepper-divider-length: auto;\n  --va-stepper-divider-min-length: 2rem;\n  --va-stepper-divider-thickness: 1px;\n  --va-stepper-divider-spacing: 0.5rem;\n  --va-stepper-divider-vertical-margin-left: 2rem;\n  --va-stepper-step-content-wrapper-padding: 0.5rem 1rem;\n  --va-stepper-step-content-margin: 0.8rem 0 2rem;\n  --va-stepper-controls-gap: 1rem;\n}\n.va-stepper__default-controls {\n  display: flex;\n  gap: var(--va-stepper-controls-gap);\n}";
var _sfc_main88 = defineComponent({
  name: "VaStepperControls",
  components: { VaButton: VaButton2 },
  props: {
    modelValue: { type: Number, required: true },
    steps: {
      type: Array,
      required: true
    },
    nextDisabled: { type: Boolean, required: true },
    stepControls: { type: Object, required: true },
    finishButtonHidden: { type: Boolean, default: false }
  },
  setup(props) {
    const { t } = useTranslation();
    const isLastStep = computed(() => {
      const lastEnabledStepIndex = props.steps.length - 1 - [...props.steps].reverse().findIndex((step) => !step.disabled);
      return props.modelValue >= lastEnabledStepIndex;
    });
    return {
      t,
      isLastStep
    };
  }
});
var _hoisted_155 = { class: "va-stepper__default-controls" };
function _sfc_render86(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock("div", _hoisted_155, [
    createVNode(_component_va_button, {
      preset: "primary",
      disabled: _ctx.$props.modelValue <= 0,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$props.stepControls.prevStep())
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.t("back")), 1)
      ]),
      _: 1
    }, 8, ["disabled"]),
    !_ctx.isLastStep ? (openBlock(), createBlock(_component_va_button, {
      key: 0,
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$props.stepControls.nextStep()),
      disabled: _ctx.$props.nextDisabled
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.t("next")), 1)
      ]),
      _: 1
    }, 8, ["disabled"])) : !_ctx.$props.finishButtonHidden ? (openBlock(), createBlock(_component_va_button, {
      key: 1,
      onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("finish"))
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.t("finish")), 1)
      ]),
      _: 1
    })) : createCommentVNode("", true)
  ]);
}
var VaStepperControls = _export_sfc(_sfc_main88, [["render", _sfc_render86], ["styles", [...VaButton2.styles || [], _style_082]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepperStepButton.js
var _style_083 = ':root {\n  --va-stepper-step-button-inactive-color: var(--va-secondary);\n  --va-stepper-step-button-hover-highlight-opacity: 0.1;\n  --va-stepper-step-button-disabled-opacity: 0.5;\n  --va-stepper-step-button-padding: 1rem;\n  --va-stepper-step-button-number-size: 1.2rem;\n  --va-stepper-step-button-icon-size: 2rem;\n  --va-stepper-step-button-gap: 0.5rem;\n  --va-stepper-step-button-icon-border-radius: 100%;\n  --va-stepper-step-border-radius: var(--va-square-border-radius);\n  --va-stepper-divider-color: var(--va-secondary);\n  --va-stepper-divider-length: auto;\n  --va-stepper-divider-min-length: 2rem;\n  --va-stepper-divider-thickness: 1px;\n  --va-stepper-divider-spacing: 0.5rem;\n  --va-stepper-divider-vertical-margin-left: 2rem;\n  --va-stepper-step-content-wrapper-padding: 0.5rem 1rem;\n  --va-stepper-step-content-margin: 0.8rem 0 2rem;\n  --va-stepper-controls-gap: 1rem;\n}\n.va-stepper__step-button {\n  position: relative;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  gap: var(--va-stepper-step-button-gap);\n  flex-shrink: 0;\n  padding: var(--va-stepper-step-button-padding);\n}\n.va-stepper__step-button::after {\n  content: "";\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--13fabefd);\n  transition: opacity 0.3s;\n  opacity: 0;\n  border-radius: var(--va-stepper-step-border-radius);\n}\n.va-stepper__step-button__icon {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: var(--va-stepper-step-button-icon-size);\n  width: var(--va-stepper-step-button-icon-size);\n  font-size: var(--va-stepper-step-button-number-size);\n  color: white;\n  background: var(--va-stepper-step-button-inactive-color);\n  border-radius: var(--va-stepper-step-button-icon-border-radius);\n}\n.va-stepper__step-button--active {\n  color: var(--13fabefd);\n}\n.va-stepper__step-button--active .va-stepper__step-button__icon {\n  background: var(--13fabefd);\n}\n.va-stepper__step-button--disabled {\n  opacity: var(--va-stepper-step-button-disabled-opacity);\n  pointer-events: none;\n}\n.va-stepper__step-button:hover::after {\n  opacity: var(--va-stepper-step-button-hover-highlight-opacity);\n}\n.va-stepper__step-button--navigation-disabled::after {\n  display: none;\n}';
var __default__11 = defineComponent({
  name: "VaStepperStepButton",
  components: { VaIcon: VaIcon2 },
  props: {
    modelValue: { type: Number, required: true },
    step: {
      type: Object,
      required: true
    },
    color: { type: String, required: true },
    stepIndex: { type: Number, required: true },
    navigationDisabled: { type: Boolean, required: true },
    nextDisabled: { type: Boolean, required: true },
    stepControls: { type: Object, required: true }
  },
  emits: ["update:modelValue"],
  setup(props) {
    const { getColor } = useColors();
    const stepperColor = getColor(props.color);
    const isNextStepDisabled = (index) => props.nextDisabled && index > props.modelValue;
    const computedClass = useBem("va-stepper__step-button", () => ({
      active: props.modelValue >= props.stepIndex,
      disabled: props.step.disabled || isNextStepDisabled(props.stepIndex),
      "navigation-disabled": props.navigationDisabled
    }));
    return {
      isNextStepDisabled,
      stepperColor,
      getColor,
      computedClass
    };
  }
});
var __injectCSSVars__11 = () => {
  useCssVars((_ctx) => ({
    "13fabefd": _ctx.stepperColor
  }));
};
var __setup__11 = __default__11.setup;
__default__11.setup = __setup__11 ? (props, ctx) => {
  __injectCSSVars__11();
  return __setup__11(props, ctx);
} : __injectCSSVars__11;
var _sfc_main89 = __default__11;
var _hoisted_156 = { class: "va-stepper__step-button__icon" };
function _sfc_render87(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["va-stepper__step-button", _ctx.computedClass]),
    onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex))
  }, [
    createBaseVNode("div", _hoisted_156, [
      _ctx.step.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 0,
        name: _ctx.step.icon,
        size: "1.3rem"
      }, null, 8, ["name"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.$props.stepIndex + 1), 1)
      ], 64))
    ]),
    createTextVNode(" " + toDisplayString(_ctx.step.label), 1)
  ], 2);
}
var VaStepperStepButton = _export_sfc(_sfc_main89, [["render", _sfc_render87], ["styles", [...VaIcon2.styles || [], _style_083]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepper.js
var _style_084 = ":root {\n  --va-stepper-step-button-inactive-color: var(--va-secondary);\n  --va-stepper-step-button-hover-highlight-opacity: 0.1;\n  --va-stepper-step-button-disabled-opacity: 0.5;\n  --va-stepper-step-button-padding: 1rem;\n  --va-stepper-step-button-number-size: 1.2rem;\n  --va-stepper-step-button-icon-size: 2rem;\n  --va-stepper-step-button-gap: 0.5rem;\n  --va-stepper-step-button-icon-border-radius: 100%;\n  --va-stepper-step-border-radius: var(--va-square-border-radius);\n  --va-stepper-divider-color: var(--va-secondary);\n  --va-stepper-divider-length: auto;\n  --va-stepper-divider-min-length: 2rem;\n  --va-stepper-divider-thickness: 1px;\n  --va-stepper-divider-spacing: 0.5rem;\n  --va-stepper-divider-vertical-margin-left: 2rem;\n  --va-stepper-step-content-wrapper-padding: 0.5rem 1rem;\n  --va-stepper-step-content-margin: 0.8rem 0 2rem;\n  --va-stepper-controls-gap: 1rem;\n}\n.va-stepper {\n  display: flex;\n  flex-direction: column;\n}\n.va-stepper--vertical {\n  flex-direction: row;\n}\n.va-stepper__navigation {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-wrap: wrap;\n}\n.va-stepper__navigation--vertical {\n  flex-direction: column;\n  align-items: flex-start;\n  flex-wrap: nowrap;\n}\n.va-stepper__divider {\n  flex-grow: 1;\n  height: var(--va-stepper-divider-thickness);\n  width: var(--va-stepper-divider-length);\n  min-width: var(--va-stepper-divider-min-length);\n  margin: 0 var(--va-stepper-divider-spacing);\n  background: var(--va-stepper-divider-color);\n}\n.va-stepper__divider--vertical {\n  min-height: var(--va-stepper-divider-min-length);\n  height: var(--va-stepper-divider-length);\n  width: var(--va-stepper-divider-thickness);\n  min-width: var(--va-stepper-divider-thickness);\n  margin: var(--va-stepper-divider-spacing) 0;\n  margin-left: var(--va-stepper-divider-vertical-margin-left);\n}\n.va-stepper__step-content-wrapper {\n  padding: var(--va-stepper-step-content-wrapper-padding);\n}\n.va-stepper__step-content {\n  margin: var(--va-stepper-step-content-margin);\n}\n.va-stepper__controls {\n  display: flex;\n  gap: var(--va-stepper-controls-gap);\n}";
var _sfc_main90 = defineComponent({
  name: "VaStepper",
  components: { VaStepperControls, VaStepperStepButton },
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    steps: {
      type: Array,
      default: () => [],
      required: true
    },
    color: { type: String, default: "primary" },
    vertical: { type: Boolean, default: false },
    navigationDisabled: { type: Boolean, default: false },
    controlsHidden: { type: Boolean, default: false },
    nextDisabled: { type: Boolean, default: false },
    finishButtonHidden: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "finish"],
  setup(props, { emit }) {
    const { valueComputed: modelValue } = useStateful(props, emit, "modelValue", { defaultValue: 0 });
    const { getColor } = useColors();
    const stepperColor = getColor(props.color);
    const isNextStepDisabled = (index) => props.nextDisabled && index > modelValue.value;
    const setStep = (index) => {
      if (props.steps[index].disabled) {
        return;
      }
      emit("update:modelValue", index);
    };
    const nextStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value + 1 + stepsToSkip;
      if (!props.steps[targetIndex]) {
        return;
      }
      if (props.steps[targetIndex].disabled) {
        nextStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const prevStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value - 1 - stepsToSkip;
      if (!props.steps[targetIndex]) {
        return;
      }
      if (props.steps[targetIndex].disabled) {
        prevStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const stepControls = { setStep, nextStep, prevStep };
    const getIterableSlotData = (step, index) => ({
      ...stepControls,
      step,
      isActive: props.modelValue === index,
      isCompleted: props.modelValue > index
    });
    return {
      isNextStepDisabled,
      stepperColor,
      getColor,
      stepControls,
      getIterableSlotData
    };
  }
});
var _hoisted_157 = {
  key: 0,
  class: "va-stepper__step-content"
};
var _hoisted_230 = { class: "va-stepper__controls" };
function _sfc_render88(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_stepper_step_button = resolveComponent("va-stepper-step-button");
  const _component_va_stepper_controls = resolveComponent("va-stepper-controls");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-stepper", { "va-stepper--vertical": _ctx.$props.vertical }])
  }, [
    createBaseVNode("ol", {
      class: normalizeClass(["va-stepper__navigation", { "va-stepper__navigation--vertical": _ctx.$props.vertical }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i) => {
        return openBlock(), createElementBlock(Fragment, { key: i }, [
          i > 0 ? renderSlot(_ctx.$slots, "divider", normalizeProps(mergeProps({ key: 0 }, _ctx.getIterableSlotData(step, i))), () => [
            createBaseVNode("span", {
              class: normalizeClass(["va-stepper__divider", { "va-stepper__divider--vertical": _ctx.$props.vertical }])
            }, null, 2)
          ]) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, `step-button-${i}`, normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(step, i))), () => [
            createVNode(_component_va_stepper_step_button, {
              stepIndex: i,
              color: _ctx.stepperColor,
              modelValue: _ctx.modelValue,
              nextDisabled: _ctx.nextDisabled,
              step,
              stepControls: _ctx.stepControls,
              navigationDisabled: _ctx.navigationDisabled
            }, null, 8, ["stepIndex", "color", "modelValue", "nextDisabled", "step", "stepControls", "navigationDisabled"])
          ])
        ], 64);
      }), 128))
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(["va-stepper__step-content-wrapper", { "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i) => {
        return openBlock(), createElementBlock(Fragment, { key: i }, [
          _ctx.$slots[`step-content-${i}`] && _ctx.modelValue === i ? (openBlock(), createElementBlock("div", _hoisted_157, [
            renderSlot(_ctx.$slots, `step-content-${i}`, normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(step, i))))
          ])) : createCommentVNode("", true)
        ], 64);
      }), 128)),
      createBaseVNode("div", _hoisted_230, [
        !_ctx.controlsHidden ? (openBlock(), createBlock(_component_va_stepper_controls, {
          key: 0,
          modelValue: _ctx.modelValue,
          nextDisabled: _ctx.nextDisabled,
          steps: _ctx.steps,
          stepControls: _ctx.stepControls,
          onFinish: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("finish"))
        }, null, 8, ["modelValue", "nextDisabled", "steps", "stepControls"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "controls", normalizeProps(guardReactiveProps(_ctx.stepControls)))
      ])
    ], 2)
  ], 2);
}
var _VaStepper = _export_sfc(_sfc_main90, [["render", _sfc_render88], ["styles", [...VaStepperControls.styles || [], ...VaStepperStepButton.styles || [], _style_084]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/index.js
var VaStepper = withConfigTransport(_VaStepper);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/types.js
var TabsViewKey = Symbol("TabsView");

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/VaTabs.js
var _style_085 = ':root,\n:host {\n  --va-tabs-display: flex;\n  --va-tabs-align-items-horizontal: center;\n  --va-tabs-align-items-vertical: stretch;\n  /* Container */\n  --va-tabs-container-height: 2rem;\n  --va-tabs-container-margin: 0 3px;\n  /* Slider */\n  --va-tabs-slider-width: 0.125rem;\n  --va-tabs-slider-height: 0.125rem;\n  --va-tabs-slider-transition: transform ease 0.3s;\n  /* Slider Wrapper */\n  --va-tabs-slider-wrapper-bottom: 0;\n  --va-tabs-slider-wrapper-margin: 0;\n  --va-tabs-slider-wrapper-z-index: 4000;\n  --va-tabs-slider-wrapper-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.va-tabs {\n  display: var(--va-tabs-display);\n  align-items: var(--va-tabs-align-items-horizontal);\n  position: relative;\n  font-family: var(--va-font-family);\n}\n.va-tabs__wrapper {\n  overflow: hidden;\n  contain: content;\n  display: flex;\n  flex: 1 1 auto;\n}\n.va-tabs .va-tabs__pagination {\n  flex: 0 0 auto;\n}\n.va-tabs .va-tabs__container {\n  overflow: hidden;\n  flex: 1 1 auto;\n  display: flex;\n  height: var(--va-tabs-container-height);\n  margin: var(--va-tabs-container-margin);\n  white-space: nowrap;\n  position: relative;\n}\n.va-tabs .va-tabs__container .va-tabs__tabs {\n  height: 100%;\n}\n.va-tabs .va-tabs__container .va-tabs__tabs-items {\n  display: flex;\n}\n.va-tabs .va-tabs__container--right {\n  justify-content: flex-end;\n}\n.va-tabs .va-tabs__container--grow .va-tabs__tabs {\n  display: flex;\n  min-width: 100%;\n}\n.va-tabs .va-tabs__container--grow .va-tabs__tabs-items {\n  width: 100%;\n}\n.va-tabs .va-tabs__container--grow .va-tab {\n  flex: 1 0 auto;\n  max-width: none;\n}\n.va-tabs .va-tabs__container--center {\n  justify-content: center;\n}\n.va-tabs .va-tabs__container--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}\n.va-tabs--vertical {\n  align-items: var(--va-tabs-align-items-vertical);\n}\n.va-tabs--vertical .va-tabs__wrapper {\n  flex: 0 0 auto;\n}\n.va-tabs--vertical .va-tabs__container {\n  height: auto;\n}\n.va-tabs--vertical .va-tabs__container .va-tabs__tabs-items {\n  flex-direction: column;\n}\n.va-tabs--vertical .va-tabs__container .va-tabs__tabs {\n  position: relative;\n}\n.va-tabs--vertical .va-tab {\n  display: flex;\n}\n.va-tabs--vertical .va-tab__content {\n  flex: 0 0 auto;\n}\n.va-tabs--vertical .va-tabs__content {\n  flex: 1 0 auto;\n}\n.va-tabs .va-tabs__slider-wrapper {\n  bottom: var(--va-tabs-slider-wrapper-bottom);\n  margin: var(--va-tabs-slider-wrapper-margin);\n  position: absolute;\n  z-index: var(--va-tabs-slider-wrapper-z-index);\n}\n.va-tabs .va-tabs__slider-wrapper .va-tabs__slider {\n  width: var(--va-tabs-slider-width);\n  height: var(--va-tabs-slider-height);\n}\n.va-tabs .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
var _sfc_main91 = defineComponent({
  name: "VaTabs",
  components: { VaButton: VaButton2, VaConfig },
  emits: ["update:modelValue", "click:next", "click:prev"],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" }
  },
  setup: (props, { emit }) => {
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
        position: props.hidePagination ? "unset" : "absolute"
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (showPagination.value && leftSidePosition + containerClientWidth <= tabsClientWidth) {
        tabsContentOffset.value = leftSidePosition;
      } else if (showPagination.value && rightSidePosition >= containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
      } else {
        tabsContentOffset.value = 0;
      }
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a;
        tab.updateSidePositions();
        const isTabSelected = (((_a = tab.name) == null ? void 0 : _a.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (tabsContentOffset.value + containerClientWidth > tabsClientWidth && tabsList.value.length) {
        moveToTab(tabsList.value[0]);
      }
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
    };
    const movePaginationLeft = () => {
      var _a, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const currentTabLeftSidePosition = unref((_a = tabsList.value[i]) == null ? void 0 : _a.leftSidePosition);
        const nextTabLeftSidePosition = unref((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
        if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
          offsetToSet = currentTabLeftSidePosition;
          break;
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const rightSidePosition2 = unref(tabsList.value[i].rightSidePosition);
        if (rightSidePosition2 > containerRightSide) {
          offsetToSet = unref(tabsList.value[i].leftSidePosition);
          if (tabsContentOffset.value < offsetToSet) {
            break;
          }
        }
      }
      const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a = container.value) == null ? void 0 : _a.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const redrawTabs = () => {
      const oldShowPaginationValue = showPagination.value;
      updatePagination();
      if (oldShowPaginationValue === showPagination.value) {
        updateTabsState();
        includeAnimation();
      } else {
        requestAnimationFrame(() => {
          updateTabsState();
          includeAnimation();
        });
      }
    };
    const selectTab = (tab) => {
      var _a;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a = tab.name) == null ? void 0 : _a.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a = tab.name) == null ? void 0 : _a.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a;
        tabListItem.id = ((_a = tabListItem.name) == null ? void 0 : _a.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper, tabs], redrawTabs);
    return {
      ...useTranslation(),
      wrapper,
      container,
      tabs,
      tabsList,
      sliderHeight,
      sliderWidth,
      sliderOffsetX,
      sliderOffsetY,
      showPagination,
      tabsContentOffset,
      startingXPoint,
      animationIncluded,
      colorComputed,
      tabConfig,
      computedClass,
      computedTabsClass,
      tabSelected,
      sliderStyles,
      paginationControlledStyles,
      disablePaginationLeft,
      disablePaginationRight,
      resetSliderSizes,
      moveToTab,
      updateStartingXPoint,
      updateTabsState,
      updatePagination,
      movePaginationLeft,
      movePaginationRight,
      updateSlider,
      includeAnimation,
      redrawTabs,
      selectTab
    };
  }
});
var _hoisted_158 = ["aria-disabled"];
var _hoisted_231 = createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_316 = [
  _hoisted_231
];
var _hoisted_412 = { class: "va-tabs__tabs-items" };
var _hoisted_59 = { class: "va-tabs__content" };
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createBaseVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      _ctx.showPagination && !_ctx.$props.hidePagination ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        class: "va-tabs__pagination",
        "aria-label": _ctx.t("movePaginationLeft"),
        size: "medium",
        disabled: _ctx.disablePaginationLeft,
        color: _ctx.color,
        preset: "secondary",
        icon: _ctx.$props.prevIcon,
        onClick: _ctx.movePaginationLeft
      }, null, 8, ["aria-label", "disabled", "color", "icon", "onClick"])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createBaseVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createBaseVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_316, 4),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_412, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3
          }, 8, ["components"])
        ], 4)
      ], 2),
      _ctx.showPagination && !_ctx.$props.hidePagination ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        class: "va-tabs__pagination",
        "aria-label": _ctx.t("movePaginationRight"),
        size: "medium",
        color: _ctx.color,
        disabled: _ctx.disablePaginationRight,
        preset: "secondary",
        icon: _ctx.$props.nextIcon,
        onClick: _ctx.movePaginationRight
      }, null, 8, ["aria-label", "color", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ], 8, _hoisted_158),
    createBaseVNode("div", _hoisted_59, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var _VaTabs = _export_sfc(_sfc_main91, [["render", _sfc_render89], ["styles", [...VaButton2.styles || [], ...VaConfig.styles || [], _style_085]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/index.js
var VaTabs = withConfigTransport(_VaTabs);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/hooks/time-text-parser.js
var parse = (text) => {
  const m = text.match(/[0-9]{1,2}/g);
  if (!m) {
    return [];
  }
  return m.map((s) => Number(s));
};
var parsePeriod = (text) => {
  const m = text.match(/pm|am/i);
  if (!m) {
    return null;
  }
  return Number(m[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d = new Date();
  const [h2, m, s] = parse(text);
  const period = parsePeriod(text);
  if (!h2) {
    return null;
  }
  const is12format = period !== null && h2 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h2 === 12 ? 0 : h2 : h2;
  d.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d.setMinutes(Math.min(m || 0, 60));
  d.setSeconds(Math.min(s || 0, 60));
  return d;
};
var useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction2;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/hooks/time-text-formatter.js
var useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/hooks/useTimePicker.js
var safeModelValue = (m) => m.value ? m.value : new Date(new Date().setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h2) => (h2 === 0 ? 12 : h2) - Number(h2 > 12) * 12;
var from12to24 = (h2, isAM = false) => (h2 === 12 ? 0 : h2) + Number(isAM) * 12;
var createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed(() => props.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i) => props.hoursFilter(props.ampm ? i + 12 * Number(isPM.value) : i));
    }
    return array.map((n) => {
      return props.ampm ? from24to12(n) : n;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i) => i === h22);
      }
      const h2 = modelValue.value.getHours();
      return items2.value.findIndex((i) => i === h2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m = modelValue.value.getMinutes();
      return items2.value.findIndex((i) => i === m);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s = modelValue.value.getSeconds();
      return items2.value.findIndex((i) => i === s);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h2 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h2 + 12 : h2;
        if (isPM.value && h2 <= 12) {
          h24 = h2 + 12;
        }
        if (!isPM.value && h2 >= 12) {
          h24 = h2 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props, modelValue) => {
  const { view } = toRefs(props);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumnCell.js
var _sfc_main92 = defineComponent({
  name: "VaTimePickerColumnCell",
  setup() {
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { getTextColor, getColor } = useColors();
    const styleComputed = computed(() => isHovered.value ? {
      color: getColor(getTextColor(getColor("background-secondary"))),
      background: getColor("background-secondary")
    } : void 0);
    return {
      onMouseEnter,
      onMouseLeave,
      styleComputed
    };
  }
});
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 36);
}
var VaTimePickerColumnCell = _export_sfc(_sfc_main92, [["render", _sfc_render90]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.js
var _style_086 = '.va-time-picker-column {\n  --va-time-picker-column-gap-height: 50px;\n  --va-time-picker-column-border-right: 1px solid var(--va-background-element);\n  --va-time-picker-cell-height: 30px;\n  --va-time-picker-cell-width: 40px;\n  --va-time-picker-cell-cursor: pointer;\n  --va-time-picker-cell-active-background: var(--va-primary);\n  --va-time-picker-cell-active-color: var(--va-primary);\n  --va-time-picker-cell-background-color-hover: transparent;\n  --va-time-picker-cell-active-background-opacity: 0.05;\n  --va-time-picker-cell-active-background-opacity-hover: 0.1;\n}\n.va-time-picker-column {\n  overflow-y: scroll;\n  -ms-overflow-style: none;\n  /* IE and Edge */\n  scrollbar-width: none;\n  /* Firefox */\n  height: 100%;\n  border-right: var(--va-time-picker-column-border-right);\n}\n.va-time-picker-column::-webkit-scrollbar {\n  /* WebKit */\n  display: none;\n}\n.va-time-picker-column::before, .va-time-picker-column::after {\n  content: "";\n  display: block;\n  height: var(--va-time-picker-column-gap-height);\n  width: 100%;\n}\n.va-time-picker-column:last-child {\n  border-right: 0;\n}\n.va-time-picker-column .va-time-picker-cell {\n  height: var(--va-time-picker-cell-height);\n  line-height: var(--va-time-picker-cell-height);\n  width: var(--va-time-picker-cell-width);\n  text-align: center;\n  cursor: var(--va-time-picker-cell-cursor);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-time-picker-column .va-time-picker-cell--active {\n  position: relative;\n  color: var(--va-time-picker-cell-active-color);\n  z-index: 0;\n}\n.va-time-picker-column .va-time-picker-cell--active::before {\n  background: var(--va-time-picker-cell-active-background);\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  right: 0;\n  content: "";\n  z-index: -1;\n  opacity: var(--va-time-picker-cell-active-background-opacity);\n}\n.va-time-picker-column .va-time-picker-cell:hover {\n  background: var(--va-time-picker-cell-background-color-hover);\n}\n.va-time-picker-column:focus-visible .va-time-picker-cell--active {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 4px;\n  outline-offset: -2px;\n}';
var _sfc_main93 = defineComponent({
  name: "VaTimePickerColumn",
  components: { VaTimePickerColumnCell },
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        var _a, _b;
        (_b = (_a = rootElement.value) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
          behavior: animated ? "smooth" : "auto",
          top: index * props.cellHeight
        });
      });
    };
    const makeActiveByIndex = (index) => {
      syncActiveItemIndex.value = index;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n) => {
      if (!Number.isInteger(n)) {
        return n;
      }
      return n < 10 ? `0${n}` : `${n}`;
    };
    const { background } = useElementBackground(rootElement);
    const { textColorComputed } = useTextColor(background);
    const styleComputed = computed(() => ({
      color: textColorComputed.value
    }));
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max(
        (scrollTop - scrollTop % props.cellHeight) / props.cellHeight,
        scrollTop / props.cellHeight
      );
      if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce_1(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    return {
      rootElement,
      makeActiveNext,
      makeActivePrev,
      makeActiveByIndex,
      onScroll,
      onCellClick,
      formatCell,
      styleComputed,
      focus,
      blur
    };
  }
});
var _hoisted_159 = ["onClick"];
function _sfc_render91(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumnCell = resolveComponent("VaTimePickerColumnCell");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    tabindex: "0",
    class: "va-time-picker-column",
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(), ["stop", "prevent"]), ["down"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(5), ["stop", "prevent"]), ["space"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.makeActivePrev(), ["stop", "prevent"]), ["up"]))
    ],
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
      return openBlock(), createBlock(_component_VaTimePickerColumnCell, {
        key: item,
        onScrollPassive: _ctx.onScroll,
        onTouchmovePassive: _ctx.onScroll,
        onMousewheelPassive: _ctx.onScroll
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
            onClick: ($event) => _ctx.onCellClick(index)
          }, [
            renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: _ctx.activeItemIndex, items: _ctx.items, formattedItem: _ctx.formatCell(item) })), () => [
              createTextVNode(toDisplayString(_ctx.formatCell(item)), 1)
            ])
          ], 10, _hoisted_159)
        ]),
        _: 2
      }, 1032, ["onScrollPassive", "onTouchmovePassive", "onMousewheelPassive"]);
    }), 128))
  ], 36);
}
var _VaTimePickerColumn = _export_sfc(_sfc_main93, [["render", _sfc_render91], ["styles", [...VaTimePickerColumnCell.styles || [], _style_086]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumn/index.js
var VaTimePickerColumn = withConfigTransport(_VaTimePickerColumn);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/VaTimePicker.js
var _style_087 = '.va-time-picker {\n  --va-time-picker-display: inline-flex;\n  --va-time-picker-disabled-opacity: 0.4;\n}\n.va-time-picker {\n  display: var(--va-time-picker-display);\n  justify-content: center;\n  overflow: hidden;\n  height: var(--va-time-picker-height);\n  font-family: var(--va-font-family);\n}\n.va-time-picker--readonly {\n  position: relative;\n}\n.va-time-picker--readonly::after {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 1;\n}\n.va-time-picker--disabled {\n  position: relative;\n  opacity: var(--va-time-picker-disabled-opacity);\n}\n.va-time-picker--disabled::after {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 1;\n}\n.va-time-picker--framed {\n  position: relative;\n}\n.va-time-picker--framed::before {\n  content: "";\n  height: var(--va-time-picker-cell-height);\n  width: 100%;\n  position: absolute;\n  top: 50%;\n  left: 0;\n  transform: translateY(-50%);\n  border-top: 1px solid var(--va-divider);\n  border-bottom: 1px solid var(--va-divider);\n  z-index: 0;\n}';
var _sfc_main94 = defineComponent({
  name: "VaTimePicker",
  components: { VaTimePickerColumn },
  props: {
    ...useStatefulProps,
    ...useFormProps,
    ...useComponentPresetProp,
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: Number, default: 30 },
    visibleCellsCount: { type: Number, default: 7 }
  },
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { columns, isPM } = useTimePicker(props, valueComputed);
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a;
      (_a = pickers.value[idx]) == null ? void 0 : _a.focus();
    };
    const blur = (idx) => {
      var _a;
      idx ? (_a = pickers.value[idx]) == null ? void 0 : _a.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useForm("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => ({
      ...computedFormClasses,
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
      return {
        height: `${props.cellHeight * props.visibleCellsCount}px`,
        "cell-height": `${props.cellHeight}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    return {
      columns,
      computedStyles,
      computedClasses,
      isPM,
      pickers,
      setItemRef,
      focusNext,
      focusPrev,
      activeColumnIndex,
      focus,
      blur
    };
  }
});
function _sfc_render92(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumn = resolveComponent("VaTimePickerColumn");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-time-picker", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyles)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column, idx) => {
      return openBlock(), createBlock(_component_VaTimePickerColumn, {
        key: idx,
        ref_for: true,
        ref: _ctx.setItemRef,
        items: column.items,
        tabindex: _ctx.disabled ? -1 : 0,
        "cell-height": _ctx.$props.cellHeight,
        activeItemIndex: column.activeItem.value,
        "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["stop", "prevent"]), ["right"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["stop", "prevent"]), ["left"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
        ],
        onFocus: ($event) => _ctx.activeColumnIndex = idx
      }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
    }), 128))
  ], 6);
}
var _VaTimePicker = _export_sfc(_sfc_main94, [["render", _sfc_render92], ["styles", [...VaTimePickerColumn.styles || [], _style_087]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/VaTimeInput.js
var _style_088 = ":root,\n:host {\n  --va-time-input-min-width: var(--va-form-element-min-width);\n}\n.va-time-input {\n  min-width: var(--va-time-input-min-width);\n}\n.va-time-input__anchor {\n  flex: 1;\n}";
var VaInputWrapperProps2 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue", "disabled"]);
var VaDropdownProps5 = extractComponentProps(
  VaDropdown,
  ["keyboardNavigation", "offset", "placement", "closeOnContentClick", "innerAnchorSelector", "modelValue"]
);
var _sfc_main95 = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    "update:modelValue",
    "update:isOpen"
  ],
  props: {
    ...VaDropdownProps5,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...VaInputWrapperProps2,
    ...extractComponentProps(_VaTimePicker),
    ...useValidationProps,
    isOpen: { type: Boolean, default: void 0 },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" }
  },
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
    const [modelValueSync] = useSyncProp("modelValue", props, emit);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(modelValueSync.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a;
      if (props.disabled) {
        return;
      }
      const val = (_a = e.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v = parse2(val);
      if (isValid.value && v) {
        modelValueSync.value = v;
      } else {
        modelValueSync.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const computedInputWrapperProps = computed(() => ({
      ...filterComponentProps(VaInputWrapperProps2).value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const { t } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      "aria-label": props.label || t("selectedTime"),
      "aria-required": props.requiredMark,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit_1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps5).value,
      closeOnContentClick: false,
      offset: [2, 0],
      keyboardNavigation: true,
      placement: "bottom-start",
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      t,
      input,
      timePicker,
      timePickerProps: filterComponentProps(extractComponentProps(_VaTimePicker)),
      dropdownPropsComputed,
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      modelValueSync,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      cursorStyleComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render93(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.doShowDropdown,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.doShowDropdown = $event),
    class: ["va-time-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({
        class: "va-time-input__anchor",
        style: _ctx.cursorStyleComputed
      }, _ctx.computedInputWrapperProps, {
        onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
      }), createSlots({
        default: withCtx(() => [
          createBaseVNode("input", mergeProps({
            ref: "input",
            class: "va-time-input__input"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.computedInputListeners), {
            onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
          }), null, 16)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({ key: 0 }, { ..._ctx.iconProps, ..._ctx.clearIconProps }, {
            "aria-label": _ctx.t("resetTime"),
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            "aria-label": _ctx.t("toggleDropdown"),
            onClick: withModifiers(_ctx.showDropdown, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
            ]
          }, _ctx.iconProps), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))
            ])
          };
        }),
        _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
          name: "prependInner",
          fn: withCtx((slotScope) => [
            renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.t("toggleDropdown")
            }, _ctx.iconProps, {
              onClick: withModifiers(_ctx.showDropdown, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
          ])
        } : void 0
      ]), 1040, ["style", "onClick"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.modelValueSync = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown", "onKeypress"])
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style"]);
}
var _VaTimeInput = _export_sfc(_sfc_main95, [["render", _sfc_render93], ["styles", [...VaDropdown.styles || [], ...VaDropdownContent.styles || [], ..._VaTimePicker.styles || [], ...VaIcon.styles || [], ...VaInputWrapper.styles || [], _style_088]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/index.js
var VaTimeInput = withConfigTransport(_VaTimeInput);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/index.js
var VaTimePicker = withConfigTransport(_VaTimePicker);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimeline.js
var _style_089 = ":root,\n:host {\n  --va-timeline-display: flex;\n  --va-timeline-flex-wrap: nowrap;\n  /* Vertical */\n  --va-timeline-vertical-flex-direction: column;\n  --va-timeline-vertical-padding-left: 0.25rem;\n  --va-timeline-vertical-padding-right: 0.25rem;\n}\n.va-timeline {\n  display: var(--va-timeline-display);\n  flex-wrap: var(--va-timeline-flex-wrap);\n  font-family: var(--va-font-family);\n}\n.va-timeline--vertical {\n  flex-direction: var(--va-timeline-vertical-flex-direction);\n  padding-left: var(--va-timeline-vertical-padding-left);\n  padding-right: var(--va-timeline-vertical-padding-right);\n}\n.va-timeline--align-top .va-timeline-item__before,\n.va-timeline--align-top .va-timeline-item__after {\n  flex: 0;\n}\n.va-timeline .va-timeline-item {\n  flex: 1;\n}\n.va-timeline .va-timeline-item--vertical .va-timeline-separator--vertical .va-timeline-separator__line:first-child {\n  flex: 0 0 1rem;\n}\n.va-timeline .va-timeline-item--vertical.va-timeline-item--is-first .va-timeline-separator--vertical .va-timeline-separator__line:first-child {\n  flex-basis: 2rem;\n}\n.va-timeline .va-timeline-item--vertical.va-timeline-item--is-first .va-timeline-item__after,\n.va-timeline .va-timeline-item--vertical.va-timeline-item--is-first .va-timeline-item__before {\n  padding-top: 2rem;\n}\n.va-timeline .va-timeline-item--vertical.va-timeline-item--vertical.va-timeline-item--is-last .va-timeline-item__after,\n.va-timeline .va-timeline-item--vertical.va-timeline-item--vertical.va-timeline-item--is-last .va-timeline-item__before {\n  padding-bottom: 2rem;\n}";
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a;
  return !!((_a = slot == null ? void 0 : slot.props) == null ? void 0 : _a.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a;
  const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME = "va-timeline";
var _sfc_main96 = {
  name: COMPONENT_NAME,
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props, { slots }) {
    return () => h(
      "div",
      {
        class: {
          [COMPONENT_NAME]: true,
          [`${COMPONENT_NAME}--vertical`]: props.vertical,
          [`${COMPONENT_NAME}--align-top`]: props.alignTop
        }
      },
      processSlots({ props, slots })
    );
  }
};
var _VaTimeline = _export_sfc(_sfc_main96, [["styles", [_style_089]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/index.js
var VaTimeline = withConfigTransport(_VaTimeline);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/hooks/useTreeHelpers.js
var useTreeViewProps = {
  nodes: {
    type: Array,
    default: []
  },
  stateful: {
    type: Boolean,
    default: true
  },
  selectable: {
    type: Boolean,
    default: false
  },
  selectionType: {
    type: String,
    default: "leaf",
    validator: (v) => ["leaf", "independent"].includes(v)
  },
  valueBy: {
    type: [String, Function],
    default: "id"
  },
  textBy: {
    type: [String, Function],
    default: "label"
  },
  trackBy: {
    type: [String, Function],
    default: "id"
  },
  iconBy: {
    type: [String, Function],
    default: "icon"
  },
  disabledBy: {
    type: [String, Function],
    default: "disabled"
  },
  expandedBy: {
    type: [String, Function],
    default: "expanded"
  },
  checkedBy: {
    type: [String, Function],
    default: "checked"
  },
  expandAll: {
    type: Boolean,
    default: false
  },
  expanded: {
    type: Array,
    default: []
  },
  expandNodeBy: {
    type: String,
    default: "leaf"
  },
  filter: {
    type: String,
    default: ""
  },
  filterMethod: {
    type: Function,
    default: void 0
  },
  checked: {
    type: Array,
    default: []
  },
  color: {
    type: String,
    default: "primary"
  }
};
var useTreeViewEmits = ["update:modelValue", "update:checked", "update:expanded", "update:selected"];
var useTreeHelpers = (props) => {
  const isStringOrNumber = (node) => {
    const typeOfNode = typeof node;
    return typeOfNode === "string" || typeOfNode === "number";
  };
  const getNodeProperty = (node, key) => !key || isStringOrNumber(node) ? node : getValueByKey(node, key);
  const getValue2 = (node) => getNodeProperty(node, props.valueBy);
  const getNodeByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.nodes.find((node) => value === getValue2(node)) || value;
  };
  const getText = (node) => getNodeProperty(node, props.textBy);
  const getChecked = (node) => getNodeProperty(node, props.checkedBy);
  const getDisabled = (node) => getNodeProperty(node, props.disabledBy);
  const getExpanded = (node) => getNodeProperty(node, props.expandedBy);
  const getTrackBy = (node) => getNodeProperty(node, props.trackBy);
  const iterateNodes = (nodes, cb) => {
    nodes.forEach((node) => {
      const children = node.children || [];
      if (children.length) {
        iterateNodes(children, cb);
      }
      cb(node);
    });
  };
  return {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeByValue,
    getNodeProperty
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/types.js
var TreeViewKey = Symbol("TreeView");

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/hooks/useTreeKeyboardNavigation.js
var useTreeKeyboardNavigation = (props, methods) => {
  const { emit, toggleNode, toggleCheckbox } = methods;
  const isElementExpanded = (currentElement) => (currentElement == null ? void 0 : currentElement.getAttribute("aria-expanded")) === "true";
  const getParentElement = (currentElement) => {
    var _a;
    return ((_a = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a.closest(".va-tree-node")) || null;
  };
  const getPreviousElement = (currentElement) => currentElement == null ? void 0 : currentElement.previousElementSibling;
  const findPreviousElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let previousElement = getPreviousElement(currentElement);
    let lastChildElement = isElementExpanded(previousElement) && getLastChildElement(previousElement);
    if (lastChildElement) {
      do {
        if (isElementExpanded(lastChildElement)) {
          lastChildElement = getLastChildElement(lastChildElement);
          if (lastChildElement) {
            continue;
          } else {
            break;
          }
        } else {
          previousElement = lastChildElement;
          break;
        }
      } while (true);
    }
    if (!previousElement) {
      return getParentElement(currentElement);
    }
    return previousElement;
  };
  const getNextElement = (currentElement) => currentElement == null ? void 0 : currentElement.nextElementSibling;
  const findNextElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let nextElement = getNextElement(currentElement);
    const isCurrentExpanded = isElementExpanded(currentElement);
    if (!nextElement) {
      let parentElement = getParentElement(currentElement);
      do {
        if (!getNextElement(parentElement)) {
          parentElement = getParentElement(parentElement);
          if (!parentElement) {
            break;
          } else {
            continue;
          }
        } else {
          nextElement = getNextElement(parentElement);
          break;
        }
      } while (true);
    }
    if (isCurrentExpanded) {
      return getFirstChildElement(currentElement);
    }
    return nextElement;
  };
  const getFirstChildElement = (currentElement) => {
    var _a;
    return ((_a = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a.firstElementChild) || null;
  };
  const getLastChildElement = (currentElement) => {
    var _a;
    return ((_a = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a.lastElementChild) || null;
  };
  const onHorizontalMove = (currentElement, dir, node) => {
    var _a, _b;
    const isCurrentElementExpanded = isElementExpanded(currentElement);
    if (dir === "left") {
      if (isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_a = getParentElement(currentElement)) == null ? void 0 : _a.focus();
      }
    } else {
      if (!isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_b = getFirstChildElement(currentElement)) == null ? void 0 : _b.focus();
      }
    }
  };
  const onVerticalMove = (currentElement, dir) => {
    var _a, _b;
    if (dir === "up") {
      (_a = findPreviousElement(currentElement)) == null ? void 0 : _a.focus();
    } else {
      (_b = findNextElement(currentElement)) == null ? void 0 : _b.focus();
    }
  };
  const handleKeyboardNavigation = (event, node) => {
    const currentElement = event.target;
    switch (event.code) {
      case "ArrowUp":
        onVerticalMove(currentElement, "up");
        break;
      case "ArrowRight":
        onHorizontalMove(currentElement, "right", node);
        break;
      case "ArrowDown":
        onVerticalMove(currentElement, "down");
        break;
      case "ArrowLeft":
        onHorizontalMove(currentElement, "left", node);
        break;
      case "Space":
        if (props.selectable) {
          const state = typeof node.checked !== "undefined" ? !node.checked : null;
          toggleCheckbox(node, state);
        } else {
          emit("update:selected", node);
        }
        break;
      case "Escape":
        if (!props.selectable) {
          emit("update:selected", null);
        }
        currentElement.blur();
        break;
      default:
        currentElement.blur();
    }
  };
  return { handleKeyboardNavigation };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/hooks/useTreeView.js
var useTreeView = (props, emit) => {
  const { getColor } = useColors();
  const colorComputed = computed(() => getColor(props.color));
  const isLeafSelectionComputed = computed(() => props.selectionType === "leaf");
  const {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeProperty
  } = useTreeHelpers(props);
  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs(props);
  const { valueComputed: expandedList } = useStateful(props, emit, "expanded");
  const { valueComputed: checkedList } = useStateful(props, emit, "checked");
  const selectedNode = ref();
  const selectedNodeComputed = computed({
    get: () => selectedNode.value,
    set: (node) => {
      const value = getValue2(node);
      if (selectedNode.value !== value) {
        selectedNode.value = value;
        emit("update:selected", node);
      }
    }
  });
  const updateModel = (model, values, state) => {
    if (state) {
      model.value = model.value.concat(values).filter((value, idx, self2) => self2.indexOf(value) === idx);
    } else {
      model.value = model.value.filter((v) => !values.includes(v));
    }
  };
  const toggleCheckbox = (node, state) => {
    let stateValue = state === null ? true : state;
    if (state && node.indeterminate) {
      stateValue = false;
    }
    const values = [getValue2(node)];
    if (isLeafSelectionComputed.value && node.hasChildren) {
      const toggleChildren = (nodes2) => {
        nodes2.forEach((node2) => {
          var _a;
          if (node2.disabled) {
            return;
          }
          if ((_a = node2.children) == null ? void 0 : _a.length) {
            toggleChildren(node2.children);
          }
          values.push(getValue2(node2));
        });
      };
      toggleChildren(node.children);
    }
    updateModel(checkedList, values, stateValue);
  };
  const toggleNode = (node) => {
    if (node.hasChildren) {
      updateModel(expandedList, [getValue2(node)], !node.expanded);
    }
  };
  const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 }) => {
    var _a;
    const valueBy = getValue2(node);
    let matchesFilter = true;
    const hasChildren = !!children.length;
    const disabled = getDisabled(node) || false;
    let indeterminate = false;
    let checked = checkedList.value.includes(valueBy) || false;
    if (isLeafSelectionComputed.value && hasChildren) {
      const isAllChildrenChecked = children.every((c) => c.checked);
      checked = isAllChildrenChecked;
      indeterminate = !isAllChildrenChecked && children.some((c) => c.indeterminate || c.checked);
      if (indeterminate) {
        checked = null;
      }
    }
    if (filter.value) {
      matchesFilter = (children == null ? void 0 : children.some((c) => c.matchesFilter)) || ((_a = computedFilterMethod2.value) == null ? void 0 : _a.call(computedFilterMethod2, node, filter.value, textBy.value));
    }
    return {
      ...node,
      level,
      checked,
      children,
      disabled,
      expanded: expandedList.value.includes(valueBy) || false,
      hasChildren,
      matchesFilter,
      indeterminate
    };
  };
  const computedFilterMethod = computed(() => {
    if (filterMethod == null ? void 0 : filterMethod.value) {
      return filterMethod.value;
    }
    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());
  });
  const buildTree = (nodes2, level = 0) => nodes2.map((node) => {
    var _a;
    if ((_a = node.children) == null ? void 0 : _a.length) {
      const children = buildTree(node.children, level + 1);
      return createNode({ node, level, children, computedFilterMethod });
    }
    return createNode({ node, level, computedFilterMethod, children: [] });
  });
  const getFilteredNodes = (nodes2) => nodes2.slice().filter((node) => {
    if (node.hasChildren) {
      getFilteredNodes(node.children.slice());
    }
    return node.matchesFilter ? node : false;
  });
  const { handleKeyboardNavigation } = useTreeKeyboardNavigation(props, { emit, toggleCheckbox, toggleNode });
  provide(TreeViewKey, {
    selectedNodeComputed,
    colorComputed,
    iconBy: props.iconBy,
    selectable: props.selectable,
    expandNodeBy: props.expandNodeBy,
    getText,
    getValue: getValue2,
    getTrackBy,
    toggleNode,
    toggleCheckbox,
    getNodeProperty,
    handleKeyboardNavigation
  });
  const treeItems = computed(() => buildTree(nodes.value));
  const checkForInitialValues = () => {
    const expandedValues = [];
    const checkedValues = [];
    iterateNodes(nodes.value, (node) => {
      if (expandAll.value) {
        expandedValues.push(getValue2(node));
      } else {
        getExpanded(node) && expandedValues.push(getValue2(node));
      }
      if (getChecked(node)) {
        checkedValues.push(getValue2(node));
      }
    });
    if (expandedValues.length) {
      updateModel(expandedList, expandedValues, true);
    }
    if (checkedValues.length) {
      updateModel(checkedList, checkedValues, true);
    }
  };
  checkForInitialValues();
  return {
    treeItems: computed(() => getFilteredNodes(treeItems.value)),
    getText,
    getTrackBy,
    toggleCheckbox
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useStrictInject.js
var useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-scroll-container/VaScrollContainer.js
var _style_090 = ":root {\n  --va-scroll-container-scrollbar-gradient-to: var(--va-background-primary);\n}\n.va-scroll-container {\n  scrollbar-color: var(--f55ca9ca) transparent;\n  scrollbar-width: thin;\n  overflow-x: var(--62c5c45b);\n  overflow-y: var(--62c5c45c);\n  width: 100%;\n  height: 100%;\n  direction: var(--c20c3f98);\n}\n.va-scroll-container::-webkit-scrollbar {\n  width: var(--704f36e8);\n  height: var(--704f36e8);\n}\n.va-scroll-container::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-scroll-container::-webkit-scrollbar-thumb {\n  background: var(--f55ca9ca);\n  opacity: 0.3;\n  border-radius: 2px;\n}\n.va-scroll-container__content {\n  height: -webkit-fill-available;\n  height: -moz-available;\n  height: stretch;\n  width: -webkit-fill-available;\n  width: -moz-available;\n  width: stretch;\n  direction: ltr;\n}";
var __default__12 = defineComponent({
  name: "VaScrollContainer",
  props: {
    ...useSizeProps,
    vertical: { type: Boolean, default: false },
    horizontal: { type: Boolean, default: false },
    color: { type: String, default: "secondary" },
    rtl: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: 4,
        sizes: { small: 4, medium: 6, large: 8 }
      })
    },
    size: {
      type: String,
      default: "small",
      validator: (v) => ["small", "medium", "large"].includes(v)
    }
  },
  setup(props) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    return {
      overflowX: computed(() => props.horizontal ? "auto" : "hidden"),
      overflowY: computed(() => props.vertical ? "auto" : "hidden"),
      scrollColor: computed(() => {
        const color = getColor(props.color);
        return props.gradient ? `linear-gradient(0deg, var(--va-scroll-container-scrollbar-gradient-to) 0%, ${color} 100%)` : color;
      }),
      scrollbarSize: computed(() => sizeComputed.value),
      scrollbarPosition: computed(() => props.rtl ? "rtl" : "ltr")
    };
  }
});
var __injectCSSVars__12 = () => {
  useCssVars((_ctx) => ({
    "f55ca9ca": _ctx.scrollColor,
    "704f36e8": _ctx.scrollbarSize,
    "62c5c45b": _ctx.overflowX,
    "62c5c45c": _ctx.overflowY,
    "c20c3f98": _ctx.scrollbarPosition
  }));
};
var __setup__12 = __default__12.setup;
__default__12.setup = __setup__12 ? (props, ctx) => {
  __injectCSSVars__12();
  return __setup__12(props, ctx);
} : __injectCSSVars__12;
var _sfc_main97 = __default__12;
var _hoisted_160 = { class: "va-scroll-container" };
var _hoisted_232 = { class: "va-scroll-container__content" };
function _sfc_render94(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_160, [
    createBaseVNode("div", _hoisted_232, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
var _VaScrollContainer = _export_sfc(_sfc_main97, [["render", _sfc_render94], ["styles", [_style_090]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-scroll-container/index.js
var VaScrollContainer = withConfigTransport(_VaScrollContainer);

// node_modules/vuestic-ui/dist/web-components/src/components/va-viewer/VaViewer.js
var _style_091 = ":root {\n  --va-viewer-content-overlay-background-color: rgba(0, 0, 0, 0.45);\n  --va-viewer-content-overlay-z-index: var(--va-z-index-teleport-overlay);\n  --va-viewer-content-controls-panel-padding: 0.75rem;\n  --va-viewer-content-controls-panel-justify-content: flex-end;\n  --va-viewer-content-controls-panel-background-color: rgba(0, 0, 0, 0.1);\n  --va-viewer-content-controls-panel-z-index: calc(var(--va-z-index-teleport-overlay) + 50);\n}\n.va-viewer {\n  --va-image-position: relative;\n}\n.va-viewer-content {\n  position: fixed;\n  inset: 0;\n  z-index: var(--va-viewer-content-overlay-z-index);\n  display: flex;\n  justify-content: center;\n  background-color: var(--va-viewer-content-overlay-background-color);\n}\n.va-viewer-content__main-area {\n  --va-image-position: relative;\n  display: flex;\n}\n.va-viewer-content__main-area > * {\n  width: auto;\n  max-width: unset;\n}\n.va-viewer-content__controls-panel {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  z-index: var(--va-viewer-content-controls-panel-z-index);\n  display: flex;\n  justify-content: var(--va-viewer-content-controls-panel-justify-content);\n  padding: var(--va-viewer-content-controls-panel-padding);\n  background-color: var(--va-viewer-content-controls-panel-background-color);\n}";
var _sfc_main98 = defineComponent({
  name: "VaViewer",
  inheritAttrs: false,
  components: { VaIcon: VaIcon2 },
  setup(_, { slots }) {
    const content = ref();
    const controls = ref();
    const isMounted = useIsMounted();
    const isClosed = ref(true);
    const isOpened = computed(() => isMounted.value && !isClosed.value);
    const openViewer = () => isClosed.value = false;
    const closeViewer = () => isClosed.value = true;
    const handleAnchorClick = () => {
      if (!slots.anchor) {
        openViewer();
      }
    };
    useClickOutside([content, controls], closeViewer);
    const document2 = useDocument();
    const teleportTarget = computed(() => {
      var _a;
      return (_a = document2.value) == null ? void 0 : _a.body;
    });
    return {
      content,
      controls,
      teleportTarget,
      isOpened,
      openViewer,
      closeViewer,
      handleAnchorClick
    };
  }
});
var _hoisted_161 = { class: "va-viewer-content" };
var _hoisted_233 = {
  ref: "content",
  class: "va-viewer-content__main-area"
};
var _hoisted_317 = {
  ref: "controls",
  class: "va-viewer-content__controls-panel"
};
function _sfc_render95(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", mergeProps({ class: "va-viewer" }, _ctx.$attrs, {
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleAnchorClick && _ctx.handleAnchorClick(...args))
    }), [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ openViewer: _ctx.openViewer }))),
      !_ctx.$slots.anchor ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
    ], 16),
    _ctx.isOpened ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.teleportTarget
    }, [
      createBaseVNode("div", _hoisted_161, [
        createBaseVNode("div", _hoisted_233, [
          !_ctx.$slots.image ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "image")
        ], 512),
        createBaseVNode("div", _hoisted_317, [
          renderSlot(_ctx.$slots, "controls"),
          renderSlot(_ctx.$slots, "close", normalizeProps(guardReactiveProps({ close: _ctx.closeViewer })), () => [
            createBaseVNode("button", {
              class: "va-viewer-content__close-button",
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.closeViewer && _ctx.closeViewer(...args))
            }, [
              createVNode(_component_va_icon, {
                name: "close",
                color: "backgroundPrimary"
              })
            ])
          ])
        ], 512)
      ])
    ], 8, ["to"])) : createCommentVNode("", true)
  ], 64);
}
var _VaViewer = _export_sfc(_sfc_main98, [["render", _sfc_render95], ["styles", [...VaIcon2.styles || [], _style_091]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-viewer/index.js
var VaViewer = withConfigTransport(_VaViewer);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/types.js
var VaFileUploadKey = Symbol("VaFileUpload");

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.js
var _style_092 = ":root,\n:host {\n  --va-file-upload-undo-button-line-height: 1.1428;\n  --va-file-upload-undo-button-margin-top: 0;\n  --va-file-upload-undo-button-margin-bottom: 0;\n  --va-file-upload-undo-margin-left: 0.5rem;\n}\n.va-file-upload-undo-progress-bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  --va-progress-bar-transition: width var(--38c05944) linear;\n}\n.va-file-upload-undo {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  flex-wrap: wrap;\n}\n.va-file-upload-undo__button {\n  line-height: var(--va-file-upload-undo-button-line-height);\n  margin-left: var(--va-file-upload-undo-margin-left);\n  margin-top: var(--va-file-upload-undo-button-margin-top);\n  margin-bottom: var(--va-file-upload-undo-button-margin-bottom);\n}\n.va-file-upload-undo--vertical {\n  justify-content: center;\n  align-items: center;\n  align-content: center;\n  padding: var(--va-file-upload-undo-padding);\n}\n.va-file-upload-undo--vertical .va-file-upload-undo__text {\n  margin: 1rem 0 0;\n  text-align: center;\n}\n.va-file-upload-undo--vertical .va-file-upload-undo__button {\n  margin: 1rem 0 0;\n}";
var INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
var __default__13 = defineComponent({
  name: "VaFileUploadUndo",
  components: {
    VaProgressBar,
    VaButton: VaButton2
  },
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup: (props) => {
    const progress = ref(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props.vertical
    }));
    const undoDurationStyle = computed(() => {
      var _a;
      return `${(_a = undoDuration.value) != null ? _a : 0}ms`;
    });
    onMounted(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return {
      progress,
      undoDuration,
      undoButtonText,
      computedClasses,
      undoDurationStyle,
      deletedFileMessage
    };
  }
});
var __injectCSSVars__13 = () => {
  useCssVars((_ctx) => ({
    "38c05944": _ctx.undoDurationStyle
  }));
};
var __setup__13 = __default__13.setup;
__default__13.setup = __setup__13 ? (props, ctx) => {
  __injectCSSVars__13();
  return __setup__13(props, ctx);
} : __injectCSSVars__13;
var _sfc_main99 = __default__13;
var _hoisted_162 = { class: "va-file-upload-undo__text" };
function _sfc_render96(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_bar = resolveComponent("va-progress-bar");
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_va_progress_bar, {
      "model-value": _ctx.progress,
      rounded: false,
      class: "va-file-upload-undo-progress-bar"
    }, null, 8, ["model-value"]),
    createBaseVNode("div", {
      class: normalizeClass(["va-file-upload-undo", _ctx.computedClasses])
    }, [
      createBaseVNode("span", _hoisted_162, toDisplayString(_ctx.deletedFileMessage), 1),
      createVNode(_component_va_button, {
        class: "va-file-upload-undo__button",
        "aria-label": _ctx.undoButtonText,
        size: "small",
        outline: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.undoButtonText), 1)
        ]),
        _: 1
      }, 8, ["aria-label"])
    ], 2)
  ], 64);
}
var _VaFileUploadUndo = _export_sfc(_sfc_main99, [["render", _sfc_render96], ["styles", [...VaProgressBar.styles || [], ...VaButton2.styles || [], _style_092]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadUndo/index.js
var VaFileUploadUndo = withConfigTransport(_VaFileUploadUndo);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
var _style_093 = ":root,\n:host {\n  --va-file-upload-list-item-size-text-color: var(--va-secondary);\n  --va-file-upload-list-item-border-radius: 0.375rem;\n  --va-file-upload-list-item-background-color: var(--va-white);\n  --va-file-upload-list-item-box-shadow: var(--va-box-shadow);\n}\n.va-file-upload-list-item {\n  background-color: var(--va-file-upload-list-item-background-color);\n  box-shadow: var(--va-file-upload-list-item-box-shadow, var(--va-block-box-shadow));\n  border-radius: var(--va-file-upload-list-item-border-radius, var(--va-block-border-radius));\n  position: relative;\n  line-height: 1.5rem;\n  padding: 1.125rem 0.5rem 1rem 1rem;\n  max-width: 100%;\n  width: 100%;\n}\n.va-file-upload-list-item + .va-file-upload-list-item {\n  margin-top: 0.5rem;\n}\n.va-file-upload-list-item .va-list-item__inner {\n  padding: 0;\n  overflow: hidden;\n}\n.va-file-upload-list-item__content {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.va-file-upload-list-item__name {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex-basis: 60%;\n  overflow: hidden;\n}\n.va-file-upload-list-item__size {\n  color: var(--va-file-upload-list-item-size-text-color);\n}\n.va-file-upload-list-item__delete {\n  font-size: 1.5rem;\n  cursor: pointer;\n  --va-button-size: 1.5rem;\n}\n.va-file-upload-list-item--undo {\n  overflow: hidden;\n  position: relative;\n}\n.va-file-upload-list-item--undo .va-list-item-section {\n  padding: 0;\n}";
var INJECTION_ERROR_MESSAGE2 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
var _sfc_main100 = defineComponent({
  name: "VaFileUploadListItem",
  components: {
    VaListItem,
    VaListItemSection,
    VaFileUploadUndo,
    VaButton: VaButton2
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE2);
    const { onFocus, onBlur } = useFocus();
    const removed = ref(false);
    const removeFile = () => {
      var _a;
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, (_a = undoDuration.value) != null ? _a : 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return {
      ...useTranslation(),
      undo,
      removed,
      disabled,
      computedClasses,
      onBlur,
      onFocus,
      removeFile,
      recoverFile
    };
  }
});
var _hoisted_163 = { class: "va-file-upload-list-item__content" };
var _hoisted_234 = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
var _hoisted_318 = { class: "va-file-upload-list-item__size" };
function _sfc_render97(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-list-item", _ctx.computedClasses]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, { onRecover: _ctx.recoverFile }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_163, [
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", _hoisted_234, toDisplayString(_ctx.file && _ctx.file.name), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_318, toDisplayString(_ctx.file && _ctx.file.size), 1),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "clear",
              class: "va-file-upload-list-item__delete",
              "aria-label": _ctx.t("removeFile"),
              onClick: withModifiers(_ctx.removeFile, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["space"])
              ],
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["aria-label", "onClick", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled"]);
}
var _VaFileUploadListItem = _export_sfc(_sfc_main100, [["render", _sfc_render97], ["styles", [...VaListItem.styles || [], ...VaListItemSection.styles || [], ...VaFileUploadUndo.styles || [], ...VaButton2.styles || [], _style_093]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadListItem/index.js
var VaFileUploadListItem = withConfigTransport(_VaFileUploadListItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.js
var _style_094 = ":root,\n:host {\n  --va-file-upload-gallery-item-card-box-shadow: var(--va-box-shadow);\n  --va-file-upload-gallery-item-text: var(--va-text-primary);\n  --va-file-upload-gallery-item-text-hover: var(--va-text-inverted);\n}\n.va-file-upload-gallery-item {\n  display: flex;\n  position: relative;\n  margin-bottom: 1rem;\n  margin-right: 0.5rem;\n  flex-basis: calc(14.2857% - 0.5rem);\n  max-width: calc(14.2857% - 0.5rem);\n  min-width: 8.5714rem;\n  border-radius: 0.375rem;\n  overflow: hidden;\n  width: 100%;\n  align-items: stretch;\n}\n@media (max-width: 991.98px) {\n.va-file-upload-gallery-item {\n    flex-basis: calc(16.667% - 0.5rem);\n    max-width: calc(16.667% - 0.5rem);\n}\n}\n@media (max-width: 767.98px) {\n.va-file-upload-gallery-item {\n    flex-basis: calc(20% - 0.5rem);\n    max-width: calc(20% - 0.5rem);\n}\n}\n@media (max-width: 575.98px) {\n.va-file-upload-gallery-item {\n    flex-basis: calc(50% - 0.5rem);\n    max-width: calc(50% - 0.5rem);\n}\n}\n.va-file-upload-gallery-item:last-of-type {\n  margin-right: 0;\n}\n.va-file-upload-gallery-item:hover .va-file-upload-gallery-item__overlay, .va-file-upload-gallery-item:focus .va-file-upload-gallery-item__overlay, .va-file-upload-gallery-item--focused .va-file-upload-gallery-item__overlay {\n  z-index: 3;\n  opacity: 1;\n}\n.va-file-upload-gallery-item:hover .va-file-upload-gallery-item__name, .va-file-upload-gallery-item:focus .va-file-upload-gallery-item__name, .va-file-upload-gallery-item--focused .va-file-upload-gallery-item__name {\n  color: var(--va-file-upload-gallery-item-text-hover);\n}\n.va-file-upload-gallery-item__overlay {\n  display: flex;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  top: 0;\n  left: 0;\n  flex-direction: column;\n  padding: 0.5rem;\n  z-index: -1;\n  opacity: 0;\n}\n.va-file-upload-gallery-item__overlay-background {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  top: 0;\n  left: 0;\n  z-index: -1;\n}\n.va-file-upload-gallery-item__image {\n  width: 100%;\n  box-shadow: var(--va-box-shadow);\n  object-fit: cover;\n  z-index: 1;\n}\n.va-file-upload-gallery-item__name {\n  color: var(--va-file-upload-gallery-item-text);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 0.875rem;\n}\n.va-file-upload-gallery-item__delete {\n  cursor: pointer;\n  font-size: 1.5rem;\n  margin-top: auto;\n}\n.va-file-upload-gallery-item--not-image .va-file-upload-gallery-item__overlay {\n  display: flex;\n}\n.va-file-upload-gallery-item--undo .va-list-item__inner {\n  display: flex;\n  align-items: flex-start;\n  position: relative;\n}\n.va-file-upload-gallery-item--undo .va-list-item-section {\n  height: inherit;\n  padding: 0;\n}\n.va-file-upload-gallery-item--undo .va-file-upload-undo {\n  flex: 1;\n}";
var INJECTION_ERROR_MESSAGE3 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
var _sfc_main101 = defineComponent({
  name: "VaFileUploadGalleryItem",
  components: {
    VaFileUploadUndo,
    VaButton: VaButton2,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE3);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      var _a;
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, (_a = undoDuration.value) != null ? _a : 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e) => {
          var _a, _b;
          if (((_a = e.target) == null ? void 0 : _a.result).includes("image")) {
            previewImage.value = (_b = e.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    return {
      ...useTranslation(),
      undo,
      ...useTextColor(toRef(props, "color")),
      removed,
      disabled,
      isFocused,
      previewImage,
      classesComputed,
      overlayStylesComputed,
      onBlur,
      onFocus,
      removeImage,
      recoverImage
    };
  }
});
var _hoisted_164 = ["src", "alt"];
var _hoisted_235 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_319 = ["title"];
function _sfc_render98(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-gallery-item", _ctx.classesComputed]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    onFocus: _ctx.onFocus,
    onBlur: _ctx.onBlur
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, {
            vertical: "",
            onRecover: _ctx.recoverImage
          }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          _ctx.previewImage ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.previewImage,
            alt: _ctx.file.name || "",
            class: "va-file-upload-gallery-item__image"
          }, null, 8, _hoisted_164)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_235, [
            createBaseVNode("div", {
              class: "va-file-upload-gallery-item__overlay-background",
              style: normalizeStyle(_ctx.overlayStylesComputed)
            }, null, 4),
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-file-upload-gallery-item__name",
              title: _ctx.file.name,
              style: normalizeStyle({ color: _ctx.textColorComputed })
            }, toDisplayString(_ctx.file.name), 13, _hoisted_319)) : createCommentVNode("", true),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "va-delete",
              class: "va-file-upload-gallery-item__delete",
              "aria-label": _ctx.t("removeFile"),
              onClick: _ctx.removeImage,
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["aria-label", "onClick", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
}
var _VaFileUploadGalleryItem = _export_sfc(_sfc_main101, [["render", _sfc_render98], ["styles", [...VaFileUploadUndo.styles || [], ...VaButton2.styles || [], ...VaListItem.styles || [], ...VaListItemSection.styles || [], _style_094]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadGalleryItem/index.js
var VaFileUploadGalleryItem = withConfigTransport(_VaFileUploadGalleryItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.js
var _style_095 = ".va-file-upload-single-item {\n  width: 100%;\n}\n.va-file-upload-single-item__content {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  max-width: 100%;\n  width: 100%;\n}\n.va-file-upload-single-item__name {\n  margin-right: 0.25rem;\n  max-width: 80%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  line-height: normal;\n}\n.va-file-upload-single-item__button {\n  margin-top: 0;\n  margin-bottom: 0;\n  font-weight: 700;\n}";
var INJECTION_ERROR_MESSAGE4 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
var _sfc_main102 = defineComponent({
  name: "VaFileUploadSingleItem",
  components: {
    VaButton: VaButton2,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null }
  },
  setup: () => ({
    ...useTranslation(),
    disabled: useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE4).disabled
  })
});
var _hoisted_165 = { class: "va-file-upload-single-item__name" };
var _hoisted_236 = createTextVNode(" Delete ");
function _sfc_render99(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    class: "va-file-upload-single-item",
    tabindex: "-1"
  }, {
    default: withCtx(() => [
      createVNode(_component_va_list_item_section, { class: "va-file-upload-single-item__content" }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_165, toDisplayString(_ctx.file && _ctx.file.name), 1),
          !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
            key: 0,
            class: "va-file-upload-single-item__button",
            "aria-label": _ctx.t("removeFile"),
            size: "small",
            color: "danger",
            flat: "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
          }, {
            default: withCtx(() => [
              _hoisted_236
            ]),
            _: 1
          }, 8, ["aria-label"])) : createCommentVNode("", true)
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["disabled", "aria-disabled"]);
}
var _VaFileUploadSingleItem = _export_sfc(_sfc_main102, [["render", _sfc_render99], ["styles", [...VaButton2.styles || [], ...VaListItem.styles || [], ...VaListItemSection.styles || [], _style_095]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadSingleItem/index.js
var VaFileUploadSingleItem = withConfigTransport(_VaFileUploadSingleItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
var _style_096 = ".va-file-upload-list {\n  display: flex;\n  flex-wrap: wrap;\n  padding: 0 0 1.5rem;\n}\n.va-file-upload-list--gallery {\n  padding-bottom: 0.5rem;\n}";
var _sfc_main103 = defineComponent({
  name: "VaFileUploadList",
  components: {
    VaList,
    VaFileUploadListItem,
    VaFileUploadGalleryItem,
    VaFileUploadSingleItem
  },
  emits: ["remove", "removeSingle"],
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    color: { type: String, default: "success" }
  },
  setup(props) {
    const filesList = computed(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    const formatDate = (date = new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    return {
      filesList
    };
  }
});
function _sfc_render100(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_list_item = resolveComponent("va-file-upload-list-item");
  const _component_va_file_upload_gallery_item = resolveComponent("va-file-upload-gallery-item");
  const _component_va_file_upload_single_item = resolveComponent("va-file-upload-single-item");
  const _component_va_list = resolveComponent("va-list");
  return openBlock(), createBlock(_component_va_list, {
    class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${_ctx.type}`]),
    role: _ctx.type !== "single" ? "list" : void 0
  }, {
    default: withCtx(() => [
      _ctx.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_list_item, {
          key: file.name,
          file,
          color: _ctx.color,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }, null, 8, ["file", "color", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_gallery_item, {
          key: file.name,
          file,
          color: _ctx.color,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }, null, 8, ["file", "color", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "single" && _ctx.filesList.length ? (openBlock(), createBlock(_component_va_file_upload_single_item, {
        key: 2,
        file: _ctx.filesList[_ctx.filesList.length - 1],
        onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
      }, null, 8, ["file"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["role", "class"]);
}
var _VaFileUploadList = _export_sfc(_sfc_main103, [["render", _sfc_render100], ["styles", [...VaList.styles || [], ...VaFileUploadListItem.styles || [], ...VaFileUploadGalleryItem.styles || [], ...VaFileUploadSingleItem.styles || [], _style_096]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadList/index.js
var VaFileUploadList = withConfigTransport(_VaFileUploadList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUpload.js
var _style_097 = ':root,\n:host {\n  --va-file-upload-position: relative;\n  --va-file-upload-margin: 0.5rem 0;\n  --va-file-upload-list-margin-top: 1rem;\n  --va-file-upload-dropzone-border-radius: 0.375rem;\n  --va-file-upload-dropzone-cursor: pointer;\n  --va-file-upload-dropzone-text-padding-sm: 0 0 1rem;\n  --va-file-upload-dropzone-field-padding: 1.5rem 2rem;\n  --va-file-upload-dropzone-field-padding-sm: 1.5rem 1rem;\n  --va-file-upload-dropzone-field-button-margin: 0;\n  --va-file-upload-dropzone-field-button-z-index: 10;\n  --va-file-upload-dropzone-field-text-pr: 10px;\n  --va-file-upload-dropzone-list-padding: 0 2rem 1rem;\n}\n.va-file-upload {\n  position: var(--va-file-upload-position);\n  font-family: var(--va-font-family);\n  margin: var(--va-file-upload-margin);\n}\n.va-file-upload .va-file-upload-list {\n  margin-top: var(--va-file-upload-list-margin-top);\n}\n.va-file-upload__field {\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  position: relative;\n}\n.va-file-upload__field__button {\n  margin: var(--va-file-upload-dropzone-field-button-margin);\n  z-index: 10;\n}\n.va-file-upload__field__text {\n  padding-right: var(--va-file-upload-dropzone-field-text-pr);\n}\n.va-file-upload__field__input {\n  position: absolute;\n  top: 0;\n  right: 0;\n  height: 100%;\n  width: 100%;\n  color: transparent;\n  opacity: 0;\n  cursor: pointer;\n}\n.va-file-upload__field__input::-webkit-file-upload-button {\n  cursor: pointer;\n}\n.va-file-upload--dropzone {\n  background-color: var(--va-file-upload-dropzone-background-color);\n  overflow: hidden;\n  border-radius: var(--va-file-upload-dropzone-border-radius);\n  cursor: var(--va-file-upload-dropzone-cursor);\n}\n.va-file-upload--dropzone .va-file-upload__field {\n  justify-content: center;\n  display: flex;\n  align-items: center;\n  padding: var(--va-file-upload-dropzone-field-padding);\n  transition: height 0.2s;\n  overflow: visible;\n  flex-wrap: wrap;\n}\n@media (max-width: 767.98px) {\n.va-file-upload--dropzone .va-file-upload__field {\n    flex-direction: column;\n    padding: var(--va-file-upload-dropzone-field-padding-sm);\n}\n.va-file-upload--dropzone .va-file-upload__field__text {\n    padding: var(--va-file-upload-dropzone-text-padding-sm);\n    text-align: center;\n}\n}\n.va-file-upload--dropzone .va-file-upload-list {\n  padding: var(--va-file-upload-dropzone-list-padding);\n  margin-top: 0;\n}\n.va-file-upload--disabled .va-file-upload__field__input {\n  cursor: default;\n}\n.va-file-upload--disabled .va-file-upload__field__input::-webkit-file-upload-button {\n  cursor: inherit;\n}\n.va-file-upload .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _sfc_main104 = defineComponent({
  name: "VaFileUpload",
  components: {
    VaModal,
    VaButton: VaButton2,
    VaFileUploadList
  },
  props: {
    ...useComponentPresetProp,
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    undoButtonText: { type: String, default: "$t:undo" },
    dropZoneText: { type: String, default: "$t:dropzone" },
    uploadButtonText: { type: String, default: "$t:uploadFile" },
    deletedFileMessage: { type: String, default: "$t:fileDeleted" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(props, { emit }) {
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const validateFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t) => props.fileTypes.includes(t));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e) => {
      var _a, _b;
      const f = ((_a = e.target) == null ? void 0 : _a.files) || ((_b = e.dataTransfer) == null ? void 0 : _b.files);
      if (!f) {
        return;
      }
      const validatedFiles = props.fileTypes ? validateFiles(Array.from(f)) : f;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e) => {
      uploadFile(e);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        files.value = validateFiles(files.value);
      }
    });
    const { tp } = useTranslation();
    provide(VaFileUploadKey, {
      undo: toRef(props, "undo"),
      disabled: toRef(props, "disabled"),
      undoDuration: toRef(props, "undoDuration"),
      undoButtonText: computed(() => tp(props.undoButtonText)),
      deletedFileMessage: computed(() => tp(props.deletedFileMessage))
    });
    return {
      modal,
      dropzoneHighlight,
      fileInputRef,
      colorComputed,
      computedStyle,
      computedClasses,
      files,
      tp,
      uploadFile,
      changeFieldValue,
      removeFile,
      removeSingleFile,
      callFileDialogue
    };
  }
});
var _hoisted_166 = { class: "va-file-upload__field" };
var _hoisted_237 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_320 = ["accept", "multiple", "disabled"];
function _sfc_render101(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_file_upload_list = resolveComponent("va-file-upload-list");
  const _component_va_modal = resolveComponent("va-modal");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-file-upload", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode("div", _hoisted_166, [
        _ctx.dropzone ? (openBlock(), createElementBlock("div", _hoisted_237, toDisplayString(_ctx.tp(_ctx.dropZoneText)), 1)) : createCommentVNode("", true),
        createVNode(_component_va_button, {
          class: "va-file-upload__field__button",
          disabled: _ctx.disabled,
          "aria-disabled": _ctx.disabled,
          color: _ctx.colorComputed,
          style: normalizeStyle({ "pointer-events": _ctx.dropzoneHighlight ? "none" : void 0 }),
          onChange: _ctx.changeFieldValue,
          onClick: _ctx.callFileDialogue
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.tp(_ctx.uploadButtonText)), 1)
          ]),
          _: 1
        }, 8, ["disabled", "aria-disabled", "color", "style", "onChange", "onClick"])
      ])
    ]),
    createBaseVNode("input", {
      ref: "fileInputRef",
      type: "file",
      class: "va-file-upload__field__input",
      tabindex: -1,
      "aria-hidden": "true",
      accept: _ctx.fileTypes,
      multiple: _ctx.type !== "single",
      disabled: _ctx.disabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.changeFieldValue && _ctx.changeFieldValue(...args)),
      onDragenter: _cache[1] || (_cache[1] = ($event) => _ctx.dropzoneHighlight = true),
      onDragleave: _cache[2] || (_cache[2] = ($event) => _ctx.dropzoneHighlight = false)
    }, null, 40, _hoisted_320),
    _ctx.files.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(_component_va_file_upload_list, {
      key: 0,
      type: _ctx.type,
      files: _ctx.files,
      color: _ctx.colorComputed,
      onRemove: _ctx.removeFile,
      onRemoveSingle: _ctx.removeSingleFile
    }, null, 8, ["type", "files", "color", "onRemove", "onRemoveSingle"])) : createCommentVNode("", true),
    createVNode(_component_va_modal, {
      modelValue: _ctx.modal,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.modal = $event),
      "hide-default-actions": "",
      title: "File validation",
      message: "File type is incorrect!"
    }, null, 8, ["modelValue"])
  ], 6);
}
var _VaFileUpload = _export_sfc(_sfc_main104, [["render", _sfc_render101], ["styles", [...VaModal.styles || [], ...VaButton2.styles || [], ...VaFileUploadList.styles || [], _style_097]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/index.js
var VaFileUpload = withConfigTransport(_VaFileUpload);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.js
var _style_098 = ':root,\n:host {\n  --va-tree-node-contents-gap: 8px;\n  --va-tree-node-padding: 6px;\n  --va-tree-node-border-radius: 4px;\n  --va-tree-node-indent: 28px;\n  --va-tree-node-content-item-flex: 0 0 var(--va-tree-node-indent);\n  --va-tree-node-content-body-item-flex: 1;\n  --va-tree-node-interactive-bg-opacity: 0.1;\n  --va-tree-node-children-background: linear-gradient(#adb3b9 33%, rgba(255, 255, 255, 0) 0%) 15px/1px 3px repeat-y transparent;\n}\n.va-tree-node-root {\n  display: flex;\n  padding: var(--va-tree-node-padding);\n  position: relative;\n}\n.va-tree-node-root::before {\n  content: "";\n  background-color: var(--va-primary);\n  border-radius: var(--va-tree-node-border-radius);\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.va-tree-node-root:hover::before {\n  opacity: var(--va-tree-node-interactive-bg-opacity);\n}\n.va-tree-node-content {\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: center;\n  width: 100%;\n}\n.va-tree-node-content__item {\n  flex: var(--va-tree-node-content-item-flex);\n  min-width: var(--va-tree-node-indent);\n  line-height: 1;\n}\n.va-tree-node-content__item--leaf {\n  cursor: pointer;\n}\n.va-tree-node-content__body {\n  flex: var(--va-tree-node-content-body-item-flex);\n  width: 100%;\n}\n.va-tree-node-content--indent {\n  margin-left: var(--va-tree-node-indent);\n}\n.va-tree-node-children {\n  display: none;\n  background: var(--va-tree-node-children-background);\n  padding-left: var(--va-tree-node-indent);\n  width: 100%;\n}\n.va-tree-node-children--expanded {\n  display: block;\n}\n.va-tree-node__checkbox {\n  --va-checkbox-input-padding: 0;\n}\n.va-tree-node--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-tree-node--disabled .va-tree-node-content__item--leaf {\n  cursor: pointer;\n  pointer-events: all;\n}\n.va-tree-node:focus-visible > .va-tree-node-root {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-tree-node:focus-visible > .va-tree-node-root::before {\n  opacity: var(--va-tree-node-interactive-bg-opacity);\n}';
var INJECTION_ERROR_MESSAGE5 = "The VaTreeNode component should be used in the context of VaTreeView component";
var _sfc_main105 = defineComponent({
  name: "VaTreeNode",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  components: { VaCheckbox, VaIcon: VaIcon2 },
  setup: (props) => {
    const {
      iconBy,
      selectable,
      expandNodeBy,
      colorComputed,
      selectedNodeComputed,
      getText,
      getTrackBy,
      toggleNode,
      toggleCheckbox,
      getNodeProperty,
      handleKeyboardNavigation
    } = useStrictInject(TreeViewKey, INJECTION_ERROR_MESSAGE5);
    const labelComputed = computed(() => getText(props.node) || "");
    const isExpandedComputed = computed(() => props.node.hasChildren ? !!props.node.expanded : void 0);
    const iconComputed = computed(() => getNodeProperty(props.node, iconBy));
    const roleComputed = computed(() => props.node.hasChildren ? "group" : "treeitem");
    const treeNodeClassComputed = useBem("va-tree-node", () => ({
      disabled: !!props.node.disabled
    }));
    const expandedClassComputed = useBem("va-tree-node-children", () => ({
      expanded: !!isExpandedComputed.value
    }));
    const indentClassComputed = useBem("va-tree-node-content", () => ({
      indent: props.node.hasChildren === false
    }));
    const tabIndexComputed = computed(() => props.node.disabled ? -1 : 0);
    const onNodeClick = (type) => {
      const nodeType = expandNodeBy === "node" && type === "leaf" ? "node" : type;
      if (expandNodeBy === nodeType) {
        toggleNode(props.node);
      }
      selectedNodeComputed.value = props.node;
    };
    return {
      selectable,
      expandNodeBy,
      getText,
      getTrackBy,
      toggleNode,
      onNodeClick,
      handleKeyboardNavigation,
      toggleCheckbox,
      roleComputed,
      iconComputed,
      labelComputed,
      colorComputed,
      tabIndexComputed,
      indentClassComputed,
      isExpandedComputed,
      expandedClassComputed,
      treeNodeClassComputed
    };
  }
});
var _hoisted_167 = ["role", "aria-expanded", "aria-disabled", "aria-checked", "tabindex"];
var _hoisted_238 = { class: "va-tree-node-root" };
var _hoisted_321 = {
  key: 2,
  class: "va-tree-node-content__item"
};
var _hoisted_413 = { class: "va-tree-node-content__body" };
var _hoisted_510 = ["aria-hidden"];
function _sfc_render102(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_tree_node = resolveComponent("va-tree-node", true);
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tree-node", _ctx.treeNodeClassComputed]),
    role: _ctx.roleComputed,
    "aria-expanded": _ctx.isExpandedComputed,
    "aria-disabled": _ctx.$props.node.disabled,
    "aria-checked": !!_ctx.$props.node.checked,
    tabindex: _ctx.tabIndexComputed,
    onKeydown: [
      _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["up"])),
      _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["right"])),
      _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["down"])),
      _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["left"])),
      _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["space"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["esc"]))
    ]
  }, [
    createBaseVNode("div", _hoisted_238, [
      createBaseVNode("div", {
        class: normalizeClass(["va-tree-node-content", _ctx.indentClassComputed]),
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.onNodeClick("node"))
      }, [
        _ctx.$props.node.hasChildren ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-tree-node-content__item va-tree-node-content__item--leaf",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.onNodeClick("leaf"), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "icon-toggle", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_icon, {
              name: _ctx.isExpandedComputed ? "keyboard_arrow_down" : "keyboard_arrow_right",
              size: "20px"
            }, null, 8, ["name"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.selectable ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "va-tree-node-content__item",
          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "checkbox", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_checkbox, {
              "model-value": _ctx.$props.node.checked,
              color: _ctx.colorComputed,
              indeterminate: "",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => _ctx.toggleCheckbox(_ctx.$props.node, v)),
              class: "va-tree-node__checkbox"
            }, null, 8, ["model-value", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.iconComputed ? (openBlock(), createElementBlock("div", _hoisted_321, [
          renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_icon, {
              name: _ctx.iconComputed,
              size: "small"
            }, null, 8, ["name"])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_413, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createTextVNode(toDisplayString(_ctx.labelComputed), 1)
          ])
        ])
      ], 2)
    ]),
    withDirectives(createBaseVNode("div", {
      "aria-hidden": !_ctx.$props.node.expanded,
      class: normalizeClass(["va-tree-node-children", _ctx.expandedClassComputed])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.node.children, (childNode) => {
        return openBlock(), createBlock(_component_va_tree_node, {
          key: _ctx.getTrackBy(childNode),
          node: childNode
        }, createSlots({ _: 2 }, [
          renderList(_ctx.$slots, (_, name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          })
        ]), 1032, ["node"]);
      }), 128))
    ], 10, _hoisted_510), [
      [vShow, _ctx.$props.node.hasChildren]
    ])
  ], 42, _hoisted_167);
}
var _VaTreeNode = _export_sfc(_sfc_main105, [["render", _sfc_render102], ["styles", [...VaCheckbox.styles || [], ...VaIcon2.styles || [], _style_098]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/components/VaTreeNode/index.js
var VaTreeNode = withConfigTransport(_VaTreeNode);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/VaTreeView.js
var _style_099 = ":root,\n:host {\n  --va-tree-view-padding: 0.3125rem;\n}\n.va-tree-view {\n  padding: var(--va-tree-view-padding);\n  font-family: var(--va-font-family);\n}";
var _sfc_main106 = defineComponent({
  name: "VaTreeView",
  props: { ...useTreeViewProps },
  emits: [...useTreeViewEmits],
  components: { VaTreeNode },
  setup: (props, { emit }) => {
    const { treeItems, getTrackBy } = useTreeView(props, emit);
    return { treeItems, getTrackBy };
  }
});
var _hoisted_168 = {
  class: "va-tree-view",
  role: "tree"
};
var _hoisted_239 = createTextVNode("No matching nodes found");
function _sfc_render103(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_tree_node = resolveComponent("va-tree-node");
  return openBlock(), createElementBlock("div", _hoisted_168, [
    _ctx.$props.filter && !_ctx.treeItems.length ? renderSlot(_ctx.$slots, "not-found", { key: 0 }, () => [
      _hoisted_239
    ]) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.treeItems, (nodeItem) => {
      return openBlock(), createBlock(_component_va_tree_node, {
        key: _ctx.getTrackBy(nodeItem),
        node: nodeItem
      }, createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_, name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1032, ["node"]);
    }), 128))
  ]);
}
var _VaTreeView = _export_sfc(_sfc_main106, [["render", _sfc_render103], ["styles", [...VaTreeNode.styles || [], _style_099]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/index.js
var VaTreeView = withConfigTransport(_VaTreeView);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.js
var _style_0100 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: hidden;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar__item {\n  border-left: var(--va-sidebar-item-active-border-size) solid transparent;\n  padding-right: var(--va-sidebar-item-active-border-size);\n  display: inline-block;\n  width: 100%;\n  font-family: var(--va-font-family);\n  transition: var(--va-sidebar-item-transition);\n  box-sizing: border-box;\n  color: currentColor;\n}";
var _sfc_main107 = defineComponent({
  name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: Number, default: 0.2 },
    borderColor: { type: String, default: void 0 }
  },
  setup(props) {
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement);
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = { ...sidebar, ...props };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(
          getColor(props.hoverColor || props.activeColor),
          props.hoverOpacity
        );
      }
      return style;
    });
    const { tagComputed, hrefComputed } = useRouterLink(props);
    return {
      rootElement,
      computedStyle,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isHovered,
      backgroundColorComputed,
      bg: getColor(sidebar == null ? void 0 : sidebar.color),
      textBackground
    };
  }
});
function _sfc_render104(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "rootElement",
    class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to
  }, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "style", "href", "to"]);
}
var _VaSidebarItem = _export_sfc(_sfc_main107, [["render", _sfc_render104], ["styles", [_style_0100]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.js
var _style_0101 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: hidden;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar__item__content {\n  display: flex;\n  align-items: center;\n  padding: var(--va-sidebar-item-content-padding);\n  min-height: 58px;\n  box-sizing: border-box;\n}\n.va-sidebar__item__content > * {\n  margin-right: var(--va-sidebar-item-content-gap);\n}\n.va-sidebar__item__content > *:last-child {\n  margin-right: 0;\n}";
var _sfc_main108 = defineComponent({
  name: "VaSidebarItemContent"
});
var _hoisted_169 = { class: "va-sidebar__item__content va-sidebar-item-content" };
function _sfc_render105(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_169, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemContent = _export_sfc(_sfc_main108, [["render", _sfc_render105], ["styles", [_style_0101]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.js
var _style_0102 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: hidden;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar__title {\n  flex-grow: 1;\n  white-space: var(--va-sidebar-item-title-white-space);\n  transition: opacity 0.2s ease-in-out;\n}";
var _sfc_main109 = defineComponent({
  name: "VaSidebarItemTitle"
});
var _hoisted_170 = { class: "va-sidebar__title va-sidebar-item-title" };
function _sfc_render106(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_170, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemTitle = _export_sfc(_sfc_main109, [["render", _sfc_render106], ["styles", [_style_0102]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/index.js
var VaSidebarItemContent = withConfigTransport(_VaSidebarItemContent);
var VaSidebarItemTitle = withConfigTransport(_VaSidebarItemTitle);
var VaSidebarItem = withConfigTransport(_VaSidebarItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/components/VaTab/VaTab.js
var _style_0103 = ":root,\n:host {\n  --va-tab-align-items: center;\n  --va-tab-display: inline-flex;\n  --va-tab-flex: 0 1 auto;\n  --va-tab-font-weight: 600;\n  --va-tab-line-height: normal;\n  --va-tab-height: inherit;\n  --va-tab-max-width: 264px;\n  --va-tab-text-align: center;\n  --va-tab-vertical-align: middle;\n  --va-tab-color: inherit;\n  /* Content */\n  --va-tab-content-align-items: center;\n  --va-tab-content-color: inherit;\n  --va-tab-content-display: flex;\n  --va-tab-content-flex: 1 1 auto;\n  --va-tab-content-height: 100%;\n  --va-tab-content-justify-content: center;\n  --va-tab-content-max-width: inherit;\n  --va-tab-content-text-decoration: none;\n  --va-tab-content-transition: $transition-primary;\n  --va-tab-content-user-select: none;\n  --va-tab-content-white-space: nowrap;\n  --va-tab-content-padding: 0.275rem 0.75rem;\n  --va-tab-content-cursor: pointer;\n  /* Icon */\n  --va-tab-icon-margin-right: 0.5rem;\n}\n.va-tab {\n  align-items: var(--va-tab-align-items);\n  display: var(--va-tab-display);\n  flex: var(--va-tab-flex);\n  font-weight: var(--va-tab-font-weight);\n  line-height: var(--va-tab-line-height);\n  height: var(--va-tab-height);\n  max-width: var(--va-tab-max-width);\n  text-align: var(--va-tab-text-align);\n  vertical-align: var(--va-tab-vertical-align);\n  color: var(--va-tab-color);\n}\n.va-tab__content {\n  align-items: var(--va-tab-content-align-items);\n  color: var(--va-tab-content-color);\n  display: var(--va-tab-content-display);\n  flex: var(--va-tab-content-flex);\n  height: var(--va-tab-content-height);\n  justify-content: var(--va-tab-content-justify-content);\n  max-width: var(--va-tab-content-max-width);\n  -webkit-text-decoration: var(--va-tab-content-text-decoration);\n          text-decoration: var(--va-tab-content-text-decoration);\n  transition: var(--va-tab-content-transition);\n  -webkit-user-select: var(--va-tab-content-user-select);\n     -moz-user-select: var(--va-tab-content-user-select);\n          user-select: var(--va-tab-content-user-select);\n  white-space: var(--va-tab-content-white-space);\n  padding: var(--va-tab-content-padding);\n  cursor: var(--va-tab-content-cursor);\n}\n.va-tab__content:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n  outline-offset: -2px;\n}\n.va-tab__icon {\n  margin-right: var(--va-tab-icon-margin-right);\n}\n.va-tab.va-tab--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}";
var _sfc_main110 = defineComponent({
  name: "VaTab",
  components: { VaIcon: VaIcon2 },
  emits: ["click", "keydown-enter", "focus"],
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  },
  setup: (props, { emit }) => {
    const tabElement = shallowRef();
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { keyboardFocusListeners, hasKeyboardFocus } = useKeyboardOnlyFocus();
    const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props);
    const classComputed = computed(() => ({ "va-tab--disabled": props.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a, _b;
      const componentOffsetLeft = ((_a = tabElement.value) == null ? void 0 : _a.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const onTabClick = () => {
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = () => {
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return {
      tabElement,
      parentDisabled,
      isActive,
      hoverState,
      tagComputed,
      hrefComputed,
      isActiveRouterLink,
      colorComputed,
      classComputed,
      computedStyle,
      tabIndexComputed,
      rightSidePosition,
      leftSidePosition,
      updateHoverState,
      updateSidePositions,
      onTabClick,
      onTabKeydown,
      onFocus,
      keyboardFocusListeners
    };
  }
});
var _hoisted_171 = ["tabindex"];
var _hoisted_240 = ["textContent"];
function _sfc_render107(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    ref: "tabElement",
    class: normalizeClass(["va-tab", _ctx.classComputed]),
    role: "tab",
    "aria-selected": _ctx.isActive,
    "aria-disabled": _ctx.$props.disabled || _ctx.parentDisabled,
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.updateHoverState(false))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        class: "va-tab__content",
        tabindex: _ctx.tabIndexComputed,
        onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onTabClick && _ctx.onTabClick(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onTabKeydown && _ctx.onTabKeydown(...args), ["enter"]))
      }, toHandlers(_ctx.keyboardFocusListeners)), [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-tab__icon",
            size: "small",
            name: _ctx.icon
          }, null, 8, ["name"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: "va-tab__label",
            textContent: toDisplayString(_ctx.label)
          }, null, 8, _hoisted_240)
        ])
      ], 16, _hoisted_171)
    ]),
    _: 3
  }, 40, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]);
}
var _VaTab = _export_sfc(_sfc_main110, [["render", _sfc_render107], ["styles", [...VaIcon2.styles || [], _style_0103]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/components/VaTab/index.js
var VaTab = withConfigTransport(_VaTab);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.js
var _style_0104 = ":root,\n:host {\n  --va-timeline-separator-display: flex;\n  --va-timeline-separator-align-items: center;\n  /* Line */\n  --va-timeline-separator-line-transition: background-color ease 0.5s;\n  --va-timeline-separator-line-width: 0.125rem;\n  --va-timeline-separator-line-height: 0.125rem;\n  --va-timeline-separator-line-flex: 1;\n  /* Center */\n  --va-timeline-separator-center-transition: background-color ease 0.5s;\n  --va-timeline-separator-center-width: 0.5rem;\n  --va-timeline-separator-center-height: 0.5rem;\n  --va-timeline-separator-center-border-radius: 0.5rem;\n  /* Vertical */\n  --va-timeline-separator-vertical-flex-direction: column;\n}\n.va-timeline-separator {\n  display: var(--va-timeline-separator-display);\n  align-items: var(--va-timeline-separator-align-items);\n}\n.va-timeline-separator--vertical {\n  flex-direction: var(--va-timeline-separator-vertical-flex-direction);\n}\n.va-timeline-separator__line {\n  transition: var(--va-timeline-separator-line-transition);\n  width: var(--va-timeline-separator-line-width);\n  height: var(--va-timeline-separator-line-height);\n  flex: var(--va-timeline-separator-line-flex);\n}\n.va-timeline-separator__center {\n  transition: var(--va-timeline-separator-center-transition);\n  width: var(--va-timeline-separator-center-width);\n  height: var(--va-timeline-separator-center-height);\n  border-radius: var(--va-timeline-separator-center-border-radius);\n}";
var componentName = "va-timeline-separator";
var _sfc_main111 = defineComponent({
  name: componentName,
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props) {
    const { getColor } = useColors();
    return () => h(
      "div",
      {
        class: {
          [componentName]: true,
          [`${componentName}--vertical`]: props.vertical
        }
      },
      [
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activePrevious
          },
          style: {
            backgroundColor: getColor(props.activePrevious ? props.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__center`]: true,
            [`${componentName}__center--active`]: props.active
          },
          style: {
            backgroundColor: getColor(props.active ? props.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activeNext
          },
          style: {
            backgroundColor: getColor(props.activeNext ? props.color : "divider")
          }
        })
      ]
    );
  }
});
var _VaTimelineSeparator = _export_sfc(_sfc_main111, [["styles", [_style_0104]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineSeparator/index.js
var VaTimelineSeparator = withConfigTransport(_VaTimelineSeparator);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineItem/VaTimelineItem.js
var _style_0105 = ":root,\n:host {\n  --va-timeline-item-display: flex;\n  --va-timeline-item-flex-direction: column;\n  --va-timeline-item-vertical-flex-direction: row;\n  --va-timeline-item-vertical-flex-wrap: nowrap;\n  --va-timeline-item-vertical-align-items: stretch;\n  /* Title */\n  --va-timeline-item-title-text-align: center;\n  --va-timeline-item-title-color: var(--va-primary);\n  --va-timeline-item-title-font-weight: 700;\n  --va-timeline-item-title-font-size: 0.8rem;\n  --va-timeline-item-title-text-transform: uppercase;\n  /* Description */\n  --va-timeline-item-description-margin-top: 0.25rem;\n  --va-timeline-item-description-text-align: center;\n}\n.va-timeline-item {\n  display: var(--va-timeline-item-display);\n  flex-direction: var(--va-timeline-item-flex-direction);\n}\n.va-timeline-item__before, .va-timeline-item__after {\n  flex: 1;\n}\n.va-timeline-item--vertical {\n  flex-direction: var(--va-timeline-item-vertical-flex-direction);\n  flex-wrap: var(--va-timeline-item-vertical-flex-wrap);\n  align-items: var(--va-timeline-item-vertical-align-items);\n}\n.va-timeline-item--vertical .va-timeline-item__before,\n.va-timeline-item--vertical .va-timeline-item__after {\n  padding-top: 1rem;\n  padding-bottom: 1rem;\n}\n.va-timeline-item--vertical .va-timeline-item__before {\n  padding-right: 1rem;\n}\n.va-timeline-item--vertical .va-timeline-item__after {\n  padding-left: 1rem;\n}\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__before,\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__after {\n  padding-right: 1rem;\n  padding-left: 1rem;\n}\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__before {\n  padding-bottom: 0.5rem;\n}\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__after {\n  padding-top: 0.5rem;\n}";
var COMPONENT_NAME2 = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var _sfc_main112 = defineComponent({
  name: COMPONENT_NAME2,
  props: {
    ...useComponentPresetProp,
    ...VaTimelineSeparatorProps,
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  },
  setup(props, { slots }) {
    const children = [
      h(
        VaTimelineSeparator,
        { ...filterComponentProps(VaTimelineSeparatorProps).value }
      )
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(
        h(
          "div",
          { class: `${COMPONENT_NAME2}__before` },
          before()
        )
      );
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(
        h(
          "div",
          { class: `${COMPONENT_NAME2}__after` },
          after()
        )
      );
    }
    return () => h(
      "div",
      {
        class: [
          { [COMPONENT_NAME2]: true },
          { [`${COMPONENT_NAME2}--vertical`]: props.vertical },
          { [`${COMPONENT_NAME2}--is-first`]: props.isFirst },
          { [`${COMPONENT_NAME2}--is-last`]: props.isLast }
        ]
      },
      children
    );
  }
});
var _VaTimelineItem = _export_sfc(_sfc_main112, [["styles", [_style_0105]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineItem/index.js
var VaTimelineItem = withConfigTransport(_VaTimelineItem);

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/components.js
var vuesticComponents = Object.freeze(Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton: VaButton2,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardBlock,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFallback,
  VaFileUpload,
  VaForm,
  VaHover,
  VaIcon: VaIcon2,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaSelect,
  VaSeparator,
  VaSkeleton,
  VaSkeletonGroup,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaSwitch,
  VaTabs,
  VaTab,
  VaStepper,
  VaTimeInput,
  VaTimeline,
  VaTimelineItem,
  VaTimePicker,
  VaToast,
  VaTreeView,
  VaScrollContainer,
  VaViewer,
  VaVirtualScroller
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/create-vuestic/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app2) {
    const { config } = options;
    setCurrentApp(app2);
    Object.entries(vuesticComponents).forEach(([name, component]) => {
      app2.component(name, component);
    });
    usePlugin(app2, GlobalConfigPlugin(config));
    usePlugin(app2, CachePlugin);
    usePlugin(app2, ColorConfigPlugin(config));
    usePlugin(app2, ColorsClassesPlugin);
    usePlugin(app2, BreakpointConfigPlugin);
    usePlugin(app2, VaDropdownPlugin);
    usePlugin(app2, VaToastPlugin);
    usePlugin(app2, VaModalPlugin);
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/create-vuestic/create-vuestic-essential.js
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app2) {
    const { config, components, plugins } = options;
    setCurrentApp(app2);
    usePlugin(app2, (plugins == null ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app2, (plugins == null ? void 0 : plugins.CachePlugin) || CachePlugin);
    usePlugin(app2, (plugins == null ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin, config);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app2, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app2.component(name, component);
      });
    }
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementTextColor.js
var isRefString = (r) => typeof (r == null ? void 0 : r.value) === "string";
var useElementTextColor = (background) => {
  if (isRefString(background) || typeof background === "string") {
    const { textColorComputed: textColorComputed2 } = useTextColor(background);
    return textColorComputed2;
  }
  const { background: elBg } = useElementBackground(background);
  const { textColorComputed } = useTextColor(elBg);
  return textColorComputed;
};

// node_modules/vuestic-ui/dist/web-components/src/services/web-components/register-vuestic-web-components-essential.js
var componentsOrder = [
  "VaConfig",
  "VaForm",
  "VaAccordion",
  "VaFileUpload",
  "VaSidebar",
  "VaTabs"
];
var registerVuesticWebComponentsEssential = (options) => {
  const { css, components } = options;
  Object.entries(components).sort(([nameA], [nameB]) => {
    if (!componentsOrder.includes(nameA) && !componentsOrder.includes(nameB)) {
      return 0;
    }
    let indexA = componentsOrder.indexOf(nameA);
    let indexB = componentsOrder.indexOf(nameB);
    if (indexA === -1) {
      indexA = Number.MAX_SAFE_INTEGER;
    }
    if (indexB === -1) {
      indexB = Number.MAX_SAFE_INTEGER;
    }
    return indexA - indexB;
  }).forEach(([name, component]) => {
    const customElement = defineCustomElement(component);
    if (css && "styles" in component) {
      component.styles.push(css);
    }
    customElements.define(`${kebabCase_1(name)}`, customElement);
  });
};

// node_modules/vuestic-ui/dist/web-components/src/services/web-components/register-vuestic-web-components.js
var defaultCSS = `
.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-smoothing: antialiased;
}`;
var registerVuesticWebComponents = (options = {}) => {
  const { css = defaultCSS } = options;
  registerVuesticWebComponentsEssential({
    css,
    components: vuesticComponents
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/hooks/useModal.js
var useModal = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  return { init };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItem/index.js
var VaRatingItem = withConfigTransport(_VaRatingItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/hooks/useToast.js
var useToast = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext;
  const createdInThisSetupContext = [];
  const init = (options) => {
    const id = createToastInstance(options, appContext);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};
export {
  BreakpointConfigPlugin,
  CachePlugin,
  ColorConfigPlugin,
  ColorsClassesPlugin,
  GlobalConfigPlugin,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton2 as VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFallback,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadKey,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaHover,
  VaIcon2 as VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaScrollContainer,
  VaSelect,
  VaSelectOption,
  VaSelectOptionList,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaStepper,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeView,
  VaViewer,
  VaVirtualScroller,
  VuesticIconAliases,
  VuesticIconFonts,
  presets as colorsPreset,
  createIconsConfig,
  createVuestic,
  createVuesticEssential,
  defineVuesticConfig,
  registerVuesticWebComponents,
  registerVuesticWebComponentsEssential,
  defaultThresholds as thresholdsPreset,
  useBreakpoint,
  useColors,
  useElementTextColor,
  useGlobalConfig,
  useI18nConfig,
  useIcon as useIcons,
  useModal,
  useToast
};
//# sourceMappingURL=vuestic-ui_web-components.js.map
