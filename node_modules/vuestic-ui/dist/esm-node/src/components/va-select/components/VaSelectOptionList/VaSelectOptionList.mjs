import { defineComponent, shallowRef, computed, ref, watch, resolveComponent, openBlock, createElementBlock, withKeys, withModifiers, Fragment, renderList, toDisplayString, createCommentVNode, createBlock, withCtx, renderSlot, normalizeProps, guardReactiveProps, createVNode, mergeProps } from "vue";
import { p as pick_1 } from "../../../../../vendor.mjs";
import { e as extractHTMLElement } from "../../../../composables/useHTMLElement.mjs";
import { a as useColorProps } from "../../../../composables/useColors.mjs";
import { u as useComponentPresetProp } from "../../../../composables/useComponentPreset.mjs";
import { u as useObjectRefs } from "../../../../composables/useObjectRefs.mjs";
import { u as useSelectableListProps, a as useSelectableList } from "../../../../composables/useSelectableList.mjs";
import { u as useThrottleProps, a as useThrottleValue } from "../../../../composables/useThrottle.mjs";
import { s as scrollToElement } from "../../../../utils/scroll-to-element.mjs";
import { V as VaVirtualScroller } from "../../../va-virtual-scroller/index.mjs";
import { V as VaSelectOption } from "../VaSelectOption/index.mjs";
import { _ as _export_sfc } from "../../../../../plugin-vue_export-helper.mjs";
var VaSelectOptionList_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSelectOptionList",
  components: { VaVirtualScroller, VaSelectOption },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: { type: [String, Number, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const root = shallowRef();
    const focus = () => {
      var _a;
      (_a = root.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a, _b;
      return (_b = (_a = root.value) == null ? void 0 : _a.clientHeight) != null ? _b : 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => {
      var _a;
      return (_a = props.hoveredOption) != null ? _a : null;
    });
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const currentSelectedOptionText = computed(() => {
      var _a;
      const selected = (_a = props.options) == null ? void 0 : _a.find((option) => props.getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a;
      return currentSelectedOptionText.value.toLowerCase() === ((_a = props.search) == null ? void 0 : _a.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (!props.search || props.search.length < props.minSearchChars || isSearchedOptionSelected.value) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !getGroupBy(option)) {
        groups._noGroup.push(option);
      } else {
        const groupBy = getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !!value || value === 0;
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option != null ? option : null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option != null ? option : null, "keyboard");
    };
    const selectOption = (option) => !getDisabled(option) && emit("select-option", option);
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick_1(props, ["getSelectedState", "color", "search", "highlightMatchedText", "minSearchChars"]),
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value - 1, true));
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a;
      if (!isValueExists(option)) {
        return;
      }
      const element = itemRefs.value[getTrackBy(option)];
      if (element) {
        scrollToElement(extractHTMLElement(element));
      }
      if (props.virtualScroller) {
        (_a = virtualScrollerRef.value) == null ? void 0 : _a[0].virtualScrollTo(currentOptionIndex.value);
      }
    };
    const publicMethods = {
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    return {
      root,
      virtualScrollerRef,
      rootHeight,
      optionGroups: optionGroupsThrottled,
      filteredOptions,
      selectOptionProps,
      currentOptionComputed,
      onScroll,
      getTrackBy,
      setItemRef,
      getDisabled,
      selectOption,
      updateHoveredOption,
      handleScrollToBottom,
      ...publicMethods
    };
  }
});
const _hoisted_1 = ["tabindex"];
const _hoisted_2 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
const _hoisted_3 = {
  key: 0,
  class: "va-select-option-list--empty"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_select_option = resolveComponent("va-select-option");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        _ctx.$props.virtualScroller ? (openBlock(), createBlock(_component_va_virtual_scroller, {
          key: 1,
          ref_for: true,
          ref: "virtualScrollerRef",
          items: options,
          "track-by": _ctx.getTrackBy,
          "wrapper-size": _ctx.rootHeight,
          "onScroll:bottom": _ctx.handleScrollToBottom
        }, {
          default: withCtx(({ item: option, index }) => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, index, selectOption: _ctx.selectOption })), () => [
              createVNode(_component_va_select_option, mergeProps({
                option,
                "current-option": _ctx.currentOptionComputed,
                disabled: _ctx.getDisabled(option)
              }, _ctx.selectOptionProps, {
                onClick: withModifiers(($event) => _ctx.selectOption(option), ["stop"]),
                onMousemove: ($event) => _ctx.updateHoveredOption(option)
              }), null, 16, ["option", "current-option", "disabled", "onClick", "onMousemove"])
            ])
          ]),
          _: 2
        }, 1032, ["items", "track-by", "wrapper-size", "onScroll:bottom"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
          return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
            key: _ctx.getTrackBy(option)
          }, { option, index, selectOption: _ctx.selectOption })), () => [
            createVNode(_component_va_select_option, mergeProps({
              ref_for: true,
              ref: _ctx.setItemRef(_ctx.getTrackBy(option)),
              "current-option": _ctx.currentOptionComputed,
              option,
              disabled: _ctx.getDisabled(option)
            }, _ctx.selectOptionProps, {
              onClick: withModifiers(($event) => _ctx.selectOption(option), ["stop"]),
              onMousemove: ($event) => _ctx.updateHoveredOption(option)
            }), null, 16, ["current-option", "option", "disabled", "onClick", "onMousemove"])
          ]);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_3, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_1);
}
var _VaSelectOptionList = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSelectOptionList as _ };
//# sourceMappingURL=VaSelectOptionList.mjs.map
