import { defineComponent, shallowRef, ref, toRefs, computed, watch, nextTick, resolveComponent, openBlock, createBlock, mergeProps, withCtx, renderSlot, normalizeProps, guardReactiveProps, createVNode, withModifiers, createSlots, createElementVNode, toHandlers, withKeys, createCommentVNode, renderList } from "vue";
import { o as omit_1 } from "../../../vendor.mjs";
import { e as extractComponentProps, a as extractComponentEmits } from "../../utils/component-options/extract-component-options.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.mjs";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { a as useFocusEmits, u as useFocus } from "../../composables/useFocus.mjs";
import { u as useParsable } from "../../composables/useParsable.mjs";
import { u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from "../../composables/useValidation.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useSyncProp } from "../va-date-picker/hooks/sync-prop.mjs";
import { u as useRangeModelValueGuard } from "./hooks/range-model-value-guard.mjs";
import { u as useDateParser } from "./hooks/input-text-parser.mjs";
import { i as isDates, a as isSingleDate, b as isRange } from "../va-date-picker/utils/date-utils.mjs";
import { _ as _VaDatePicker } from "../va-date-picker/VaDatePicker.mjs";
import { V as VaDropdown } from "../va-dropdown/index.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.mjs";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.mjs";
var VaDateInput_vue_vue_type_style_index_0_lang = "";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue", "disabled"]);
const VaDatePickerProps = extractComponentProps(_VaDatePicker);
const VaDropdownProps = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "offset", "keyboardNavigation", "closeOnContentClick", "modelValue"]
);
const _sfc_main = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon
  },
  props: {
    ...VaDropdownProps,
    ...useClearableProps,
    ...VaInputWrapperProps,
    ...VaDatePickerProps,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" }
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp(isOpen, "is-open", emit, false);
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      ariaHidden: false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const computedInputWrapperProps = computed(() => ({
      ...filterComponentProps(VaInputWrapperProps).value,
      focused: isFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { t } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || t("selectedDate"),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit_1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps).value,
      offset: [2, 0],
      stateful: false,
      keyboardNavigation: true,
      closeOnContentClick: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      t,
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      isFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(VaDatePickerProps),
      dropdownPropsComputed,
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      cursorStyleComputed,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.isOpenSync = $event),
    class: ["va-date-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed, {
    onOpen: _ctx.focusDatePicker,
    onClose: _ctx.focus
  }), {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputAttributes: _ctx.inputAttributesComputed, inputWrapperProps: _ctx.inputWrapperProps, inputListeners: _ctx.inputListeners })), () => [
        createVNode(_component_va_input_wrapper, mergeProps({
          class: "va-date-input__anchor",
          style: _ctx.cursorStyleComputed
        }, _ctx.inputWrapperProps, {
          onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
        }), createSlots({
          default: withCtx(() => [
            createElementVNode("input", mergeProps({
              ref: "input",
              class: "va-date-input__input"
            }, _ctx.inputAttributesComputed, toHandlers(_ctx.inputListeners), {
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
            }), null, 16)
          ]),
          icon: withCtx(() => [
            _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.t("resetDate")
            }, { ..._ctx.iconProps, ..._ctx.clearIconProps }, {
              onClick: withModifiers(_ctx.reset, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 1,
              "aria-label": _ctx.t("toggleDropdown")
            }, _ctx.iconProps, {
              onClick: withModifiers(_ctx.showDropdown, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.filterSlots, (name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          }),
          _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
            name: "prependInner",
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
              _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                "aria-label": _ctx.t("toggleDropdown")
              }, _ctx.iconProps, {
                onClick: withModifiers(_ctx.showDropdown, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
            ])
          } : void 0
        ]), 1040, ["style", "onClick"])
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, { class: "va-date-input__dropdown-content" }, {
        default: withCtx(() => [
          createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
            modelValue: _ctx.valueWithoutText,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueWithoutText = $event),
            "onClick:day": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:day", $event)),
            "onClick:month": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:month", $event)),
            "onClick:year": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:year", $event)),
            "onHover:day": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:day", $event)),
            "onHover:month": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:month", $event)),
            "onHover:year": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("hover:year", $event)),
            "onUpdate:view": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:view", $event))
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["modelValue"])
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style", "onOpen", "onClose"]);
}
var _VaDateInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaDateInput as _ };
//# sourceMappingURL=VaDateInput.mjs.map
