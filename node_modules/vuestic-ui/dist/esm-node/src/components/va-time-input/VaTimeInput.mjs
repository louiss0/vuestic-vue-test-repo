import { defineComponent, shallowRef, computed, nextTick, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createVNode, withModifiers, createSlots, createElementVNode, toHandlers, withKeys, createCommentVNode, renderList, renderSlot, normalizeProps, guardReactiveProps } from "vue";
import { o as omit_1 } from "../../../vendor.mjs";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.mjs";
import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { a as useFocusEmits, u as useFocus } from "../../composables/useFocus.mjs";
import { a as useValidationEmits, u as useValidationProps, b as useValidation } from "../../composables/useValidation.mjs";
import { u as useSyncProp } from "../../composables/useSyncProp.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useTimeParser } from "./hooks/time-text-parser.mjs";
import { u as useTimeFormatter } from "./hooks/time-text-formatter.mjs";
import { _ as _VaTimePicker } from "../va-time-picker/VaTimePicker.mjs";
import { V as VaIcon } from "../va-icon/VaIcon.mjs";
import { V as VaDropdown } from "../va-dropdown/index.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.mjs";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.mjs";
var VaTimeInput_vue_vue_type_style_index_0_lang = "";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue", "disabled"]);
const VaDropdownProps = extractComponentProps(
  VaDropdown,
  ["keyboardNavigation", "offset", "placement", "closeOnContentClick", "innerAnchorSelector", "modelValue"]
);
const _sfc_main = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    "update:modelValue",
    "update:isOpen"
  ],
  props: {
    ...VaDropdownProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...VaInputWrapperProps,
    ...extractComponentProps(_VaTimePicker),
    ...useValidationProps,
    isOpen: { type: Boolean, default: void 0 },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" }
  },
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
    const [modelValueSync] = useSyncProp("modelValue", props, emit);
    const { parse, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(modelValueSync.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a;
      if (props.disabled) {
        return;
      }
      const val = (_a = e.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v = parse(val);
      if (isValid.value && v) {
        modelValueSync.value = v;
      } else {
        modelValueSync.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const computedInputWrapperProps = computed(() => ({
      ...filterComponentProps(VaInputWrapperProps).value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const { t } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      "aria-label": props.label || t("selectedTime"),
      "aria-required": props.requiredMark,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit_1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps).value,
      closeOnContentClick: false,
      offset: [2, 0],
      keyboardNavigation: true,
      placement: "bottom-start",
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      t,
      input,
      timePicker,
      timePickerProps: filterComponentProps(extractComponentProps(_VaTimePicker)),
      dropdownPropsComputed,
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      modelValueSync,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      cursorStyleComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.doShowDropdown,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.doShowDropdown = $event),
    class: ["va-time-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({
        class: "va-time-input__anchor",
        style: _ctx.cursorStyleComputed
      }, _ctx.computedInputWrapperProps, {
        onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
      }), createSlots({
        default: withCtx(() => [
          createElementVNode("input", mergeProps({
            ref: "input",
            class: "va-time-input__input"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.computedInputListeners), {
            onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
          }), null, 16)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({ key: 0 }, { ..._ctx.iconProps, ..._ctx.clearIconProps }, {
            "aria-label": _ctx.t("resetTime"),
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            "aria-label": _ctx.t("toggleDropdown"),
            onClick: withModifiers(_ctx.showDropdown, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
            ]
          }, _ctx.iconProps), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))
            ])
          };
        }),
        _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
          name: "prependInner",
          fn: withCtx((slotScope) => [
            renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.t("toggleDropdown")
            }, _ctx.iconProps, {
              onClick: withModifiers(_ctx.showDropdown, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
          ])
        } : void 0
      ]), 1040, ["style", "onClick"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.modelValueSync = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown", "onKeypress"])
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style"]);
}
var _VaTimeInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaTimeInput as _ };
//# sourceMappingURL=VaTimeInput.mjs.map
