import { defineComponent, shallowRef, ref, computed, onMounted, watch, nextTick, openBlock, createElementBlock, mergeProps } from "vue";
import { p as pick_1 } from "../../../../../vendor.js";
import { u as useEmitProxy } from "../../../../composables/useEmitProxy.js";
import { u as useFormProps } from "../../../../composables/useForm.js";
import { u as useTextareaRowHeight } from "./useTextareaRowHeight.js";
import { _ as _export_sfc } from "../../../../../plugin-vue_export-helper.js";
var VaTextarea_vue_vue_type_style_index_0_lang = "";
const positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
const { createEmits, createListeners } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
const _sfc_main = defineComponent({
  name: "VaTextarea",
  props: {
    ...useFormProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    }
  },
  emits: createEmits(),
  setup(props, { emit }) {
    const textarea = shallowRef();
    const rowHeight = ref(-1);
    const height = ref(-1);
    const { calculateRowHeight, calculateHeight } = useTextareaRowHeight(textarea);
    const isResizable = computed(() => {
      return Boolean((props.autosize || props.maxRows || props.minRows !== 1) && textarea.value);
    });
    const updateRowHeight = () => {
      if (isResizable.value) {
        rowHeight.value = calculateRowHeight();
      }
    };
    const updateHeight = () => {
      if (isResizable.value) {
        height.value = calculateHeight();
      }
    };
    onMounted(() => {
      updateRowHeight();
      updateHeight();
    });
    watch(() => props.modelValue, () => {
      nextTick(updateHeight);
    });
    const computedStyle = computed(() => ({
      minHeight: rowHeight.value * props.minRows + "px",
      maxHeight: props.maxRows ? rowHeight.value * props.maxRows + "px" : void 0,
      height: height.value + "px",
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick_1(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    const focus = () => {
      var _a;
      (_a = textarea.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = textarea.value) == null ? void 0 : _a.blur();
    };
    return {
      textarea,
      computedStyle,
      listeners: createListeners(emit),
      computedProps,
      focus,
      blur
    };
  }
});
const _hoisted_1 = ["value"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", mergeProps({
    ref: "textarea",
    class: "textarea",
    style: _ctx.computedStyle
  }, { ..._ctx.computedProps, ..._ctx.listeners }, { value: _ctx.modelValue }), null, 16, _hoisted_1);
}
var VaTextarea = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { VaTextarea as V };

import './VaTextarea.css';
//# sourceMappingURL=VaTextarea.js.map
